{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"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","file":"chunk-DP4RSXR5.js","sourcesContent":["import { createHash } from 'crypto';\nimport { convertToCoreMessages } from 'ai';\nimport type { CoreMessage, ToolExecutionOptions } from 'ai';\nimport jsonSchemaToZod from 'json-schema-to-zod';\nimport { z } from 'zod';\nimport type { ZodObject } from 'zod';\n\nimport type { MastraPrimitives } from './action';\nimport type { ToolsInput } from './agent';\nimport type { Logger } from './logger';\nimport type { Mastra } from './mastra';\nimport type { AiMessageType, MastraMemory } from './memory';\nimport { Tool } from './tools';\nimport type { CoreTool, ToolAction, VercelTool } from './tools';\n\nexport const delay = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\nexport function jsonSchemaPropertiesToTSTypes(value: any): z.ZodTypeAny {\n  if (!value.type) {\n    return z.object({});\n  }\n\n  // Handle case where type is an array of strings\n  if (Array.isArray(value.type)) {\n    const types = value.type.map((type: string) => {\n      return jsonSchemaPropertiesToTSTypes({ ...value, type });\n    });\n    return z\n      .union(types)\n      .describe((value.description || '') + (value.examples ? `\\nExamples: ${value.examples.join(', ')}` : ''));\n  }\n\n  let zodType;\n  switch (value.type) {\n    case 'string':\n      zodType = z\n        .string()\n        .describe((value.description || '') + (value.examples ? `\\nExamples: ${value.examples.join(', ')}` : ''));\n      break;\n    case 'number':\n      zodType = z\n        .number()\n        .describe((value.description || '') + (value.examples ? `\\nExamples: ${value.examples.join(', ')}` : ''));\n      break;\n    case 'integer':\n      zodType = z\n        .number()\n        .int()\n        .describe((value.description || '') + (value.examples ? `\\nExamples: ${value.examples.join(', ')}` : ''));\n      break;\n    case 'boolean':\n      zodType = z\n        .boolean()\n        .describe((value.description || '') + (value.examples ? `\\nExamples: ${value.examples.join(', ')}` : ''));\n      break;\n    case 'array':\n      zodType = z\n        .array(jsonSchemaPropertiesToTSTypes(value.items))\n        .describe((value.description || '') + (value.examples ? `\\nExamples: ${value.examples.join(', ')}` : ''));\n      break;\n    case 'object':\n      zodType = jsonSchemaToModel(value).describe(\n        (value.description || '') + (value.examples ? `\\nExamples: ${value.examples.join(', ')}` : ''),\n      );\n      break;\n    case 'null':\n      zodType = z.null().describe(value.description || '');\n      break;\n    default:\n      throw new Error(`Unsupported JSON schema type: ${value.type}`);\n  }\n\n  return zodType;\n}\n\nexport function jsonSchemaToModel(jsonSchema: Record<string, any>): ZodObject<any> {\n  const properties = jsonSchema.properties;\n  const requiredFields = jsonSchema.required || [];\n  if (!properties) {\n    return z.object({});\n  }\n\n  const zodSchema: Record<string, any> = {};\n  for (const [key, _] of Object.entries(properties)) {\n    const value = _ as any;\n    let zodType;\n    if (value.anyOf) {\n      const anyOfTypes = value.anyOf.map((schema: any) => jsonSchemaPropertiesToTSTypes(schema));\n      zodType = z\n        .union(anyOfTypes)\n        .describe((value.description || '') + (value.examples ? `\\nExamples: ${value.examples.join(', ')}` : ''));\n    } else if (value.allOf) {\n      const allOfTypes = value.allOf.map((schema: any) => jsonSchemaPropertiesToTSTypes(schema));\n      zodType = z\n        .intersection(\n          allOfTypes[0],\n          allOfTypes.slice(1).reduce((acc: z.ZodTypeAny, schema: z.ZodTypeAny) => acc.and(schema), allOfTypes[0]),\n        )\n        .describe((value.description || '') + (value.examples ? `\\nExamples: ${value.examples.join(', ')}` : ''));\n    } else {\n      if (!value.type) {\n        value.type = 'string';\n      }\n      zodType = jsonSchemaPropertiesToTSTypes(value);\n    }\n\n    if (value.description) {\n      zodType = zodType.describe(value.description);\n    }\n\n    // Add check for null type requiring the field\n    const isTypeRequired = value.type === 'null';\n\n    if (requiredFields.includes(key) || isTypeRequired) {\n      zodSchema[key] = zodType;\n    } else {\n      zodSchema[key] = zodType.nullable().optional();\n    }\n  }\n\n  return z.object(zodSchema);\n}\n\n/**\n * Deep merges two objects, recursively merging nested objects and arrays\n */\nexport function deepMerge<T extends object = object>(target: T, source: Partial<T>): T {\n  const output = { ...target };\n\n  if (!source) return output;\n\n  Object.keys(source).forEach(key => {\n    const targetValue = output[key as keyof T];\n    const sourceValue = source[key as keyof T];\n\n    if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {\n      (output as any)[key] = sourceValue;\n    } else if (\n      sourceValue instanceof Object &&\n      targetValue instanceof Object &&\n      !Array.isArray(sourceValue) &&\n      !Array.isArray(targetValue)\n    ) {\n      (output as any)[key] = deepMerge(targetValue, sourceValue as T);\n    } else if (sourceValue !== undefined) {\n      (output as any)[key] = sourceValue;\n    }\n  });\n\n  return output;\n}\n\nexport interface TagMaskOptions {\n  /** Called when masking begins */\n  onStart?: () => void;\n  /** Called when masking ends */\n  onEnd?: () => void;\n  /** Called for each chunk that is masked */\n  onMask?: (chunk: string) => void;\n}\n\n/**\n * Transforms a stream by masking content between XML tags.\n * @param stream Input stream to transform\n * @param tag Tag name to mask between (e.g. for <foo>...</foo>, use 'foo')\n * @param options Optional configuration for masking behavior\n */\nexport async function* maskStreamTags(\n  stream: AsyncIterable<string>,\n  tag: string,\n  options: TagMaskOptions = {},\n): AsyncIterable<string> {\n  const { onStart, onEnd, onMask } = options;\n  const openTag = `<${tag}>`;\n  const closeTag = `</${tag}>`;\n\n  let buffer = '';\n  let fullContent = '';\n  let isMasking = false;\n  let isBuffering = false;\n\n  // used for checking in chunks that include tags or partial tags + some other non-tag text\n  // eg: \"o <tag_name\" or \"name> w\", can trim before-start to get \"<tag_name\" or after-end to get \"name>\"\n  const trimOutsideDelimiter = (text: string, delimiter: string, trim: 'before-start' | 'after-end') => {\n    if (!text.includes(delimiter)) {\n      return text;\n    }\n\n    const parts = text.split(delimiter);\n\n    if (trim === `before-start`) {\n      return `${delimiter}${parts[1]}`;\n    }\n\n    return `${parts[0]}${delimiter}`;\n  };\n\n  // Helper to check if text starts with pattern (ignoring whitespace)\n  // When checking partial tags: startsWith(buffer, openTag) checks if buffer could be start of tag\n  // When checking full tags: startsWith(chunk, openTag) checks if chunk starts with full tag\n  const startsWith = (text: string, pattern: string) => {\n    // check start of opening tag\n    if (pattern.includes(openTag.substring(0, 3))) {\n      // our pattern for checking the start is always based on xml-like tags\n      // if the pattern looks like our opening tag and the pattern also includes\n      // some other chunked text before it, we just wanted to check the xml part of the pattern\n      pattern = trimOutsideDelimiter(pattern, `<`, `before-start`);\n    }\n\n    return text.trim().startsWith(pattern.trim());\n  };\n\n  for await (const chunk of stream) {\n    fullContent += chunk;\n\n    if (isBuffering) buffer += chunk;\n\n    const chunkHasTag = startsWith(chunk, openTag);\n    const bufferHasTag = !chunkHasTag && isBuffering && startsWith(openTag, buffer);\n\n    let toYieldBeforeMaskedStartTag = ``;\n    // Check if we should start masking chunks\n    if (!isMasking && (chunkHasTag || bufferHasTag)) {\n      isMasking = true;\n      isBuffering = false;\n\n      // check if the buffered text includes text before the start tag. ex \"o <tag_name\", \"o\" should be yielded and not masked\n      const taggedTextToMask = trimOutsideDelimiter(buffer, `<`, `before-start`);\n      if (taggedTextToMask !== buffer.trim()) {\n        toYieldBeforeMaskedStartTag = buffer.replace(taggedTextToMask, ``);\n      }\n\n      buffer = '';\n      onStart?.();\n    }\n\n    // Check if we should start buffering (looks like part of the opening tag but it's not the full <tag> yet eg <ta - could be <table> but we don't know yet)\n    if (!isMasking && !isBuffering && startsWith(openTag, chunk) && chunk.trim() !== '') {\n      isBuffering = true;\n      buffer += chunk;\n      continue;\n    }\n\n    // We're buffering, need to check again if our buffer has deviated from the opening <tag> eg <tag2>\n    if (isBuffering && buffer && !startsWith(openTag, buffer)) {\n      yield buffer;\n      buffer = '';\n      isBuffering = false;\n      continue;\n    }\n\n    // Check if we should stop masking chunks (since the content includes the closing </tag>)\n    if (isMasking && fullContent.includes(closeTag)) {\n      onMask?.(chunk);\n      onEnd?.();\n      isMasking = false;\n      const lastFullContent = fullContent;\n      fullContent = ``; // reset to handle streams with multiple full tags that have text inbetween\n\n      // check to see if we have a partial chunk outside the close tag. if we do we need to yield it so it isn't swallowed with the masked text\n      const textUntilEndTag = trimOutsideDelimiter(lastFullContent, closeTag, 'after-end');\n      if (textUntilEndTag !== lastFullContent) {\n        yield lastFullContent.replace(textUntilEndTag, ``);\n      }\n\n      continue;\n    }\n\n    // We're currently masking chunks inside a <tag>\n    if (isMasking) {\n      onMask?.(chunk);\n      // in the case that there was a chunk that included a tag to mask and some other text, ex \"o <tag_name\" we need to still yield the\n      // text before the tag (\"o \") so it's not swallowed with the masked text\n      if (toYieldBeforeMaskedStartTag) {\n        yield toYieldBeforeMaskedStartTag;\n      }\n      continue;\n    }\n\n    // default yield the chunk\n    yield chunk;\n  }\n}\n\n/**\n * Resolve serialized zod output - This function takes the string output ot the `jsonSchemaToZod` function\n * and instantiates the zod object correctly.\n *\n * @param schema - serialized zod object\n * @returns resolved zod object\n */\nexport function resolveSerializedZodOutput(schema: string): z.ZodType {\n  // Creates and immediately executes a new function that takes 'z' as a parameter\n  // The function body is a string that returns the serialized zod schema\n  // When executed with the 'z' parameter, it reconstructs the zod schema in the current context\n  return Function('z', `\"use strict\";return (${schema});`)(z);\n}\n\n/**\n * Checks if a tool is a Vercel Tool\n * @param tool - The tool to check\n * @returns True if the tool is a Vercel Tool, false otherwise\n */\nexport function isVercelTool(tool?: ToolToConvert): tool is VercelTool {\n  // Checks if this tool is not an instance of Tool\n  return !(tool instanceof Tool);\n}\n\ninterface ToolOptions {\n  name: string;\n  runId?: string;\n  threadId?: string;\n  resourceId?: string;\n  logger: Logger;\n  description?: string;\n  mastra?: (Mastra & MastraPrimitives) | MastraPrimitives;\n  memory?: MastraMemory;\n  agentName?: string;\n}\n\ntype ToolToConvert = VercelTool | ToolAction<any, any, any>;\n\ninterface LogOptions {\n  agentName?: string;\n  toolName: string;\n  tool?: ToolToConvert;\n  type?: 'tool' | 'toolset';\n}\n\ninterface LogMessageOptions {\n  start: string;\n  error: string;\n}\n\nfunction createLogMessageOptions({ agentName, toolName, tool, type }: LogOptions): LogMessageOptions {\n  // If no agent name, use default format\n  if (!agentName) {\n    return {\n      start: `Executing tool ${toolName}`,\n      error: `Failed tool execution`,\n    };\n  }\n\n  const prefix = `[Agent:${agentName}]`;\n  const vercelPrefix = isVercelTool(tool) ? 'Vercel ' : '';\n  const toolType = type === 'toolset' ? 'toolset' : 'tool';\n\n  return {\n    start: `${prefix} - Executing ${vercelPrefix}${toolType} ${toolName}`,\n    error: `${prefix} - Failed ${vercelPrefix}${toolType} execution`,\n  };\n}\n\nfunction createExecute(tool: ToolToConvert, options: ToolOptions, logType?: 'tool' | 'toolset') {\n  // dont't add memory or mastra to logging\n  const { logger, mastra: _mastra, memory: _memory, ...rest } = options;\n\n  const { start, error } = createLogMessageOptions({\n    agentName: options.agentName,\n    toolName: options.name,\n    tool,\n    type: logType,\n  });\n\n  const execFunction = async (args: any, execOptions: ToolExecutionOptions) => {\n    if (isVercelTool(tool)) {\n      return tool?.execute?.(args, execOptions) ?? undefined;\n    }\n    return (\n      tool?.execute?.(\n        {\n          context: args,\n          threadId: options.threadId,\n          resourceId: options.resourceId,\n          mastra: options.mastra,\n          memory: options.memory,\n          runId: options.runId,\n        },\n        execOptions,\n      ) ?? undefined\n    );\n  };\n\n  return async (args: any, execOptions?: any) => {\n    try {\n      logger.debug(start, { ...rest, args });\n      return await execFunction(args, execOptions);\n    } catch (err) {\n      logger.error(error, { ...rest, error: err, args });\n      throw err;\n    }\n  };\n}\n\n/**\n * Checks if a value is a Zod type\n * @param value - The value to check\n * @returns True if the value is a Zod type, false otherwise\n */\nfunction isZodType(value: unknown): value is z.ZodType {\n  // Check if it's a Zod schema by looking for common Zod properties and methods\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    '_def' in value &&\n    'parse' in value &&\n    typeof (value as any).parse === 'function' &&\n    'safeParse' in value &&\n    typeof (value as any).safeParse === 'function'\n  );\n}\n\n// Helper function to create a deterministic hash\nfunction createDeterministicId(input: string): string {\n  return createHash('sha256').update(input).digest('hex').slice(0, 8); // Take first 8 characters for a shorter but still unique ID\n}\n\n/**\n * Sets the properties for a Vercel Tool, including an ID and inputSchema\n * @param tool - The tool to set the properties for\n * @returns The tool with the properties set\n */\nfunction setVercelToolProperties(tool: VercelTool) {\n  const inputSchema = convertVercelToolParameters(tool);\n  const toolId = !('id' in tool)\n    ? tool.description\n      ? `tool-${createDeterministicId(tool.description)}`\n      : `tool-${Math.random().toString(36).substring(2, 9)}`\n    : tool.id;\n  return {\n    ...tool,\n    id: toolId,\n    inputSchema,\n  };\n}\n\n/**\n * Ensures a tool has an ID and inputSchema by generating one if not present\n * @param tool - The tool to ensure has an ID and inputSchema\n * @returns The tool with an ID and inputSchema\n */\nexport function ensureToolProperties(tools: ToolsInput): ToolsInput {\n  const toolsWithProperties = Object.keys(tools).reduce<ToolsInput>((acc, key) => {\n    const tool = tools?.[key];\n    if (tool) {\n      if (isVercelTool(tool)) {\n        acc[key] = setVercelToolProperties(tool) as VercelTool;\n      } else {\n        acc[key] = tool;\n      }\n    }\n    return acc;\n  }, {});\n\n  return toolsWithProperties;\n}\n\nfunction convertVercelToolParameters(tool: VercelTool): z.ZodType {\n  // If the tool is a Vercel Tool, check if the parameters are already a zod object\n  // If not, convert the parameters to a zod object using jsonSchemaToZod\n  const schema = tool.parameters ?? z.object({});\n  return isZodType(schema) ? schema : resolveSerializedZodOutput(jsonSchemaToZod(schema));\n}\n\n/**\n * Converts a Vercel Tool or Mastra Tool into a CoreTool format\n * @param tool - The tool to convert (either VercelTool or ToolAction)\n * @param options - Tool options including Mastra-specific settings\n * @param logType - Type of tool to log (tool or toolset)\n * @returns A CoreTool that can be used by the system\n */\nexport function makeCoreTool(tool: ToolToConvert, options: ToolOptions, logType?: 'tool' | 'toolset'): CoreTool {\n  // Helper to get parameters based on tool type\n  const getParameters = () => {\n    if (isVercelTool(tool)) {\n      return convertVercelToolParameters(tool);\n    }\n    return tool.inputSchema ?? z.object({});\n  };\n\n  // Check if this is a provider-defined tool\n  const isProviderDefined =\n    'type' in tool &&\n    tool.type === 'provider-defined' &&\n    'id' in tool &&\n    typeof tool.id === 'string' &&\n    tool.id.includes('.');\n\n  // For provider-defined tools, we need to include all required properties\n  if (isProviderDefined) {\n    return {\n      type: 'provider-defined' as const,\n      id: tool.id as `${string}.${string}`,\n      args: ('args' in tool ? tool.args : {}) as Record<string, unknown>,\n      description: tool.description!,\n      parameters: getParameters(),\n      execute: tool.execute ? createExecute(tool, { ...options, description: tool.description }, logType) : undefined,\n    };\n  }\n\n  // For function tools\n  return {\n    type: 'function' as const,\n    description: tool.description!,\n    parameters: getParameters(),\n    execute: tool.execute ? createExecute(tool, { ...options, description: tool.description }, logType) : undefined,\n  };\n}\n\n/**\n * Creates a proxy for a Mastra instance to handle deprecated properties\n * @param mastra - The Mastra instance to proxy\n * @param logger - The logger to use for warnings\n * @returns A proxy for the Mastra instance\n */\nexport function createMastraProxy({ mastra, logger }: { mastra: Mastra; logger: Logger }) {\n  return new Proxy(mastra, {\n    get(target, prop) {\n      const hasProp = Reflect.has(target, prop);\n\n      if (hasProp) {\n        const value = Reflect.get(target, prop);\n        const isFunction = typeof value === 'function';\n        if (isFunction) {\n          return value.bind(target);\n        }\n        return value;\n      }\n\n      if (prop === 'logger') {\n        logger.warn(`Please use 'getLogger' instead, logger is deprecated`);\n        return Reflect.apply(target.getLogger, target, []);\n      }\n\n      if (prop === 'telemetry') {\n        logger.warn(`Please use 'getTelemetry' instead, telemetry is deprecated`);\n        return Reflect.apply(target.getTelemetry, target, []);\n      }\n\n      if (prop === 'storage') {\n        logger.warn(`Please use 'getStorage' instead, storage is deprecated`);\n        return Reflect.get(target, 'storage');\n      }\n\n      if (prop === 'agents') {\n        logger.warn(`Please use 'getAgents' instead, agents is deprecated`);\n        return Reflect.apply(target.getAgents, target, []);\n      }\n\n      if (prop === 'tts') {\n        logger.warn(`Please use 'getTTS' instead, tts is deprecated`);\n        return Reflect.apply(target.getTTS, target, []);\n      }\n\n      if (prop === 'vectors') {\n        logger.warn(`Please use 'getVectors' instead, vectors is deprecated`);\n        return Reflect.apply(target.getVectors, target, []);\n      }\n\n      if (prop === 'memory') {\n        logger.warn(`Please use 'getMemory' instead, memory is deprecated`);\n        return Reflect.get(target, 'memory');\n      }\n\n      return Reflect.get(target, prop);\n    },\n  });\n}\n\nexport function checkEvalStorageFields(traceObject: any, logger?: Logger) {\n  const missingFields = [];\n  if (!traceObject.input) missingFields.push('input');\n  if (!traceObject.output) missingFields.push('output');\n  if (!traceObject.agentName) missingFields.push('agent_name');\n  if (!traceObject.metricName) missingFields.push('metric_name');\n  if (!traceObject.instructions) missingFields.push('instructions');\n  if (!traceObject.globalRunId) missingFields.push('global_run_id');\n  if (!traceObject.runId) missingFields.push('run_id');\n\n  if (missingFields.length > 0) {\n    if (logger) {\n      logger.warn('Skipping evaluation storage due to missing required fields', {\n        missingFields,\n        runId: traceObject.runId,\n        agentName: traceObject.agentName,\n      });\n    } else {\n      console.warn('Skipping evaluation storage due to missing required fields', {\n        missingFields,\n        runId: traceObject.runId,\n        agentName: traceObject.agentName,\n      });\n    }\n    return false;\n  }\n\n  return true;\n}\n\n// lifted from https://github.com/vercel/ai/blob/main/packages/ai/core/prompt/detect-prompt-type.ts#L27\nfunction detectSingleMessageCharacteristics(\n  message: any,\n): 'has-ui-specific-parts' | 'has-core-specific-parts' | 'message' | 'other' {\n  if (\n    typeof message === 'object' &&\n    message !== null &&\n    (message.role === 'function' || // UI-only role\n      message.role === 'data' || // UI-only role\n      'toolInvocations' in message || // UI-specific field\n      'parts' in message || // UI-specific field\n      'experimental_attachments' in message)\n  ) {\n    return 'has-ui-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'content' in message &&\n    (Array.isArray(message.content) || // Core messages can have array content\n      'experimental_providerMetadata' in message ||\n      'providerOptions' in message)\n  ) {\n    return 'has-core-specific-parts';\n  } else if (\n    typeof message === 'object' &&\n    message !== null &&\n    'role' in message &&\n    'content' in message &&\n    typeof message.content === 'string' &&\n    ['system', 'user', 'assistant', 'tool'].includes(message.role)\n  ) {\n    return 'message';\n  } else {\n    return 'other';\n  }\n}\n\nfunction isUiMessage(message: CoreMessage | AiMessageType): message is AiMessageType {\n  return detectSingleMessageCharacteristics(message) === `has-ui-specific-parts`;\n}\nfunction isCoreMessage(message: CoreMessage | AiMessageType): message is CoreMessage {\n  return [`has-core-specific-parts`, `message`].includes(detectSingleMessageCharacteristics(message));\n}\n\nexport function ensureAllMessagesAreCoreMessages(messages: (CoreMessage | AiMessageType)[]) {\n  return messages\n    .map(message => {\n      if (isUiMessage(message)) {\n        return convertToCoreMessages([message]);\n      }\n      if (isCoreMessage(message)) {\n        return message;\n      }\n      const characteristics = detectSingleMessageCharacteristics(message);\n      throw new Error(\n        `Message does not appear to be a core message or a UI message but must be one of the two, found \"${characteristics}\" type for message:\\n\\n${JSON.stringify(message, null, 2)}\\n`,\n      );\n    })\n    .flat();\n}\n"]}