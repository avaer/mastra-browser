{"version":3,"sources":["../src/logger/index.ts"],"names":[],"mappings":"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","file":"chunk-HEAZ5SGJ.js","sourcesContent":["import { Transform } from 'stream';\n// import pino from 'pino';\n// import pretty from 'pino-pretty';\n\nimport type { Run } from '../run/types';\n\n// Constants and Types (keeping from original implementation)\nexport const RegisteredLogger = {\n  AGENT: 'AGENT',\n  NETWORK: 'NETWORK',\n  WORKFLOW: 'WORKFLOW',\n  LLM: 'LLM',\n  TTS: 'TTS',\n  VOICE: 'VOICE',\n  VECTOR: 'VECTOR',\n  BUNDLER: 'BUNDLER',\n  DEPLOYER: 'DEPLOYER',\n  MEMORY: 'MEMORY',\n  STORAGE: 'STORAGE',\n  EMBEDDINGS: 'EMBEDDINGS',\n} as const;\n\nexport type RegisteredLogger = (typeof RegisteredLogger)[keyof typeof RegisteredLogger];\n\nexport const LogLevel = {\n  DEBUG: 'debug',\n  INFO: 'info',\n  WARN: 'warn',\n  ERROR: 'error',\n  NONE: 'silent',\n} as const;\n\nexport type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];\n\n// Base Interfaces\nexport interface BaseLogMessage extends Run {\n  msg: string;\n  level: number;\n  time: Date;\n  pid: number;\n  hostname: string;\n  name: string;\n}\n\nexport class LoggerTransport extends Transform {\n  constructor(opts: any = {}) {\n    super({ ...opts, objectMode: true });\n  }\n\n  async getLogsByRunId(_args: { runId: string }): Promise<BaseLogMessage[]> {\n    return [];\n  }\n  async getLogs(): Promise<BaseLogMessage[]> {\n    return [];\n  }\n}\n\nexport type TransportMap = Record<string, LoggerTransport>;\n\n// Base Pino Logger\nexport class Logger {\n  // protected logger: pino.Logger;\n  transports: TransportMap;\n\n  constructor(\n    options: {\n      name?: string;\n      level?: LogLevel;\n      transports?: TransportMap;\n      overrideDefaultTransports?: boolean;\n    } = {},\n  ) {\n    this.transports = options.transports || {};\n\n    // // Create Pino logger with multiple streams\n    // const transportsAry = Object.entries(this.transports);\n    // this.logger = pino(\n    //   {\n    //     name: options.name || 'app',\n    //     level: options.level || LogLevel.INFO,\n    //     formatters: {\n    //       level: label => {\n    //         return {\n    //           level: label,\n    //         };\n    //       },\n    //     },\n    //   },\n    //   options.overrideDefaultTransports\n    //     ? options?.transports?.default\n    //     : transportsAry.length === 0\n    //       ? pretty({\n    //           colorize: true,\n    //           levelFirst: true,\n    //           ignore: 'pid,hostname',\n    //           colorizeObjects: true,\n    //           translateTime: 'SYS:standard',\n    //           singleLine: false,\n    //         })\n    //       : pino.multistream([\n    //           ...transportsAry.map(([_, transport]) => ({\n    //             stream: transport,\n    //             level: options.level || LogLevel.INFO,\n    //           })),\n    //           {\n    //             stream: pretty({\n    //               colorize: true,\n    //               levelFirst: true,\n    //               ignore: 'pid,hostname',\n    //               colorizeObjects: true,\n    //               translateTime: 'SYS:standard',\n    //               singleLine: false,\n    //             }),\n    //             level: options.level || LogLevel.INFO,\n    //           },\n    //         ]),\n    // );\n  }\n\n  debug(message: string, args: Record<string, any> = {}): void {\n    // this.logger.debug(args, message);\n    console.debug(args, message);\n  }\n\n  info(message: string, args: Record<string, any> = {}): void {\n    // this.logger.info(args, message);\n    console.info(args, message);\n  }\n\n  warn(message: string, args: Record<string, any> = {}): void {\n    // this.logger.warn(args, message);\n    console.warn(args, message);\n  }\n\n  error(message: string, args: Record<string, any> = {}): void {\n    // this.logger.error(args, message);\n    console.error(args, message);\n  }\n\n  // Stream creation for process output handling\n  createStream(): Transform {\n    return new Transform({\n      transform: (chunk, _encoding, callback) => {\n        const line = chunk.toString().trim();\n        if (line) {\n          this.info(line);\n        }\n        callback(null, chunk);\n      },\n    });\n  }\n\n  async getLogs(transportId: string) {\n    if (!transportId || !this.transports[transportId]) {\n      return [];\n    }\n    return this.transports[transportId].getLogs();\n  }\n\n  async getLogsByRunId({ runId, transportId }: { transportId: string; runId: string }) {\n    return this.transports[transportId]?.getLogsByRunId({ runId });\n  }\n}\n\n// Factory function for creating loggers\nexport function createLogger(options: { name?: string; level?: LogLevel; transports?: TransportMap }) {\n  return new Logger(options);\n}\n\n// Multi-logger implementation for handling multiple loggers\nexport class MultiLogger {\n  private loggers: Logger[];\n\n  constructor(loggers: Logger[]) {\n    this.loggers = loggers;\n  }\n\n  debug(message: string, ...args: any[]): void {\n    this.loggers.forEach(logger => logger.debug(message, ...args));\n  }\n\n  info(message: string, ...args: any[]): void {\n    this.loggers.forEach(logger => logger.info(message, ...args));\n  }\n\n  warn(message: string, ...args: any[]): void {\n    this.loggers.forEach(logger => logger.warn(message, ...args));\n  }\n\n  error(message: string, ...args: any[]): void {\n    this.loggers.forEach(logger => logger.error(message, ...args));\n  }\n}\n\n// Utility function to combine multiple loggers\nexport function combineLoggers(loggers: Logger[]): MultiLogger {\n  return new MultiLogger(loggers);\n}\n\n// No-op logger implementation\nexport const noopLogger = {\n  debug: () => {},\n  info: () => {},\n  warn: () => {},\n  error: () => {},\n  cleanup: async () => {},\n};\n"]}