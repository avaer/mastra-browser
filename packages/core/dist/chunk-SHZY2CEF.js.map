{"version":3,"sources":["../src/workflows/step.ts","../src/workflows/types.ts","../src/workflows/utils.ts","../src/workflows/machine.ts","../src/workflows/workflow-instance.ts","../src/workflows/workflow.ts"],"names":["WhenConditionReturnValue","value","mastra","result","get","_mastra","_steps","_stepGraph","_retryConfig","_runId","_executionSpan","startStepId","snapshot","handler","otlpContext","_onStepTransition","_stepSubscriberGraph","loadWorkflowSnapshot_fn","makeStepDef_fn","step","trace"],"mappings":"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","file":"chunk-SHZY2CEF.js","sourcesContent":["import type { z } from 'zod';\n\nimport type { Mastra } from '../mastra';\nimport type { RetryConfig, StepAction, StepExecutionContext } from './types';\n\nexport class Step<\n  TStepId extends string = any,\n  TSchemaIn extends z.ZodSchema | undefined = undefined,\n  TSchemaOut extends z.ZodSchema | undefined = undefined,\n  TContext extends StepExecutionContext<TSchemaIn> = StepExecutionContext<TSchemaIn>,\n> implements StepAction<TStepId, TSchemaIn, TSchemaOut, TContext>\n{\n  id: TStepId;\n  description?: string;\n  inputSchema?: TSchemaIn;\n  outputSchema?: TSchemaOut;\n  payload?: TSchemaIn extends z.ZodSchema ? Partial<z.infer<TSchemaIn>> : unknown;\n  execute: (context: TContext) => Promise<TSchemaOut extends z.ZodSchema ? z.infer<TSchemaOut> : unknown>;\n  retryConfig?: RetryConfig;\n  mastra?: Mastra;\n\n  constructor({\n    id,\n    description,\n    execute,\n    payload,\n    outputSchema,\n    inputSchema,\n    retryConfig,\n  }: StepAction<TStepId, TSchemaIn, TSchemaOut, TContext>) {\n    this.id = id;\n    this.description = description ?? '';\n    this.inputSchema = inputSchema;\n    this.payload = payload;\n    this.outputSchema = outputSchema;\n    this.execute = execute;\n    this.retryConfig = retryConfig;\n  }\n}\n\nexport function createStep<\n  TId extends string,\n  TSchemaIn extends z.ZodSchema | undefined,\n  TSchemaOut extends z.ZodSchema | undefined,\n  TContext extends StepExecutionContext<TSchemaIn>,\n>(opts: StepAction<TId, TSchemaIn, TSchemaOut, TContext>) {\n  return new Step(opts);\n}\n","import type { Query } from 'sift';\nimport type { z } from 'zod';\n\nimport type { IAction, IExecutionContext, MastraUnion } from '../action';\nimport type { BaseLogMessage, RegisteredLogger } from '../logger';\nimport type { Mastra } from '../mastra';\nimport type { Step } from './step';\nimport type { Workflow } from './workflow';\n\nexport interface WorkflowOptions<\n  TWorkflowName extends string = string,\n  TSteps extends Step<string, any, any, any>[] = Step<string, any, any, any>[],\n  TTriggerSchema extends z.ZodObject<any> = any,\n  TResultSchema extends z.ZodObject<any> = any,\n> {\n  steps?: TSteps;\n  name: TWorkflowName;\n  triggerSchema?: TTriggerSchema;\n  result?: {\n    schema: TResultSchema;\n    mapping?: {\n      // TODO: fix types\n      [K in keyof z.infer<TResultSchema>]?: any; // VariableReference<VarStep, TTriggerSchema>; // TODO: fix types\n    };\n  };\n  events?: Record<string, { schema: z.ZodObject<any> }>;\n  retryConfig?: RetryConfig;\n  mastra?: Mastra;\n}\n\nexport interface StepExecutionContext<\n  TSchemaIn extends z.ZodSchema | undefined = undefined,\n  TContext extends WorkflowContext = WorkflowContext,\n> extends IExecutionContext<TSchemaIn> {\n  context: TSchemaIn extends z.ZodSchema ? { inputData: z.infer<TSchemaIn> } & TContext : TContext;\n  suspend: (payload?: unknown, softSuspend?: any) => Promise<void>;\n  runId: string;\n  emit: (event: string, data: any) => void;\n  mastra?: MastraUnion;\n}\n\nexport interface StepAction<\n  TId extends string,\n  TSchemaIn extends z.ZodSchema | undefined,\n  TSchemaOut extends z.ZodSchema | undefined,\n  TContext extends StepExecutionContext<TSchemaIn>,\n> extends IAction<TId, TSchemaIn, TSchemaOut, TContext> {\n  mastra?: Mastra;\n  payload?: TSchemaIn extends z.ZodSchema ? Partial<z.infer<TSchemaIn>> : unknown;\n  execute: (context: TContext) => Promise<TSchemaOut extends z.ZodSchema ? z.infer<TSchemaOut> : unknown>;\n  retryConfig?: RetryConfig;\n  workflow?: Workflow;\n}\n\n// For the simple key-value condition\ninterface SimpleConditionalType {\n  [key: `${string}.${string}`]: string | Query<any>;\n}\n\nexport type StepVariableType<\n  TId extends string,\n  TSchemaIn extends z.ZodSchema | undefined,\n  TSchemaOut extends z.ZodSchema | undefined,\n  TContext extends StepExecutionContext<TSchemaIn>,\n> = StepAction<TId, TSchemaIn, TSchemaOut, TContext> | 'trigger' | { id: string };\n\nexport type StepNode = { step: StepAction<any, any, any, any>; config: StepDef<any, any, any, any>[any] };\n\nexport type StepGraph = {\n  initial: StepNode[];\n  [key: string]: StepNode[];\n};\n\nexport type RetryConfig = { attempts?: number; delay?: number };\n\nexport type VariableReference<\n  TStep extends StepVariableType<any, any, any, any>,\n  TTriggerSchema extends z.ZodObject<any>,\n> =\n  TStep extends StepAction<any, any, any, any>\n    ? {\n        step: TStep;\n        path: PathsToStringProps<ExtractSchemaType<ExtractSchemaFromStep<TStep, 'outputSchema'>>> | '' | '.';\n      }\n    : TStep extends 'trigger'\n      ? {\n          step: 'trigger';\n          path: PathsToStringProps<ExtractSchemaType<TTriggerSchema>> | '.' | '';\n        }\n      : {\n          step: { id: string };\n          path: string;\n        };\n\nexport interface BaseCondition<\n  TStep extends StepVariableType<any, any, any, any>,\n  TTriggerSchema extends z.ZodObject<any>,\n> {\n  ref: TStep extends StepAction<any, any, any, any>\n    ? {\n        step: TStep;\n        path: PathsToStringProps<ExtractSchemaType<ExtractSchemaFromStep<TStep, 'outputSchema'>>> | '' | '.' | 'status';\n      }\n    : TStep extends 'trigger'\n      ? {\n          step: 'trigger';\n          path: PathsToStringProps<ExtractSchemaType<TTriggerSchema>> | '.' | '';\n        }\n      : {\n          step: { id: string };\n          path: string;\n        };\n  query: Query<any>;\n}\n\nexport type ActionContext<TSchemaIn extends z.ZodType<any>> = StepExecutionContext<z.infer<TSchemaIn>, WorkflowContext>;\nexport enum WhenConditionReturnValue {\n  CONTINUE = 'continue',\n  CONTINUE_FAILED = 'continue_failed',\n  ABORT = 'abort',\n  LIMBO = 'limbo',\n}\n\nexport type StepDef<\n  TStepId extends TSteps[number]['id'],\n  TSteps extends StepAction<any, any, any, any>[],\n  TSchemaIn extends z.ZodType<any>,\n  TSchemaOut extends z.ZodType<any>,\n> = Record<\n  TStepId,\n  {\n    when?:\n      | Condition<any, any>\n      | ((args: { context: WorkflowContext; mastra?: Mastra }) => Promise<boolean | WhenConditionReturnValue>);\n    serializedWhen?: Condition<any, any> | string;\n    loopLabel?: string;\n    loopType?: 'while' | 'until';\n    data: TSchemaIn;\n    handler: (args: ActionContext<TSchemaIn>) => Promise<z.infer<TSchemaOut>>;\n  }\n>;\n\nexport type StepCondition<\n  TStep extends StepVariableType<any, any, any, any>,\n  TTriggerSchema extends z.ZodObject<any>,\n> =\n  | BaseCondition<TStep, TTriggerSchema>\n  | SimpleConditionalType\n  | { and: StepCondition<TStep, TTriggerSchema>[] }\n  | { or: StepCondition<TStep, TTriggerSchema>[] }\n  | { not: StepCondition<TStep, TTriggerSchema> };\n\ntype Condition<TStep extends StepVariableType<any, any, any, any>, TTriggerSchema extends z.ZodObject<any>> =\n  | BaseCondition<TStep, TTriggerSchema>\n  | SimpleConditionalType\n  | { and: Condition<TStep, TTriggerSchema>[] }\n  | { or: Condition<TStep, TTriggerSchema>[] }\n  | { not: Condition<TStep, TTriggerSchema> };\n\nexport interface StepConfig<\n  TStep extends StepAction<any, any, any, any>,\n  CondStep extends StepVariableType<any, any, any, any>,\n  VarStep extends StepVariableType<any, any, any, any>,\n  TTriggerSchema extends z.ZodObject<any>,\n  TSteps extends Step<string, any, any, any>[] = Step<string, any, any, any>[],\n> {\n  when?:\n    | Condition<CondStep, TTriggerSchema>\n    | ((args: {\n        context: WorkflowContext<TTriggerSchema, TSteps>;\n        mastra?: Mastra;\n      }) => Promise<boolean | WhenConditionReturnValue>);\n  variables?: StepInputType<TStep, 'inputSchema'> extends never\n    ? Record<string, VariableReference<VarStep, TTriggerSchema>>\n    : {\n        [K in keyof StepInputType<TStep, 'inputSchema'>]?: VariableReference<VarStep, TTriggerSchema>;\n      };\n  '#internal'?: {\n    when?:\n      | Condition<CondStep, TTriggerSchema>\n      | ((args: {\n          context: WorkflowContext<TTriggerSchema, TSteps>;\n          mastra?: Mastra;\n        }) => Promise<boolean | WhenConditionReturnValue>);\n    loopLabel?: string;\n    loopType?: 'while' | 'until' | undefined;\n  };\n}\n\ntype StepSuccess<T> = {\n  status: 'success';\n  output: T;\n};\n\ntype StepSuspended<T> = {\n  status: 'suspended';\n  suspendPayload?: any;\n  output?: T;\n};\ntype StepWaiting = {\n  status: 'waiting';\n};\n\ntype StepFailure = {\n  status: 'failed';\n  error: string;\n};\n\ntype StepSkipped = {\n  status: 'skipped';\n};\n\nexport type StepResult<T> = StepSuccess<T> | StepFailure | StepSuspended<T> | StepWaiting | StepSkipped;\n\n// Define a type for mapping step IDs to their respective steps[]\nexport type StepsRecord<T extends readonly Step<any, any, z.ZodType<any> | undefined>[]> = {\n  [K in T[number]['id']]: Extract<T[number], { id: K }>;\n};\n\nexport interface WorkflowRunResult<\n  T extends z.ZodObject<any>,\n  TSteps extends Step<string, any, z.ZodType<any> | undefined>[],\n  TResult extends z.ZodObject<any>,\n> {\n  triggerData?: z.infer<T>;\n  result?: z.infer<TResult>;\n  results: {\n    [K in keyof StepsRecord<TSteps>]: StepsRecord<TSteps>[K]['outputSchema'] extends undefined\n      ? StepResult<unknown>\n      : StepResult<z.infer<NonNullable<StepsRecord<TSteps>[K]['outputSchema']>>>;\n  };\n  runId: string;\n  activePaths: Map<keyof StepsRecord<TSteps>, { status: string; suspendPayload?: any }>;\n}\n\n// Update WorkflowContext\nexport interface WorkflowContext<\n  TTrigger extends z.ZodObject<any> = any,\n  TSteps extends Step<string, any, any, any>[] = Step<string, any, any, any>[],\n  TInputData extends Record<string, any> = Record<string, any>,\n> {\n  isResume?: { runId: string; stepId: string };\n  mastra?: MastraUnion;\n  steps: {\n    [K in keyof StepsRecord<TSteps>]: StepsRecord<TSteps>[K]['outputSchema'] extends undefined\n      ? StepResult<unknown>\n      : StepResult<z.infer<NonNullable<StepsRecord<TSteps>[K]['outputSchema']>>>;\n  };\n  triggerData: z.infer<TTrigger>;\n  inputData: TInputData;\n  attempts: Record<string, number>;\n  getStepResult(stepId: 'trigger'): z.infer<TTrigger>;\n  getStepResult<T extends keyof StepsRecord<TSteps> | unknown>(\n    stepId: T extends keyof StepsRecord<TSteps> ? T : string,\n  ): T extends keyof StepsRecord<TSteps>\n    ? StepsRecord<TSteps>[T]['outputSchema'] extends undefined\n      ? unknown\n      : z.infer<NonNullable<StepsRecord<TSteps>[T]['outputSchema']>>\n    : T;\n  getStepResult<T extends Step<any, any, any, any>>(\n    stepId: T,\n  ): T['outputSchema'] extends undefined ? unknown : z.infer<NonNullable<T['outputSchema']>>;\n}\n\nexport interface WorkflowLogMessage extends BaseLogMessage {\n  type: typeof RegisteredLogger.WORKFLOW;\n  workflowName: string;\n  stepId?: StepId;\n  data?: unknown;\n  runId?: string;\n}\n\nexport type WorkflowEvent =\n  | { type: 'RESET_TO_PENDING'; stepId: string }\n  | { type: 'CONDITIONS_MET'; stepId: string }\n  | { type: 'CONDITION_FAILED'; stepId: string; error: string }\n  | { type: 'SUSPENDED'; stepId: string; suspendPayload?: any; softSuspend?: any }\n  | { type: 'WAITING'; stepId: string }\n  | { type: `xstate.error.actor.${string}`; error: Error }\n  | { type: `xstate.done.actor.${string}`; output: ResolverFunctionOutput };\n\nexport type ResolverFunctionInput = {\n  stepNode: StepNode;\n  context: WorkflowContext;\n};\n\nexport type ResolverFunctionOutput = {\n  stepId: StepId;\n  result: unknown;\n};\n\nexport type SubscriberFunctionOutput = {\n  stepId: StepId;\n  result: unknown;\n};\n\nexport type DependencyCheckOutput =\n  | { type: 'CONDITIONS_MET' }\n  | { type: 'CONDITIONS_SKIPPED' }\n  | { type: 'CONDITIONS_SKIP_TO_COMPLETED' }\n  | { type: 'CONDITION_FAILED'; error: string }\n  | { type: 'SUSPENDED' }\n  | { type: 'WAITING' }\n  | { type: 'CONDITIONS_LIMBO' };\n\nexport type StepResolverOutput =\n  | { type: 'STEP_SUCCESS'; output: unknown }\n  | { type: 'STEP_FAILED'; error: string }\n  | { type: 'STEP_WAITING' };\n\nexport type WorkflowActors = {\n  resolverFunction: {\n    input: ResolverFunctionInput;\n    output: StepResolverOutput;\n  };\n  conditionCheck: {\n    input: { context: WorkflowContext; stepId: string };\n    output: DependencyCheckOutput;\n  };\n  spawnSubscriberFunction: {\n    input: { context: WorkflowContext; stepId: string };\n    output: SubscriberFunctionOutput;\n  };\n};\n\nexport type WorkflowActionParams = {\n  stepId: string;\n};\n\nexport type WorkflowActions = {\n  type: 'updateStepResult' | 'setStepError' | 'notifyStepCompletion' | 'decrementAttemptCount';\n  params: WorkflowActionParams;\n};\n\nexport type WorkflowState = {\n  [key: string]: {\n    initial: 'pending';\n    states: {\n      pending: {\n        invoke: {\n          src: 'conditionCheck';\n          input: ({ context }: { context: WorkflowContext }) => {\n            context: WorkflowContext;\n            stepId: string;\n          };\n          onDone: [\n            {\n              guard: (_: any, event: { output: DependencyCheckOutput }) => boolean;\n              target: 'executing';\n            },\n            {\n              guard: (_: any, event: { output: DependencyCheckOutput }) => boolean;\n              target: 'waiting';\n            },\n          ];\n        };\n      };\n      waiting: {\n        after: {\n          CHECK_INTERVAL: {\n            target: 'pending';\n          };\n        };\n      };\n      executing: {\n        invoke: {\n          src: 'resolverFunction';\n          input: ({ context }: { context: WorkflowContext }) => ResolverFunctionInput;\n          onDone: {\n            target: 'completed';\n            actions: ['updateStepResult'];\n          };\n          onError: {\n            target: 'failed';\n            actions: ['setStepError'];\n          };\n        };\n      };\n      completed: {\n        type: 'final';\n        entry: ['notifyStepCompletion'];\n      };\n      failed: {\n        type: 'final';\n        entry: ['notifyStepCompletion'];\n      };\n    };\n  };\n};\n\n// Type helpers\n\n// Branded type for StepId\ndeclare const StepIdBrand: unique symbol;\nexport type StepId = string & { readonly [StepIdBrand]: typeof StepIdBrand };\n\nexport type ExtractSchemaFromStep<\n  TStep extends StepAction<any, any, any, any>,\n  TKey extends 'inputSchema' | 'outputSchema',\n> = TStep[TKey];\n\n// Helper type to extract result type from a step handler\nexport type ExtractStepResult<T> = T extends (data: any) => Promise<infer R> ? R : never;\n\nexport type StepInputType<TStep extends StepAction<any, any, any, any>, TKey extends 'inputSchema' | 'outputSchema'> =\n  ExtractSchemaFromStep<TStep, TKey> extends infer Schema\n    ? Schema extends z.ZodType<any>\n      ? z.infer<Schema>\n      : never\n    : never;\n\n// Get the raw type from Zod schema\nexport type ExtractSchemaType<T extends z.ZodSchema> = T extends z.ZodSchema<infer V> ? V : never;\n\n// Generate all possible paths through an object type\nexport type PathsToStringProps<T> = T extends object\n  ? {\n      [K in keyof T]: T[K] extends object\n        ? K extends string\n          ? K | `${K}.${PathsToStringProps<T[K]>}`\n          : never\n        : K extends string\n          ? K\n          : never;\n    }[keyof T]\n  : never;\n\nexport interface WorkflowRunState {\n  // Core state info\n  value: Record<string, string>;\n  context: {\n    steps: Record<\n      string,\n      {\n        status: 'success' | 'failed' | 'suspended' | 'waiting' | 'skipped';\n        payload?: any;\n        error?: string;\n      }\n    >;\n    triggerData: Record<string, any>;\n    attempts: Record<string, number>;\n  };\n\n  activePaths: Array<{\n    stepPath: string[];\n    stepId: string;\n    status: string;\n  }>;\n\n  // Metadata\n  runId: string;\n  timestamp: number;\n\n  childStates?: Record<string, WorkflowRunState>;\n  suspendedSteps?: Record<string, string>;\n}\n\nexport type WorkflowResumeResult<TTriggerSchema extends z.ZodObject<any>> = {\n  triggerData?: z.infer<TTriggerSchema>;\n  results: Record<string, StepResult<any>>;\n};\n","import type { z } from 'zod';\nimport type { Logger } from '../logger';\nimport type { Step } from './step';\nimport type { StepAction, StepDef, StepResult, VariableReference, WorkflowContext, WorkflowRunResult } from './types';\nimport type { Workflow } from './workflow';\nimport { get } from 'radash';\nimport type { WorkflowResultReturn } from './workflow-instance';\nimport type { Mastra } from '..';\n\nexport function isErrorEvent(stateEvent: any): stateEvent is {\n  type: `xstate.error.actor.${string}`;\n  error: Error;\n} {\n  return stateEvent.type.startsWith('xstate.error.actor.');\n}\n\nexport function isTransitionEvent(stateEvent: any): stateEvent is {\n  type: `xstate.done.actor.${string}`;\n  output?: unknown;\n} {\n  return stateEvent.type.startsWith('xstate.done.actor.');\n}\n\nexport function isVariableReference(value: any): value is VariableReference<any, any> {\n  return typeof value === 'object' && 'step' in value && 'path' in value;\n}\n\nexport function getStepResult(result?: StepResult<any>) {\n  if (result?.status === 'success') return result.output;\n  return undefined;\n}\n\nexport function getSuspendedPaths({\n  value,\n  path,\n  suspendedPaths,\n}: {\n  value: string | Record<string, string>;\n  path: string;\n  suspendedPaths: Set<string>;\n}) {\n  if (typeof value === 'string') {\n    if (value === 'suspended') {\n      suspendedPaths.add(path);\n    }\n  } else {\n    Object.keys(value).forEach(key =>\n      getSuspendedPaths({ value: value[key]!, path: path ? `${path}.${key}` : key, suspendedPaths }),\n    );\n  }\n}\n\nexport function isFinalState(status: string): boolean {\n  return ['completed', 'failed'].includes(status);\n}\n\nexport function isLimboState(status: string): boolean {\n  return status === 'limbo';\n}\n\nexport function recursivelyCheckForFinalState({\n  value,\n  suspendedPaths,\n  path,\n}: {\n  value: string | Record<string, string>;\n  suspendedPaths: Set<string>;\n  path: string;\n}): boolean {\n  if (typeof value === 'string') {\n    // if the value is a final state or limbo state or it has previously reached a suspended state, return true\n    return isFinalState(value) || isLimboState(value) || suspendedPaths.has(path);\n  }\n  return Object.keys(value).every(key =>\n    recursivelyCheckForFinalState({ value: value[key]!, suspendedPaths, path: path ? `${path}.${key}` : key }),\n  );\n}\n\nexport function getActivePathsAndStatus(value: Record<string, any>): Array<{\n  stepPath: string[];\n  stepId: string;\n  status: string;\n}> {\n  const paths: Array<{\n    stepPath: string[];\n    stepId: string;\n    status: string;\n  }> = [];\n\n  const traverse = (current: Record<string, any>, path: string[] = []) => {\n    for (const [key, value] of Object.entries(current)) {\n      const currentPath = [...path, key];\n\n      if (typeof value === 'string') {\n        // Found a leaf state\n        paths.push({\n          stepPath: currentPath,\n          stepId: key,\n          status: value,\n        });\n      } else if (typeof value === 'object' && value !== null) {\n        // Continue traversing\n        traverse(value, currentPath);\n      }\n    }\n  };\n\n  traverse(value);\n  return paths;\n}\n\nexport function mergeChildValue(\n  startStepId: string,\n  parent: Record<string, any>,\n  child: Record<string, any>,\n): Record<string, any> {\n  const traverse = (current: Record<string, any>) => {\n    const obj: Record<string, any> = {};\n    for (const [key, value] of Object.entries(current)) {\n      if (key === startStepId) {\n        // Found child state\n        obj[key] = { ...child };\n      } else if (typeof value === 'string') {\n        // Found leaf state\n        obj[key] = value;\n      } else if (typeof value === 'object' && value !== null) {\n        // Continue traversing\n        obj[key] = traverse(value);\n      }\n    }\n\n    return obj;\n  };\n\n  return traverse(parent);\n}\n\nexport const updateStepInHierarchy = (value: Record<string, any>, targetStepId: string): Record<string, any> => {\n  const result: Record<string, any> = {};\n\n  for (const key of Object.keys(value)) {\n    const currentValue = value[key];\n\n    if (key === targetStepId) {\n      // Found our target step, set it to pending\n      result[key] = 'pending';\n    } else if (typeof currentValue === 'object' && currentValue !== null) {\n      // Recurse into nested states\n      result[key] = updateStepInHierarchy(currentValue, targetStepId);\n    } else {\n      // Keep other states as is\n      result[key] = currentValue;\n    }\n  }\n\n  return result;\n};\n\nexport function getResultActivePaths(state: {\n  value: Record<string, string>;\n  context: { steps: Record<string, any> };\n}) {\n  return getActivePathsAndStatus(state.value).reduce((acc, curr) => {\n    const entry: { status: string; suspendPayload?: any } = { status: curr.status };\n    if (curr.status === 'suspended') {\n      // @ts-ignore\n      entry.suspendPayload = state.context.steps[curr.stepId].suspendPayload;\n    }\n    acc.set(curr.stepId, entry);\n    return acc;\n  }, new Map<string, { status: string; suspendPayload?: any }>());\n}\n\nexport function isWorkflow(\n  step: Step<any, any, any, any> | Workflow<any, any, any, any>,\n): step is Workflow<any, any, any, any> {\n  // @ts-ignore\n  return !!step?.name;\n}\n\nexport function resolveVariables<TSteps extends Step<any, any, any>[]>({\n  runId,\n  logger,\n  variables,\n  context,\n}: {\n  runId: string;\n  logger: Logger;\n  variables: Record<string, VariableReference<any, any>>;\n  context: WorkflowContext;\n}): Record<string, any> {\n  const resolvedData: Record<string, any> = {};\n\n  for (const [key, variable] of Object.entries(variables)) {\n    // Check if variable comes from trigger data or a previous step's result\n    const sourceData =\n      variable.step === 'trigger'\n        ? context.triggerData\n        : getStepResult(context.steps[variable.step.id ?? variable.step.name]);\n\n    logger.debug(\n      `Got source data for ${key} variable from ${variable.step === 'trigger' ? 'trigger' : (variable.step.id ?? variable.step.name)}`,\n      {\n        sourceData,\n        path: variable.path,\n        runId: runId,\n      },\n    );\n\n    if (!sourceData && variable.step !== 'trigger') {\n      resolvedData[key] = undefined;\n      continue;\n    }\n\n    // If path is empty or '.', return the entire source data\n    const value = variable.path === '' || variable.path === '.' ? sourceData : get(sourceData, variable.path);\n\n    logger.debug(`Resolved variable ${key}`, {\n      value,\n      runId: runId,\n    });\n\n    resolvedData[key] = value;\n  }\n\n  return resolvedData;\n}\n\nexport function workflowToStep<\n  TSteps extends Step<any, any, any, any>[],\n  TStepId extends string = any,\n  TTriggerSchema extends z.ZodObject<any> = any,\n  TResultSchema extends z.ZodObject<any> = any,\n>(\n  workflow: Workflow<TSteps, TStepId, TTriggerSchema, TResultSchema>,\n  { mastra }: { mastra?: Mastra },\n): StepAction<TStepId, TTriggerSchema, z.ZodType<WorkflowRunResult<TTriggerSchema, TSteps, TResultSchema>>, any> {\n  workflow.setNested(true);\n\n  return {\n    id: workflow.name,\n    workflow,\n    execute: async ({ context, suspend, emit, runId, mastra }) => {\n      if (mastra) {\n        workflow.__registerMastra(mastra);\n        workflow.__registerPrimitives({\n          logger: mastra.getLogger(),\n          telemetry: mastra.getTelemetry(),\n        });\n      }\n      const run = context.isResume ? workflow.createRun({ runId: context.isResume.runId }) : workflow.createRun();\n      const unwatch = run.watch(state => {\n        emit('state-update', workflow.name, state.value, { ...context, ...{ [workflow.name]: state.context } });\n      });\n\n      const awaitedResult =\n        context.isResume && context.isResume.stepId.includes('.')\n          ? await run.resume({\n              stepId: context.isResume.stepId.split('.').slice(1).join('.'),\n              context: context.inputData,\n            })\n          : await run.start({\n              triggerData: context.inputData,\n            });\n\n      unwatch();\n      if (!awaitedResult) {\n        throw new Error('Workflow run failed');\n      }\n\n      if (awaitedResult.activePaths?.size > 0) {\n        const suspendedStep = [...awaitedResult.activePaths.entries()].find(([stepId, { status }]) => {\n          return status === 'suspended';\n        });\n\n        if (suspendedStep) {\n          await suspend(suspendedStep[1].suspendPayload, { ...awaitedResult, runId: run.runId });\n          // await suspend({\n          //   ...suspendedStep[1].suspendPayload,\n          //   __meta: { nestedRunId: run.runId, nestedRunPaths: awaitedResult.activePaths },\n          // });\n        }\n      }\n\n      return { ...awaitedResult, runId: run.runId };\n    },\n  };\n}\n","import EventEmitter from 'events';\nimport type { Span } from '@opentelemetry/api';\nimport { get } from 'radash';\nimport sift from 'sift';\nimport type { MachineContext, Snapshot } from 'xstate';\nimport { assign, createActor, fromPromise, setup } from 'xstate';\nimport type { z } from 'zod';\n\nimport type { MastraUnion } from '../action';\nimport type { Logger } from '../logger';\n\nimport type { Mastra } from '../mastra';\nimport { createMastraProxy } from '../utils';\nimport type { Step } from './step';\nimport type {\n  DependencyCheckOutput,\n  ResolverFunctionInput,\n  ResolverFunctionOutput,\n  RetryConfig,\n  StepAction,\n  StepCondition,\n  StepDef,\n  StepGraph,\n  StepNode,\n  StepResolverOutput,\n  StepVariableType,\n  WorkflowActionParams,\n  WorkflowActions,\n  WorkflowActors,\n  WorkflowContext,\n  WorkflowEvent,\n  WorkflowRunResult,\n  WorkflowState,\n} from './types';\nimport { WhenConditionReturnValue } from './types';\nimport {\n  getResultActivePaths,\n  getStepResult,\n  getSuspendedPaths,\n  isErrorEvent,\n  isTransitionEvent,\n  recursivelyCheckForFinalState,\n} from './utils';\nimport type { WorkflowInstance } from './workflow-instance';\n\nexport class Machine<\n  TSteps extends Step<any, any, any>[] = any,\n  TTriggerSchema extends z.ZodObject<any> = any,\n  TResultSchema extends z.ZodObject<any> = any,\n> extends EventEmitter {\n  logger: Logger;\n  #mastra?: Mastra;\n  #workflowInstance: WorkflowInstance;\n  #executionSpan?: Span | undefined;\n\n  #stepGraph: StepGraph;\n  #machine!: ReturnType<typeof this.initializeMachine>;\n  #runId: string;\n  #startStepId: string;\n  name: string;\n\n  #actor: ReturnType<typeof createActor<ReturnType<typeof this.initializeMachine>>> | null = null;\n  #steps: Record<string, StepAction<any, any, any, any>> = {};\n  #retryConfig?: RetryConfig;\n\n  constructor({\n    logger,\n    mastra,\n    workflowInstance,\n    executionSpan,\n    name,\n    runId,\n    steps,\n    stepGraph,\n    retryConfig,\n    startStepId,\n  }: {\n    logger: Logger;\n    mastra?: Mastra;\n    workflowInstance: WorkflowInstance;\n    executionSpan?: Span;\n    name: string;\n    runId: string;\n    steps: Record<string, TSteps[0]>;\n    stepGraph: StepGraph;\n    retryConfig?: RetryConfig;\n    startStepId: string;\n  }) {\n    super();\n\n    this.#mastra = mastra;\n    this.#workflowInstance = workflowInstance;\n    this.#executionSpan = executionSpan;\n    this.logger = logger;\n\n    this.#runId = runId;\n    this.#startStepId = startStepId;\n    this.name = name;\n\n    this.#stepGraph = stepGraph;\n    this.#steps = steps;\n    this.#retryConfig = retryConfig;\n    this.initializeMachine();\n  }\n\n  get startStepId() {\n    return this.#startStepId;\n  }\n\n  async execute({\n    stepId,\n    input,\n    snapshot,\n    resumeData,\n  }: {\n    stepId?: string;\n    input?: any;\n    snapshot?: Snapshot<any>;\n    resumeData?: any;\n  } = {}): Promise<Pick<WorkflowRunResult<TTriggerSchema, TSteps, TResultSchema>, 'results' | 'activePaths'>> {\n    if (snapshot) {\n      // First, let's log the incoming snapshot for debugging\n      this.logger.debug(`Workflow snapshot received`, { runId: this.#runId, snapshot });\n    }\n\n    const origSteps = input.steps;\n    const isResumedInitialStep = this.#stepGraph?.initial[0]?.step?.id === stepId;\n\n    if (isResumedInitialStep) {\n      // we should not supply a snapshot if we are resuming the first step of a stepGraph, as that will halt execution\n      snapshot = undefined;\n      input.steps = {};\n    }\n\n    this.logger.debug(`Machine input prepared`, { runId: this.#runId, input });\n\n    const actorSnapshot = snapshot\n      ? {\n          ...snapshot,\n          context: {\n            ...input,\n            inputData: { ...((snapshot as any)?.context?.inputData || {}), ...resumeData },\n            // ts-ignore is needed here because our snapshot types don't really match xstate snapshot types right now. We should fix this in general.\n            // @ts-ignore\n            isResume: { runId: snapshot?.context?.steps[stepId.split('.')?.[0]]?.output?.runId || this.#runId, stepId },\n          },\n        }\n      : undefined;\n\n    this.logger.debug(`Creating actor with configuration`, {\n      input,\n      actorSnapshot,\n      runId: this.#runId,\n      machineStates: this.#machine.config.states,\n    });\n\n    this.#actor = createActor(this.#machine, {\n      inspect: (inspectionEvent: any) => {\n        this.logger.debug('XState inspection event', {\n          type: inspectionEvent.type,\n          event: inspectionEvent.event,\n          runId: this.#runId,\n        });\n      },\n      input: {\n        ...input,\n        inputData: { ...((snapshot as any)?.context?.inputData || {}), ...resumeData },\n      },\n      snapshot: actorSnapshot,\n    });\n\n    this.#actor.start();\n\n    if (stepId) {\n      this.#actor.send({ type: 'RESET_TO_PENDING', stepId });\n    }\n\n    this.logger.debug('Actor started', { runId: this.#runId });\n\n    return new Promise((resolve, reject) => {\n      if (!this.#actor) {\n        this.logger.error('Actor not initialized', { runId: this.#runId });\n        const e = new Error('Actor not initialized');\n        this.#executionSpan?.recordException(e);\n        this.#executionSpan?.end();\n        reject(e);\n        return;\n      }\n\n      const suspendedPaths: Set<string> = new Set();\n      this.#actor.subscribe(async state => {\n        this.emit('state-update', this.#startStepId, state.value, state.context);\n\n        getSuspendedPaths({\n          value: state.value as Record<string, string>,\n          path: '',\n          suspendedPaths,\n        });\n\n        const allStatesValue = state.value as Record<string, string>;\n\n        const allStatesComplete = recursivelyCheckForFinalState({\n          value: allStatesValue,\n          suspendedPaths,\n          path: '',\n        });\n\n        this.logger.debug('State completion check', {\n          allStatesComplete,\n          suspendedPaths: Array.from(suspendedPaths),\n          runId: this.#runId,\n        });\n\n        // Check if all parallel states are in a final state\n        if (!allStatesComplete) {\n          this.logger.debug('Not all states complete', {\n            allStatesComplete,\n            suspendedPaths: Array.from(suspendedPaths),\n            runId: this.#runId,\n          });\n          return;\n        }\n\n        try {\n          // Then cleanup and resolve\n          this.logger.debug('All states complete', { runId: this.#runId });\n          await this.#workflowInstance.persistWorkflowSnapshot();\n          this.#cleanup();\n          this.#executionSpan?.end();\n          resolve({\n            results: isResumedInitialStep ? { ...origSteps, ...state.context.steps } : state.context.steps,\n            activePaths: getResultActivePaths(\n              state as unknown as { value: Record<string, string>; context: { steps: Record<string, any> } },\n            ),\n          });\n        } catch (error) {\n          // If snapshot persistence fails, we should still resolve\n          // but maybe log the error\n          this.logger.debug('Failed to persist final snapshot', { error });\n\n          this.#cleanup();\n          this.#executionSpan?.end();\n          resolve({\n            results: isResumedInitialStep ? { ...origSteps, ...state.context.steps } : state.context.steps,\n            activePaths: getResultActivePaths(\n              state as unknown as { value: Record<string, string>; context: { steps: Record<string, any> } },\n            ),\n          });\n        }\n      });\n    });\n  }\n\n  #cleanup() {\n    if (this.#actor) {\n      this.#actor.stop();\n      this.#actor = null;\n    }\n\n    this.removeAllListeners();\n  }\n\n  #makeDelayMap() {\n    const delayMap: Record<string, number> = {};\n\n    Object.keys(this.#steps).forEach(stepId => {\n      delayMap[stepId] = this.#steps[stepId]?.retryConfig?.delay || this.#retryConfig?.delay || 1000;\n    });\n\n    return delayMap;\n  }\n\n  #getDefaultActions() {\n    return {\n      updateStepResult: assign({\n        steps: ({ context, event }: { context: WorkflowContext; event: any }) => {\n          if (!isTransitionEvent(event)) return context.steps;\n\n          const { stepId, result } = event.output as ResolverFunctionOutput;\n\n          return {\n            ...context.steps,\n            [stepId]: {\n              status: 'success' as const,\n              output: result,\n            },\n          };\n        },\n      }),\n      setStepError: assign({\n        steps: ({ context, event }: { context: WorkflowContext; event: any }, params: WorkflowActionParams) => {\n          if (!isErrorEvent(event)) return context.steps;\n\n          const { stepId } = params;\n\n          if (!stepId) return context.steps;\n\n          return {\n            ...context.steps,\n            [stepId]: {\n              status: 'failed' as const,\n              error: event.error.message,\n            },\n          };\n        },\n      }),\n      notifyStepCompletion: async (_: any, params: WorkflowActionParams) => {\n        const { stepId } = params;\n        this.logger.debug(`Step ${stepId} completed`);\n      },\n      snapshotStep: assign({\n        _snapshot: ({}, params: WorkflowActionParams) => {\n          const { stepId } = params;\n          // This will run after the state update\n          return { stepId };\n        },\n      }),\n      persistSnapshot: async ({ context }: { context: MachineContext }) => {\n        if (context._snapshot) {\n          await this.#workflowInstance.persistWorkflowSnapshot();\n        }\n        return;\n      },\n      decrementAttemptCount: assign({\n        attempts: ({ context, event }: { context: WorkflowContext; event: any }, params: WorkflowActionParams) => {\n          if (!isTransitionEvent(event)) return context.attempts;\n\n          const { stepId } = params;\n          const attemptCount = context.attempts[stepId];\n\n          if (attemptCount === undefined) return context.attempts;\n\n          return { ...context.attempts, [stepId]: attemptCount - 1 };\n        },\n      }),\n    };\n  }\n\n  #getDefaultActors() {\n    return {\n      resolverFunction: fromPromise(async ({ input }: { input: ResolverFunctionInput }) => {\n        const { stepNode, context } = input;\n        const attemptCount = context.attempts[stepNode.step.id];\n\n        const resolvedData = this.#resolveVariables({\n          stepConfig: stepNode.config,\n          context,\n          stepId: stepNode.step.id,\n        });\n\n        this.logger.debug(`Resolved variables for ${stepNode.step.id}`, {\n          resolvedData,\n          runId: this.#runId,\n        });\n\n        const logger = this.logger;\n        let mastraProxy = undefined;\n\n        if (this.#mastra) {\n          mastraProxy = createMastraProxy({ mastra: this.#mastra, logger });\n        }\n\n        let result = undefined;\n\n        try {\n          result = await stepNode.config.handler({\n            context: {\n              ...context,\n              inputData: { ...(context?.inputData || {}), ...resolvedData },\n              getStepResult: ((stepId: string | Step<any, any, any, any>) => {\n                const resolvedStepId = typeof stepId === 'string' ? stepId : stepId.id;\n\n                if (resolvedStepId === 'trigger') {\n                  return context.triggerData;\n                }\n                const result = context.steps[resolvedStepId];\n                if (result && result.status === 'success') {\n                  return result.output;\n                }\n                return undefined;\n              }) satisfies WorkflowContext<TTriggerSchema>['getStepResult'],\n            } as WorkflowContext,\n            emit: (event: string, ...args: any[]) => {\n              // console.log(this.#workflowInstance.name, 'emitting', event, ...args);\n              this.emit(event, ...args);\n            },\n            suspend: async (payload?: any, softSuspend?: any) => {\n              await this.#workflowInstance.suspend(stepNode.step.id, this);\n              if (this.#actor) {\n                // Update context with current result\n                context.steps[stepNode.step.id] = {\n                  status: 'suspended',\n                  suspendPayload: payload,\n                  output: softSuspend,\n                };\n                this.logger.debug(`Sending SUSPENDED event for step ${stepNode.step.id}`);\n                this.#actor?.send({\n                  type: 'SUSPENDED',\n                  suspendPayload: payload,\n                  stepId: stepNode.step.id,\n                  softSuspend,\n                });\n              } else {\n                this.logger.debug(`Actor not available for step ${stepNode.step.id}`);\n              }\n            },\n            runId: this.#runId,\n            mastra: mastraProxy as MastraUnion | undefined,\n          });\n        } catch (error) {\n          this.logger.debug(`Step ${stepNode.step.id} failed`, {\n            stepId: stepNode.step.id,\n            error,\n            runId: this.#runId,\n          });\n\n          this.logger.debug(`Attempt count for step ${stepNode.step.id}`, {\n            attemptCount,\n            attempts: context.attempts,\n            runId: this.#runId,\n            stepId: stepNode.step.id,\n          });\n\n          if (!attemptCount || attemptCount < 0) {\n            return {\n              type: 'STEP_FAILED' as const,\n              error: error instanceof Error ? error.message : `Step:${stepNode.step.id} failed with error: ${error}`,\n              stepId: stepNode.step.id,\n            };\n          }\n\n          return { type: 'STEP_WAITING' as const, stepId: stepNode.step.id };\n        }\n\n        this.logger.debug(`Step ${stepNode.step.id} result`, {\n          stepId: stepNode.step.id,\n          result,\n          runId: this.#runId,\n        });\n\n        return {\n          type: 'STEP_SUCCESS' as const,\n          result,\n          stepId: stepNode.step.id,\n        };\n      }),\n      conditionCheck: fromPromise(async ({ input }: { input: { context: WorkflowContext; stepNode: StepNode } }) => {\n        const { context, stepNode } = input;\n        const stepConfig = stepNode.config;\n\n        this.logger.debug(`Checking conditions for step ${stepNode.step.id}`, {\n          stepId: stepNode.step.id,\n          runId: this.#runId,\n        });\n\n        if (!stepConfig?.when) {\n          return { type: 'CONDITIONS_MET' as const };\n        }\n\n        this.logger.debug(`Checking conditions for step ${stepNode.step.id}`, {\n          stepId: stepNode.step.id,\n          runId: this.#runId,\n        });\n\n        if (typeof stepConfig?.when === 'function') {\n          let conditionMet = await stepConfig.when({\n            context: {\n              ...context,\n              getStepResult: ((stepId: string | Step<any, any, any, any>) => {\n                const resolvedStepId = typeof stepId === 'string' ? stepId : stepId.id;\n\n                if (resolvedStepId === 'trigger') {\n                  return context.triggerData;\n                }\n                const result = context.steps[resolvedStepId];\n                if (result && result.status === 'success') {\n                  return result.output;\n                }\n                return undefined;\n              }) satisfies WorkflowContext<TTriggerSchema>['getStepResult'],\n            },\n            mastra: this.#mastra,\n          });\n\n          if (conditionMet === WhenConditionReturnValue.ABORT) {\n            conditionMet = false;\n          } else if (conditionMet === WhenConditionReturnValue.CONTINUE_FAILED) {\n            // TODO: send another kind of event instead\n            return { type: 'CONDITIONS_SKIP_TO_COMPLETED' as const };\n          } else if (conditionMet === WhenConditionReturnValue.LIMBO) {\n            return { type: 'CONDITIONS_LIMBO' as const };\n          } else if (conditionMet) {\n            this.logger.debug(`Condition met for step ${stepNode.step.id}`, {\n              stepId: stepNode.step.id,\n              runId: this.#runId,\n            });\n            return { type: 'CONDITIONS_MET' as const };\n          }\n          return this.#workflowInstance.hasSubscribers(stepNode.step.id)\n            ? { type: 'CONDITIONS_SKIPPED' as const }\n            : { type: 'CONDITIONS_LIMBO' as const };\n        } else {\n          const conditionMet = this.#evaluateCondition(stepConfig.when, context);\n          if (!conditionMet) {\n            return {\n              type: 'CONDITION_FAILED' as const,\n              error: `Step:${stepNode.step.id} condition check failed`,\n            };\n          }\n        }\n        return { type: 'CONDITIONS_MET' as const };\n      }),\n      spawnSubscriberFunction: fromPromise(\n        async ({\n          input,\n        }: {\n          input: {\n            parentStepId: string;\n            context: WorkflowContext;\n          };\n        }) => {\n          const { parentStepId, context } = input;\n          const result = await this.#workflowInstance.runMachine(parentStepId, context);\n          return Promise.resolve({\n            steps: result.reduce((acc, r) => {\n              return { ...acc, ...r?.results };\n            }, {}),\n          });\n        },\n      ),\n    };\n  }\n\n  #resolveVariables<\n    TStepId extends TSteps[number]['id'],\n    TSchemaIn extends z.ZodSchema,\n    TSchemaOut extends z.ZodSchema,\n  >({\n    stepConfig,\n    context,\n    stepId,\n  }: {\n    stepConfig: StepDef<TStepId, TSteps, TSchemaIn, TSchemaOut>[TStepId];\n    context: WorkflowContext;\n    stepId: TStepId;\n  }): Record<string, any> {\n    this.logger.debug(`Resolving variables for step ${stepId}`, {\n      stepId,\n      runId: this.#runId,\n    });\n\n    const resolvedData: Record<string, any> = {};\n\n    for (const [key, variable] of Object.entries(stepConfig.data)) {\n      // Check if variable comes from trigger data or a previous step's result\n      const sourceData =\n        variable.step === 'trigger' ? context.triggerData : getStepResult(context.steps[variable.step.id]);\n\n      this.logger.debug(\n        `Got source data for ${key} variable from ${variable.step === 'trigger' ? 'trigger' : variable.step.id}`,\n        {\n          sourceData,\n          path: variable.path,\n          runId: this.#runId,\n        },\n      );\n\n      if (!sourceData && variable.step !== 'trigger') {\n        resolvedData[key] = undefined;\n        continue;\n      }\n\n      // If path is empty or '.', return the entire source data\n      const value = variable.path === '' || variable.path === '.' ? sourceData : get(sourceData, variable.path);\n\n      this.logger.debug(`Resolved variable ${key}`, {\n        value,\n        runId: this.#runId,\n      });\n\n      resolvedData[key] = value;\n    }\n\n    return resolvedData;\n  }\n\n  private initializeMachine() {\n    const machine = setup({\n      types: {} as {\n        context: Omit<WorkflowContext, 'getStepResult'>;\n        input: Omit<WorkflowContext, 'getStepResult'>;\n        events: WorkflowEvent;\n        actions: WorkflowActions;\n        actors: WorkflowActors;\n      },\n      delays: this.#makeDelayMap(),\n      actions: this.#getDefaultActions() as any,\n      actors: this.#getDefaultActors(),\n    }).createMachine({\n      id: this.name,\n      type: 'parallel',\n      context: ({ input }) => ({\n        ...input,\n      }),\n      states: this.#buildStateHierarchy(this.#stepGraph) as any,\n    });\n\n    this.#machine = machine;\n    return machine;\n  }\n\n  #buildStateHierarchy(stepGraph: StepGraph): WorkflowState {\n    const states: Record<string, any> = {};\n\n    stepGraph.initial.forEach(stepNode => {\n      const nextSteps = [...(stepGraph[stepNode.step.id] || [])];\n      // TODO: For identical steps, use index to create unique key\n      states[stepNode.step.id] = {\n        ...this.#buildBaseState(stepNode, nextSteps),\n      };\n    });\n\n    return states;\n  }\n\n  #buildBaseState(stepNode: StepNode, nextSteps: StepNode[] = []): any {\n    // NOTE: THIS CLEARS THE STEPGRAPH :: no concequences for now\n    const nextStep = nextSteps.shift();\n\n    return {\n      initial: 'pending',\n      on: {\n        RESET_TO_PENDING: {\n          target: '.pending', // Note the dot to target child state\n        },\n      },\n      states: {\n        pending: {\n          entry: () => {\n            this.logger.debug(`Step ${stepNode.step.id} pending`, {\n              stepId: stepNode.step.id,\n              runId: this.#runId,\n            });\n          },\n          exit: () => {\n            this.logger.debug(`Step ${stepNode.step.id} finished pending`, {\n              stepId: stepNode.step.id,\n              runId: this.#runId,\n            });\n          },\n          invoke: {\n            src: 'conditionCheck',\n            input: ({ context }: { context: WorkflowContext }) => {\n              return {\n                context,\n                stepNode,\n              };\n            },\n            onDone: [\n              {\n                guard: ({ event }: { event: { output: DependencyCheckOutput } }) => {\n                  return event.output.type === 'SUSPENDED';\n                },\n                target: 'suspended',\n                actions: [\n                  assign({\n                    steps: ({ context, event }) => {\n                      if (event.output.type !== 'SUSPENDED') return context.steps;\n                      if (event.output.softSuspend) {\n                        return {\n                          ...context.steps,\n                          [stepNode.step.id]: {\n                            status: 'suspended',\n                            ...(context.steps?.[stepNode.step.id] || {}),\n                            output: event.output.softSuspend,\n                          },\n                        };\n                      }\n                      return {\n                        ...context.steps,\n                        [stepNode.step.id]: {\n                          status: 'suspended',\n                          ...(context.steps?.[stepNode.step.id] || {}),\n                        },\n                      };\n                    },\n                    attempts: ({ context, event }) => {\n                      if (event.output.type !== 'SUSPENDED') return context.attempts;\n                      // if the step is suspended, reset the attempt count\n                      return { ...context.attempts, [stepNode.step.id]: stepNode.step.retryConfig?.attempts || 0 };\n                    },\n                  }),\n                ],\n              },\n              {\n                guard: ({ event }: { event: { output: DependencyCheckOutput } }) => {\n                  return event.output.type === 'WAITING';\n                },\n                target: 'waiting',\n                actions: [\n                  { type: 'decrementAttemptCount', params: { stepId: stepNode.step.id } },\n                  assign({\n                    steps: ({ context, event }) => {\n                      if (event.output.type !== 'WAITING') return context.steps;\n                      return {\n                        ...context.steps,\n                        [stepNode.step.id]: {\n                          status: 'waiting',\n                        },\n                      };\n                    },\n                  }),\n                ],\n              },\n              {\n                guard: ({ event }: { event: { output: DependencyCheckOutput } }) => {\n                  return event.output.type === 'CONDITIONS_MET';\n                },\n                target: 'executing',\n              },\n              {\n                guard: ({ event }: { event: { output: DependencyCheckOutput } }) => {\n                  return event.output.type === 'CONDITIONS_SKIP_TO_COMPLETED';\n                },\n                target: 'completed',\n              },\n              {\n                guard: ({ event }: { event: { output: DependencyCheckOutput } }) => {\n                  return event.output.type === 'CONDITIONS_SKIPPED';\n                },\n                actions: assign({\n                  steps: ({ context }) => {\n                    const newStep = {\n                      ...context.steps,\n                      [stepNode.step.id]: {\n                        status: 'skipped',\n                      },\n                    };\n\n                    this.logger.debug(`Step ${stepNode.step.id} skipped`, {\n                      stepId: stepNode.step.id,\n                      runId: this.#runId,\n                    });\n\n                    return newStep;\n                  },\n                }),\n\n                target: 'runningSubscribers',\n              },\n              {\n                guard: ({ event }: { event: { output: DependencyCheckOutput } }) => {\n                  return event.output.type === 'CONDITIONS_LIMBO';\n                },\n                target: 'limbo',\n                actions: assign({\n                  steps: ({ context }) => {\n                    const newStep = {\n                      ...context.steps,\n                      [stepNode.step.id]: {\n                        status: 'skipped',\n                      },\n                    };\n\n                    this.logger.debug(`Step ${stepNode.step.id} skipped`, {\n                      stepId: stepNode.step.id,\n                      runId: this.#runId,\n                    });\n\n                    return newStep;\n                  },\n                }),\n              },\n              {\n                guard: ({ event }: { event: { output: DependencyCheckOutput } }) => {\n                  return event.output.type === 'CONDITION_FAILED';\n                },\n                target: 'failed',\n                actions: assign({\n                  steps: ({ context, event }) => {\n                    if (event.output.type !== 'CONDITION_FAILED') return context.steps;\n\n                    this.logger.debug(`Workflow condition check failed`, {\n                      error: event.output.error,\n                      stepId: stepNode.step.id,\n                    });\n\n                    return {\n                      ...context.steps,\n                      [stepNode.step.id]: {\n                        status: 'failed',\n                        error: event.output.error,\n                      },\n                    };\n                  },\n                }),\n              },\n            ],\n          },\n        },\n        waiting: {\n          entry: () => {\n            this.logger.debug(`Step ${stepNode.step.id} waiting`, {\n              stepId: stepNode.step.id,\n              timestamp: new Date().toISOString(),\n              runId: this.#runId,\n            });\n          },\n          exit: () => {\n            this.logger.debug(`Step ${stepNode.step.id} finished waiting`, {\n              stepId: stepNode.step.id,\n              timestamp: new Date().toISOString(),\n              runId: this.#runId,\n            });\n          },\n          after: {\n            [stepNode.step.id]: {\n              target: 'pending',\n            },\n          },\n        },\n        limbo: {\n          // no target, will stay in limbo indefinitely\n          entry: () => {\n            this.logger.debug(`Step ${stepNode.step.id} limbo`, {\n              stepId: stepNode.step.id,\n              timestamp: new Date().toISOString(),\n              runId: this.#runId,\n            });\n          },\n          exit: () => {\n            this.logger.debug(`Step ${stepNode.step.id} finished limbo`, {\n              stepId: stepNode.step.id,\n              timestamp: new Date().toISOString(),\n              runId: this.#runId,\n            });\n          },\n        },\n        suspended: {\n          type: 'final',\n          entry: [\n            () => {\n              this.logger.debug(`Step ${stepNode.step.id} suspended`, {\n                stepId: stepNode.step.id,\n                runId: this.#runId,\n              });\n            },\n            assign({\n              steps: ({ context, event }: { context: WorkflowContext; event: WorkflowEvent }) => {\n                return {\n                  ...context.steps,\n                  [stepNode.step.id]: {\n                    ...(context?.steps?.[stepNode.step.id] || {}),\n                    status: 'suspended',\n                    suspendPayload: event.type === 'SUSPENDED' ? event.suspendPayload : undefined,\n                    output: event.type === 'SUSPENDED' ? event.softSuspend : undefined,\n                  },\n                };\n              },\n            }),\n          ],\n        },\n        executing: {\n          entry: () => {\n            this.logger.debug(`Step ${stepNode.step.id} executing`, {\n              stepId: stepNode.step.id,\n              runId: this.#runId,\n            });\n          },\n          on: {\n            SUSPENDED: {\n              target: 'suspended',\n              actions: [\n                assign({\n                  steps: ({ context, event }: { context: WorkflowContext; event: WorkflowEvent }) => {\n                    return {\n                      ...context.steps,\n                      [stepNode.step.id]: {\n                        status: 'suspended',\n                        suspendPayload: event.type === 'SUSPENDED' ? event.suspendPayload : undefined,\n                        output: event.type === 'SUSPENDED' ? event.softSuspend : undefined,\n                      },\n                    };\n                  },\n                }),\n              ],\n            },\n          },\n          invoke: {\n            src: 'resolverFunction',\n            input: ({ context }: { context: WorkflowContext }) => ({\n              context,\n              stepNode,\n            }),\n            onDone: [\n              {\n                guard: ({ event }: { event: { output: StepResolverOutput } }) => {\n                  return event.output.type === 'STEP_FAILED';\n                },\n                target: 'failed',\n                actions: assign({\n                  steps: ({ context, event }) => {\n                    if (event.output.type !== 'STEP_FAILED') return context.steps;\n\n                    const newStep = {\n                      ...context.steps,\n                      [stepNode.step.id]: {\n                        status: 'failed',\n                        error: event.output.error,\n                      },\n                    };\n\n                    this.logger.debug(`Step ${stepNode.step.id} failed`, {\n                      error: event.output.error,\n                      stepId: stepNode.step.id,\n                    });\n\n                    return newStep;\n                  },\n                }),\n              },\n              {\n                guard: ({ event }: { event: { output: StepResolverOutput } }) => {\n                  return event.output.type === 'STEP_SUCCESS';\n                },\n                actions: [\n                  ({ event }: { event: { output: StepResolverOutput } }) => {\n                    this.logger.debug(`Step ${stepNode.step.id} finished executing`, {\n                      stepId: stepNode.step.id,\n                      output: event.output,\n                      runId: this.#runId,\n                    });\n                  },\n                  { type: 'updateStepResult', params: { stepId: stepNode.step.id } },\n                  { type: 'spawnSubscribers', params: { stepId: stepNode.step.id } },\n                ],\n                target: 'runningSubscribers',\n              },\n              {\n                guard: ({ event }: { event: { output: StepResolverOutput } }) => {\n                  return event.output.type === 'STEP_WAITING';\n                },\n                target: 'waiting',\n                actions: [\n                  { type: 'decrementAttemptCount', params: { stepId: stepNode.step.id } },\n                  assign({\n                    steps: ({ context, event }) => {\n                      if (event.output.type !== 'STEP_WAITING') return context.steps;\n                      return {\n                        ...context.steps,\n                        [stepNode.step.id]: {\n                          status: 'waiting',\n                        },\n                      };\n                    },\n                  }),\n                ],\n              },\n            ],\n            onError: {\n              target: 'failed',\n              actions: [{ type: 'setStepError', params: { stepId: stepNode.step.id } }],\n            },\n          },\n        },\n        runningSubscribers: {\n          entry: () => {\n            this.logger.debug(`Step ${stepNode.step.id} running subscribers`, {\n              stepId: stepNode.step.id,\n              runId: this.#runId,\n            });\n          },\n          exit: () => {\n            this.logger.debug(`Step ${stepNode.step.id} finished running subscribers`, {\n              stepId: stepNode.step.id,\n              runId: this.#runId,\n            });\n          },\n          invoke: {\n            src: 'spawnSubscriberFunction',\n            input: ({ context }: { context: WorkflowContext }) => ({\n              parentStepId: stepNode.step.id,\n              context,\n            }),\n            onDone: {\n              target: nextStep ? nextStep.step.id : 'completed',\n              actions: [\n                assign({\n                  steps: ({ context, event }: { context: WorkflowContext; event: any }) => ({\n                    ...context.steps,\n                    ...event.output.steps,\n                  }),\n                }),\n                () => this.logger.debug(`Subscriber execution completed`, { stepId: stepNode.step.id }),\n              ],\n            },\n            onError: {\n              target: nextStep ? nextStep.step.id : 'completed',\n              actions: ({ event }: { context: WorkflowContext; event: any }) => {\n                this.logger.debug(`Subscriber execution failed`, {\n                  error: event.error,\n                  stepId: stepNode.step.id,\n                });\n              },\n            },\n          },\n        },\n        completed: {\n          type: 'final',\n          entry: [\n            { type: 'notifyStepCompletion', params: { stepId: stepNode.step.id } },\n            { type: 'snapshotStep', params: { stepId: stepNode.step.id } },\n            { type: 'persistSnapshot' },\n          ],\n        },\n        failed: {\n          type: 'final',\n          entry: [\n            { type: 'notifyStepCompletion', params: { stepId: stepNode.step.id } },\n            { type: 'snapshotStep', params: { stepId: stepNode.step.id } },\n            { type: 'persistSnapshot' },\n          ],\n        },\n        // build chain of next steps recursively\n        ...(nextStep ? { [nextStep.step.id]: { ...this.#buildBaseState(nextStep, nextSteps) } } : {}),\n      },\n    };\n  }\n\n  #evaluateCondition<TStep extends StepVariableType<any, any, any, any>, TTriggerSchema extends z.ZodObject<any>>(\n    condition: StepCondition<TStep, TTriggerSchema>,\n    context: WorkflowContext,\n  ): boolean {\n    let andBranchResult = true;\n    let baseResult = true;\n    let orBranchResult = true;\n\n    // Base condition simplified format\n    const simpleCondition = Object.entries(condition).find(([key]) => key.includes('.'));\n    if (simpleCondition) {\n      const [key, queryValue] = simpleCondition;\n      const [stepId, ...pathParts] = key.split('.');\n      const path = pathParts.join('.');\n\n      const sourceData = stepId === 'trigger' ? context.triggerData : getStepResult(context.steps[stepId as string]);\n\n      this.logger.debug(`Got condition data from step ${stepId}`, {\n        stepId,\n        sourceData,\n        runId: this.#runId,\n      });\n\n      if (!sourceData) {\n        return false;\n      }\n\n      let value = get(sourceData, path);\n\n      // If path is 'status', check if value is empty and we are not referencing the trigger.\n      // Currently only successful step results get to this point, so we can safely assume that the status is 'success'\n      if (stepId !== 'trigger' && path === 'status' && !value) {\n        value = 'success';\n      }\n\n      // Handle different types of queries\n      if (typeof queryValue === 'object' && queryValue !== null) {\n        // If it's an object, treat it as a query object\n        baseResult = sift(queryValue)(value);\n      } else {\n        // For simple values, do an equality check\n        baseResult = value === queryValue;\n      }\n    }\n\n    // Base condition\n    if ('ref' in condition) {\n      const { ref, query } = condition;\n      const sourceData = ref.step === 'trigger' ? context.triggerData : getStepResult(context.steps[ref.step.id]);\n\n      this.logger.debug(`Got condition data from ${ref.step === 'trigger' ? 'trigger' : ref.step.id}`, {\n        sourceData,\n        runId: this.#runId,\n      });\n\n      if (!sourceData) {\n        return false;\n      }\n\n      let value = get(sourceData, ref.path);\n\n      // If path is 'status', check if value is empty and we are not referencing the trigger.\n      // Currently only successful step results get to this point, so we can safely assume that the status is 'success'\n      if (ref.step !== 'trigger' && ref.path === 'status' && !value) {\n        value = 'success';\n      }\n\n      baseResult = sift(query)(value);\n    }\n\n    // AND condition\n    if ('and' in condition) {\n      andBranchResult = condition.and.every(cond => this.#evaluateCondition(cond, context));\n      this.logger.debug(`Evaluated AND condition`, {\n        andBranchResult,\n        runId: this.#runId,\n      });\n    }\n\n    // OR condition\n    if ('or' in condition) {\n      orBranchResult = condition.or.some(cond => this.#evaluateCondition(cond, context));\n      this.logger.debug(`Evaluated OR condition`, {\n        orBranchResult,\n        runId: this.#runId,\n      });\n    }\n\n    if ('not' in condition) {\n      baseResult = !this.#evaluateCondition(condition.not, context);\n      this.logger.debug(`Evaluated NOT condition`, {\n        baseResult,\n        runId: this.#runId,\n      });\n    }\n\n    const finalResult = baseResult && andBranchResult && orBranchResult;\n\n    this.logger.debug(`Evaluated condition`, {\n      finalResult,\n      runId: this.#runId,\n    });\n\n    return finalResult;\n  }\n\n  getSnapshot() {\n    const snapshot = this.#actor?.getSnapshot();\n    return snapshot;\n  }\n}\n","import type { Span } from '@opentelemetry/api';\nimport { context as otlpContext, trace } from '@opentelemetry/api';\nimport type { Snapshot } from 'xstate';\nimport type { z } from 'zod';\n\nimport type { Logger } from '../logger';\n\nimport type { Mastra } from '../mastra';\nimport { Machine } from './machine';\nimport type { Step } from './step';\nimport type {\n  ActionContext,\n  RetryConfig,\n  StepAction,\n  StepDef,\n  StepGraph,\n  WorkflowContext,\n  WorkflowRunResult,\n  WorkflowRunState,\n} from './types';\nimport { getActivePathsAndStatus, mergeChildValue, resolveVariables, updateStepInHierarchy } from './utils';\n\nexport interface WorkflowResultReturn<\n  TResult extends z.ZodObject<any>,\n  T extends z.ZodObject<any>,\n  TSteps extends Step<any, any, any>[],\n> {\n  runId: string;\n  start: (props?: { triggerData?: z.infer<T> } | undefined) => Promise<WorkflowRunResult<T, TSteps, TResult>>;\n  watch: (onTransition: (state: WorkflowRunState) => void) => () => void;\n  resume: (props: {\n    stepId: string;\n    context?: Record<string, any>;\n  }) => Promise<Omit<WorkflowRunResult<T, TSteps, TResult>, 'runId'> | undefined>;\n  resumeWithEvent: (\n    eventName: string,\n    data: any,\n  ) => Promise<Omit<WorkflowRunResult<T, TSteps, TResult>, 'runId'> | undefined>;\n}\n\nexport class WorkflowInstance<\n  TSteps extends Step<any, any, any>[] = any,\n  TTriggerSchema extends z.ZodObject<any> = any,\n  TResult extends z.ZodObject<any> = any,\n> implements WorkflowResultReturn<TResult, TTriggerSchema, TSteps>\n{\n  name: string;\n  #mastra?: Mastra;\n  #machines: Record<string, Machine<TSteps, TTriggerSchema>> = {};\n\n  logger: Logger;\n\n  #steps: Record<string, StepAction<any, any, any, any>> = {};\n  #stepGraph: StepGraph;\n  #stepSubscriberGraph: Record<string, StepGraph> = {};\n\n  #retryConfig?: RetryConfig;\n  events?: Record<string, { schema: z.ZodObject<any> }>;\n\n  #runId: string;\n  #state: any | null = null;\n  #executionSpan: Span | undefined;\n\n  #onStepTransition: Set<(state: WorkflowRunState) => void | Promise<void>> = new Set();\n  #onFinish?: () => void;\n\n  #resultMapping?: Record<string, { step: StepAction<any, any, any, any>; path: string }>;\n\n  // indexed by stepId\n  #suspendedMachines: Record<string, Machine<TSteps, TTriggerSchema>> = {};\n  // {step1&&step2: {step1: true, step2: true}}\n  #compoundDependencies: Record<string, Record<string, boolean>> = {};\n\n  constructor({\n    name,\n    logger,\n    steps,\n    runId,\n    retryConfig,\n    mastra,\n    stepGraph,\n    stepSubscriberGraph,\n    onFinish,\n    onStepTransition,\n    resultMapping,\n    events,\n  }: {\n    name: string;\n    logger: Logger;\n    steps: Record<string, StepAction<any, any, any, any>>;\n    mastra?: Mastra;\n    retryConfig?: RetryConfig;\n    runId?: string;\n    stepGraph: StepGraph;\n    stepSubscriberGraph: Record<string, StepGraph>;\n    onFinish?: () => void;\n    onStepTransition?: Set<(state: WorkflowRunState) => void | Promise<void>>;\n    resultMapping?: Record<string, { step: StepAction<any, any, any, any>; path: string }>;\n    events?: Record<string, { schema: z.ZodObject<any> }>;\n  }) {\n    this.name = name;\n    this.logger = logger;\n\n    this.#steps = steps;\n    this.#stepGraph = stepGraph;\n    this.#stepSubscriberGraph = stepSubscriberGraph;\n\n    this.#retryConfig = retryConfig;\n    this.#mastra = mastra;\n\n    this.#runId = runId ?? crypto.randomUUID();\n\n    this.#onFinish = onFinish;\n\n    this.#resultMapping = resultMapping;\n\n    this.events = events;\n    onStepTransition?.forEach(handler => this.#onStepTransition.add(handler));\n    this.#initializeCompoundDependencies();\n  }\n\n  setState(state: any) {\n    this.#state = state;\n  }\n\n  get runId() {\n    return this.#runId;\n  }\n\n  get executionSpan() {\n    return this.#executionSpan;\n  }\n\n  watch(onTransition: (state: WorkflowRunState) => void): () => void {\n    this.#onStepTransition.add(onTransition);\n\n    return () => {\n      this.#onStepTransition.delete(onTransition);\n    };\n  }\n\n  async start({ triggerData }: { triggerData?: z.infer<TTriggerSchema> } = {}) {\n    const results = await this.execute({ triggerData });\n\n    if (this.#onFinish) {\n      this.#onFinish();\n    }\n\n    return {\n      ...results,\n      runId: this.runId,\n    };\n  }\n\n  private isCompoundDependencyMet(stepKey: string): boolean {\n    // If this is not a compound dependency, return true\n    if (!this.#isCompoundKey(stepKey)) return true;\n\n    const dependencies = this.#compoundDependencies[stepKey];\n    // Check if all required steps are completed successfully\n    return dependencies ? Object.values(dependencies).every(status => status === true) : true;\n  }\n\n  async execute({\n    triggerData,\n    snapshot,\n    stepId,\n    resumeData,\n  }: {\n    stepId?: string;\n    triggerData?: z.infer<TTriggerSchema>;\n    snapshot?: Snapshot<any>;\n    resumeData?: any; // TODO: once we have a resume schema plug that in here\n  } = {}): Promise<Omit<WorkflowRunResult<TTriggerSchema, TSteps, TResult>, 'runId'>> {\n    this.#executionSpan = this.#mastra?.getTelemetry()?.tracer.startSpan(`workflow.${this.name}.execute`, {\n      attributes: { componentName: this.name, runId: this.runId },\n    });\n\n    let machineInput = {\n      // Maintain the original step results and their output\n      steps: {},\n      triggerData: triggerData || {},\n      attempts: Object.keys(this.#steps).reduce(\n        (acc, stepKey) => {\n          acc[stepKey] = this.#steps[stepKey]?.retryConfig?.attempts || this.#retryConfig?.attempts || 0;\n          return acc;\n        },\n        {} as Record<string, number>,\n      ),\n    };\n    let stepGraph = this.#stepGraph;\n    let startStepId = 'trigger';\n\n    if (snapshot) {\n      const runState = snapshot as unknown as WorkflowRunState;\n\n      if (stepId && runState?.suspendedSteps?.[stepId]) {\n        startStepId = runState.suspendedSteps[stepId];\n        stepGraph = this.#stepSubscriberGraph[startStepId] ?? this.#stepGraph;\n        machineInput = runState.context;\n      }\n    }\n\n    const defaultMachine = new Machine({\n      logger: this.logger,\n      mastra: this.#mastra,\n      workflowInstance: this,\n      name: this.name,\n      runId: this.runId,\n      steps: this.#steps,\n      stepGraph,\n      executionSpan: this.#executionSpan,\n      startStepId,\n      retryConfig: this.#retryConfig,\n    });\n\n    this.#machines[startStepId] = defaultMachine;\n\n    const stateUpdateHandler = (startStepId: string, state: any, context: any) => {\n      if (startStepId === 'trigger') {\n        this.#state = state;\n      } else {\n        this.#state = mergeChildValue(startStepId, this.#state, state);\n      }\n\n      const now = Date.now();\n      if (this.#onStepTransition) {\n        this.#onStepTransition.forEach(onTransition => {\n          void onTransition({\n            runId: this.#runId,\n            value: this.#state as Record<string, string>,\n            context: context as WorkflowContext,\n            activePaths: getActivePathsAndStatus(this.#state as Record<string, string>),\n            timestamp: now,\n          });\n        });\n      }\n    };\n\n    defaultMachine.on('state-update', stateUpdateHandler);\n\n    const { results, activePaths } = await defaultMachine.execute({\n      snapshot,\n      stepId,\n      input: machineInput,\n      resumeData,\n    });\n\n    await this.persistWorkflowSnapshot();\n\n    const result: Omit<WorkflowRunResult<TTriggerSchema, TSteps, TResult>, 'runId'> = { results, activePaths };\n    if (this.#resultMapping) {\n      result.result = resolveVariables({\n        runId: this.#runId,\n        logger: this.logger,\n        variables: this.#resultMapping,\n        context: {\n          steps: results,\n          triggerData: triggerData,\n          inputData: {},\n          attempts: machineInput.attempts,\n          getStepResult: (stepId: string) => results[stepId],\n        },\n      });\n    }\n\n    return result;\n  }\n\n  hasSubscribers(stepId: string) {\n    return Object.keys(this.#stepSubscriberGraph).some(key => key.split('&&').includes(stepId));\n  }\n\n  async runMachine(parentStepId: string, input: any) {\n    const stepStatus = input.steps[parentStepId]?.status;\n\n    // get all keys from this.#stepSubscriberGraph that include the parentStepId after the &&\n    const subscriberKeys = Object.keys(this.#stepSubscriberGraph).filter(key => key.split('&&').includes(parentStepId));\n\n    subscriberKeys.forEach(key => {\n      if (['success', 'failure', 'skipped'].includes(stepStatus) && this.#isCompoundKey(key)) {\n        this.#compoundDependencies[key]![parentStepId] = true;\n      }\n    });\n\n    const stateUpdateHandler = (startStepId: string, state: any, context: any) => {\n      if (startStepId === 'trigger') {\n        this.#state = state;\n      } else {\n        this.#state = mergeChildValue(startStepId, this.#state, state);\n      }\n\n      const now = Date.now();\n      if (this.#onStepTransition) {\n        this.#onStepTransition.forEach(onTransition => {\n          void onTransition({\n            runId: this.#runId,\n            value: this.#state as Record<string, string>,\n            context: context as WorkflowContext,\n            activePaths: getActivePathsAndStatus(this.#state as Record<string, string>),\n            timestamp: now,\n          });\n        });\n      }\n    };\n\n    const results = await Promise.all(\n      subscriberKeys.map(async key => {\n        if (!this.#stepSubscriberGraph[key] || !this.isCompoundDependencyMet(key)) {\n          return;\n        }\n\n        this.#initializeCompoundDependencies();\n\n        const machine = new Machine({\n          logger: this.logger,\n          mastra: this.#mastra,\n          workflowInstance: this,\n          name: parentStepId === 'trigger' ? this.name : `${this.name}-${parentStepId}`,\n          runId: this.runId,\n          steps: this.#steps,\n          stepGraph: this.#stepSubscriberGraph[key],\n          executionSpan: this.#executionSpan,\n          startStepId: parentStepId,\n        });\n\n        machine.on('state-update', stateUpdateHandler);\n        this.#machines[parentStepId] = machine;\n        return machine.execute({ input });\n      }),\n    );\n\n    return results;\n  }\n\n  async suspend(stepId: string, machine: Machine<TSteps, TTriggerSchema>) {\n    this.#suspendedMachines[stepId] = machine;\n  }\n\n  /**\n   * Persists the workflow state to the database\n   */\n  async persistWorkflowSnapshot(): Promise<void> {\n    const existingSnapshot = (await this.#mastra?.storage?.loadWorkflowSnapshot({\n      workflowName: this.name,\n      runId: this.#runId,\n    })) as WorkflowRunState;\n\n    const machineSnapshots: Record<string, WorkflowRunState> = {};\n    for (const [stepId, machine] of Object.entries(this.#machines)) {\n      const machineSnapshot = machine?.getSnapshot() as unknown as WorkflowRunState;\n      if (machineSnapshot) {\n        machineSnapshots[stepId] = { ...machineSnapshot };\n      }\n    }\n\n    let snapshot = machineSnapshots['trigger'] as unknown as WorkflowRunState;\n    delete machineSnapshots['trigger'];\n\n    const suspendedSteps: Record<string, string> = Object.entries(this.#suspendedMachines).reduce(\n      (acc, [stepId, machine]) => {\n        acc[stepId] = machine.startStepId;\n        return acc;\n      },\n      {} as Record<string, string>,\n    );\n\n    if (!snapshot && existingSnapshot) {\n      existingSnapshot.childStates = { ...existingSnapshot.childStates, ...machineSnapshots };\n      existingSnapshot.suspendedSteps = { ...existingSnapshot.suspendedSteps, ...suspendedSteps };\n      await this.#mastra?.storage?.persistWorkflowSnapshot({\n        workflowName: this.name,\n        runId: this.#runId,\n        snapshot: existingSnapshot,\n      });\n\n      return;\n    } else if (snapshot && !existingSnapshot) {\n      snapshot.suspendedSteps = suspendedSteps;\n      snapshot.childStates = { ...machineSnapshots };\n      await this.#mastra?.storage?.persistWorkflowSnapshot({\n        workflowName: this.name,\n        runId: this.#runId,\n        snapshot,\n      });\n      return;\n    } else if (!snapshot) {\n      this.logger.debug('Snapshot cannot be persisted. No snapshot received.', { runId: this.#runId });\n      return;\n    }\n\n    snapshot.suspendedSteps = { ...existingSnapshot.suspendedSteps, ...suspendedSteps };\n\n    if (!existingSnapshot || snapshot === existingSnapshot) {\n      await this.#mastra?.storage?.persistWorkflowSnapshot({\n        workflowName: this.name,\n        runId: this.#runId,\n        snapshot,\n      });\n\n      return;\n    }\n\n    if (existingSnapshot?.childStates) {\n      snapshot.childStates = { ...existingSnapshot.childStates, ...machineSnapshots };\n    } else {\n      snapshot.childStates = machineSnapshots;\n    }\n\n    await this.#mastra?.storage?.persistWorkflowSnapshot({\n      workflowName: this.name,\n      runId: this.#runId,\n      snapshot,\n    });\n  }\n\n  async getState(): Promise<WorkflowRunState | null> {\n    const storedSnapshot = await this.#mastra?.storage?.loadWorkflowSnapshot({\n      workflowName: this.name,\n      runId: this.runId,\n    });\n    const prevSnapshot: Record<string, WorkflowRunState> = storedSnapshot\n      ? {\n          trigger: storedSnapshot,\n          ...Object.entries(storedSnapshot?.childStates ?? {}).reduce(\n            (acc, [stepId, snapshot]) => ({ ...acc, [stepId]: snapshot as WorkflowRunState }),\n            {},\n          ),\n        }\n      : ({} as Record<string, WorkflowRunState>);\n\n    const currentSnapshot = Object.entries(this.#machines).reduce(\n      (acc, [stepId, machine]) => {\n        const snapshot = machine.getSnapshot();\n        if (!snapshot) {\n          return acc;\n        }\n\n        return {\n          ...acc,\n          [stepId]: snapshot as unknown as WorkflowRunState,\n        };\n      },\n      {} as Record<string, WorkflowRunState>,\n    );\n\n    Object.assign(prevSnapshot, currentSnapshot);\n\n    const trigger = prevSnapshot.trigger as unknown as WorkflowRunState;\n    delete prevSnapshot.trigger;\n    const snapshot = { ...trigger, childStates: prevSnapshot };\n\n    // TODO: really patch the state together here\n    const m = getActivePathsAndStatus(prevSnapshot.value as Record<string, any>);\n    return {\n      runId: this.runId,\n      value: snapshot.value as Record<string, string>,\n      context: snapshot.context,\n      activePaths: m,\n      timestamp: Date.now(),\n    };\n  }\n\n  async resumeWithEvent(eventName: string, data: any) {\n    const event = this.events?.[eventName];\n    if (!event) {\n      throw new Error(`Event ${eventName} not found`);\n    }\n\n    const results = await this.resume({ stepId: `__${eventName}_event`, context: { resumedEvent: data } });\n    return results;\n  }\n\n  async resume({ stepId, context: resumeContext }: { stepId: string; context?: Record<string, any> }) {\n    // NOTE: setTimeout(0) makes sure that if the workflow is still running\n    // we'll wait for any state changes to be applied before resuming\n    await new Promise(resolve => setTimeout(resolve, 0));\n    return this._resume({ stepId, context: resumeContext });\n  }\n\n  async #loadWorkflowSnapshot(runId: string) {\n    if (!this.#mastra?.storage) {\n      this.logger.debug('Snapshot cannot be loaded. Mastra engine is not initialized', { runId });\n      return;\n    }\n\n    await this.persistWorkflowSnapshot();\n\n    return this.#mastra.getStorage()?.loadWorkflowSnapshot({ runId, workflowName: this.name });\n  }\n\n  async _resume({ stepId, context: resumeContext }: { stepId: string; context?: Record<string, any> }) {\n    const snapshot = await this.#loadWorkflowSnapshot(this.runId);\n\n    if (!snapshot) {\n      throw new Error(`No snapshot found for workflow run ${this.runId}`);\n    }\n\n    const stepParts = stepId.split('.');\n    const stepPath = stepParts.join('.');\n    if (stepParts.length > 1) {\n      stepId = stepParts[0] ?? stepId;\n    }\n\n    let parsedSnapshot;\n    try {\n      parsedSnapshot = typeof snapshot === 'string' ? JSON.parse(snapshot as unknown as string) : snapshot;\n    } catch (error) {\n      this.logger.debug('Failed to parse workflow snapshot for resume', { error, runId: this.runId });\n      throw new Error('Failed to parse workflow snapshot');\n    }\n\n    const origSnapshot = parsedSnapshot;\n    const startStepId = parsedSnapshot.suspendedSteps?.[stepId];\n\n    if (!startStepId) {\n      return;\n    }\n    parsedSnapshot =\n      startStepId === 'trigger'\n        ? parsedSnapshot\n        : { ...parsedSnapshot?.childStates?.[startStepId], ...{ suspendedSteps: parsedSnapshot.suspendedSteps } };\n    if (!parsedSnapshot) {\n      throw new Error(`No snapshot found for step: ${stepId} starting at ${startStepId}`);\n    }\n\n    // Update context if provided\n\n    if (resumeContext) {\n      parsedSnapshot.context.steps[stepId] = {\n        status: 'success',\n        output: {\n          ...(parsedSnapshot?.context?.steps?.[stepId]?.output || {}),\n          ...resumeContext,\n        },\n      };\n    }\n\n    // Reattach the step handler\n    // TODO: need types\n    if (parsedSnapshot.children) {\n      Object.entries(parsedSnapshot.children).forEach(([_childId, child]: [string, any]) => {\n        if (child.snapshot?.input?.stepNode) {\n          // Reattach handler\n          const stepDef = this.#makeStepDef(child.snapshot.input.stepNode.step.id);\n          child.snapshot.input.stepNode.config = {\n            ...child.snapshot.input.stepNode.config,\n            ...stepDef,\n          };\n\n          // Sync the context\n          child.snapshot.input.context = parsedSnapshot.context;\n        }\n      });\n    }\n\n    parsedSnapshot.value = updateStepInHierarchy(parsedSnapshot.value, stepId);\n\n    // Reset attempt count\n    if (parsedSnapshot.context?.attempts) {\n      parsedSnapshot.context.attempts[stepId] =\n        this.#steps[stepId]?.retryConfig?.attempts || this.#retryConfig?.attempts || 0;\n    }\n\n    this.logger.debug('Resuming workflow with updated snapshot', {\n      updatedSnapshot: parsedSnapshot,\n      runId: this.runId,\n      stepId,\n    });\n\n    return this.execute({\n      snapshot: parsedSnapshot,\n      stepId: stepPath,\n      resumeData: resumeContext,\n    });\n  }\n\n  #initializeCompoundDependencies() {\n    Object.keys(this.#stepSubscriberGraph).forEach(stepKey => {\n      if (this.#isCompoundKey(stepKey)) {\n        const requiredSteps = stepKey.split('&&');\n        this.#compoundDependencies[stepKey] = requiredSteps.reduce(\n          (acc, step) => {\n            acc[step] = false;\n            return acc;\n          },\n          {} as Record<string, boolean>,\n        );\n      }\n    });\n  }\n\n  #makeStepDef<TStepId extends TSteps[number]['id'], TSteps extends Step<any, any, any>[]>(\n    stepId: TStepId,\n  ): StepDef<TStepId, TSteps, any, any>[TStepId] {\n    const executeStep = (\n      handler: (data: any) => Promise<(data: any) => void>,\n      spanName: string,\n      attributes?: Record<string, string>,\n    ) => {\n      return async (data: any) => {\n        return await otlpContext.with(trace.setSpan(otlpContext.active(), this.#executionSpan as Span), async () => {\n          if (this.#mastra?.getTelemetry()) {\n            return this.#mastra.getTelemetry()?.traceMethod(handler, {\n              spanName,\n              attributes,\n            })(data);\n          } else {\n            return handler(data);\n          }\n        });\n      };\n    };\n\n    // NOTE: destructuring rest breaks some injected runtime fields, like runId\n    // TODO: investigate why that is exactly\n    const handler = async ({ context, ...rest }: ActionContext<TSteps[number]['inputSchema']>) => {\n      const targetStep = this.#steps[stepId];\n      if (!targetStep) throw new Error(`Step not found`);\n\n      const { payload = {}, execute = async () => {} } = targetStep;\n\n      // Merge static payload with dynamically resolved variables\n      // Variables take precedence over payload values\n      const mergedData = {\n        ...(payload as {}),\n        ...context,\n      };\n\n      // Only trace if telemetry is available and action exists\n      const finalAction = this.#mastra?.getTelemetry()\n        ? executeStep(execute, `workflow.${this.name}.action.${stepId}`, {\n            componentName: this.name,\n            runId: rest.runId as string,\n          })\n        : execute;\n\n      return finalAction ? await finalAction({ context: mergedData, ...rest }) : {};\n    };\n\n    // Only trace handler if telemetry is available\n\n    const finalHandler = ({ context, ...rest }: ActionContext<TSteps[number]['inputSchema']>) => {\n      if (this.#executionSpan) {\n        return executeStep(handler, `workflow.${this.name}.step.${stepId}`, {\n          componentName: this.name,\n          runId: rest?.runId as string,\n        })({ context, ...rest });\n      }\n\n      return handler({ context, ...rest });\n    };\n\n    return {\n      handler: finalHandler,\n      data: {},\n    };\n  }\n\n  #isCompoundKey(key: string) {\n    return key.includes('&&');\n  }\n}\n","import type { Span } from '@opentelemetry/api';\nimport { context as otlpContext, trace } from '@opentelemetry/api';\nimport { z } from 'zod';\n\nimport type { MastraPrimitives } from '../action';\nimport { MastraBase } from '../base';\n\nimport type { Mastra } from '../mastra';\nimport { Step } from './step';\nimport type {\n  ActionContext,\n  RetryConfig,\n  StepAction,\n  StepConfig,\n  StepDef,\n  StepGraph,\n  StepNode,\n  StepVariableType,\n  WorkflowOptions,\n  WorkflowRunResult,\n  WorkflowRunState,\n} from './types';\nimport { WhenConditionReturnValue } from './types';\nimport { isVariableReference, isWorkflow, updateStepInHierarchy, workflowToStep } from './utils';\nimport type { WorkflowResultReturn } from './workflow-instance';\nimport { WorkflowInstance } from './workflow-instance';\n\nexport class Workflow<\n  TSteps extends Step<string, any, any>[] = Step<string, any, any>[],\n  TStepId extends string = string,\n  TTriggerSchema extends z.ZodObject<any> = any,\n  TResultSchema extends z.ZodObject<any> = any,\n> extends MastraBase {\n  name: TStepId;\n  triggerSchema?: TTriggerSchema;\n  resultSchema?: TResultSchema;\n  resultMapping?: Record<string, { step: StepAction<string, any, any, any>; path: string }>;\n  events?: Record<string, { schema: z.ZodObject<any> }>;\n  #retryConfig?: RetryConfig;\n  #mastra?: Mastra;\n  #runs: Map<string, WorkflowInstance<TSteps, TTriggerSchema>> = new Map();\n  #isNested: boolean = false;\n  #onStepTransition: Set<(state: WorkflowRunState) => void | Promise<void>> = new Set();\n  // registers stepIds on `after` calls\n  #afterStepStack: string[] = [];\n  #lastStepStack: string[] = [];\n  #ifStack: {\n    condition: StepConfig<any, any, any, TTriggerSchema>['when'];\n    elseStepKey: string;\n    condStep: StepAction<string, any, any, any>;\n  }[] = [];\n  #stepGraph: StepGraph = { initial: [] };\n  #serializedStepGraph: StepGraph = { initial: [] };\n  #stepSubscriberGraph: Record<string, StepGraph> = {};\n  #serializedStepSubscriberGraph: Record<string, StepGraph> = {};\n  #steps: Record<string, StepAction<string, any, any, any>> = {};\n\n  /**\n   * Creates a new Workflow instance\n   * @param name - Identifier for the workflow (not necessarily unique)\n   * @param logger - Optional logger instance\n   */\n  constructor({\n    name,\n    triggerSchema,\n    result,\n    retryConfig,\n    mastra,\n    events,\n  }: WorkflowOptions<TStepId, TSteps, TTriggerSchema, TResultSchema>) {\n    super({ component: 'WORKFLOW', name });\n\n    this.name = name;\n    this.#retryConfig = retryConfig;\n    this.triggerSchema = triggerSchema;\n    this.resultSchema = result?.schema;\n    this.resultMapping = result?.mapping;\n    this.events = events;\n\n    if (mastra) {\n      this.__registerPrimitives({\n        telemetry: mastra.getTelemetry(),\n        logger: mastra.getLogger(),\n      });\n      this.#mastra = mastra;\n    }\n  }\n\n  step<\n    TWorkflow extends Workflow<any, any, any, any>,\n    CondStep extends StepVariableType<any, any, any, any>,\n    VarStep extends StepVariableType<any, any, any, any>,\n    Steps extends StepAction<any, any, any, any>[] = TSteps,\n  >(\n    next: TWorkflow,\n    config?: StepConfig<ReturnType<TWorkflow['toStep']>, CondStep, VarStep, TTriggerSchema, Steps>,\n  ): this;\n  step<\n    TStep extends StepAction<any, any, any, any>,\n    CondStep extends StepVariableType<any, any, any, any>,\n    VarStep extends StepVariableType<any, any, any, any>,\n    Steps extends StepAction<any, any, any, any>[] = TSteps,\n  >(step: TStep, config?: StepConfig<TStep, CondStep, VarStep, TTriggerSchema, Steps>): this;\n  step<\n    TStepLike extends StepAction<string, any, any, any> | Workflow<TSteps, any, any, any>,\n    CondStep extends StepVariableType<any, any, any, any>,\n    VarStep extends StepVariableType<any, any, any, any>,\n    Steps extends StepAction<any, any, any, any>[] = TSteps,\n  >(\n    next: TStepLike extends StepAction<string, any, any, any> ? TStepLike : Workflow<TSteps, any, any, any>,\n    config?: StepConfig<\n      TStepLike extends StepAction<string, any, any, any>\n        ? TStepLike\n        : TStepLike extends Workflow<TSteps, any, any, any>\n          ? ReturnType<TStepLike['toStep']>\n          : never,\n      CondStep,\n      VarStep,\n      TTriggerSchema,\n      Steps\n    >,\n  ): this {\n    if (Array.isArray(next)) {\n      const nextSteps: StepAction<string, any, any, any>[] = next.map(step => {\n        if (isWorkflow(step)) {\n          const asStep = step.toStep();\n          return asStep;\n        } else {\n          return step as StepAction<string, any, any, any>;\n        }\n      });\n      nextSteps.forEach(step => this.step(step, config));\n      this.after(nextSteps);\n      this.step(\n        new Step({\n          id: `__after_${next.map(step => step?.id ?? step?.name).join('_')}`,\n          execute: async ({ context }) => {\n            return { success: true };\n          },\n        }),\n      );\n      return this;\n    }\n\n    const { variables = {} } = config || {};\n\n    const requiredData: Record<string, any> = {};\n\n    // Add valid variables to requiredData\n    for (const [key, variable] of Object.entries(variables)) {\n      if (variable && isVariableReference(variable)) {\n        requiredData[key] = variable;\n      }\n    }\n\n    const step: StepAction<string, any, any, any> = isWorkflow(next)\n      ? // @ts-ignore\n        workflowToStep(next, { mastra: this.#mastra })\n      : (next as StepAction<string, any, any, any>);\n\n    const stepKey = this.#makeStepKey(step);\n    const when = config?.['#internal']?.when || config?.when;\n\n    const graphEntry: StepNode = {\n      step,\n      config: {\n        ...this.#makeStepDef(stepKey),\n        ...config,\n        loopLabel: config?.['#internal']?.loopLabel,\n        loopType: config?.['#internal']?.loopType,\n        serializedWhen: typeof when === 'function' ? when.toString() : when,\n        data: requiredData,\n      },\n    };\n\n    this.#steps[stepKey] = step;\n\n    const parentStepKey = this.#afterStepStack[this.#afterStepStack.length - 1];\n    const stepGraph = this.#stepSubscriberGraph[parentStepKey || ''];\n    const serializedStepGraph = this.#serializedStepSubscriberGraph[parentStepKey || ''];\n\n    // if we are in an after chain and we have a stepGraph\n    if (parentStepKey && stepGraph) {\n      // if the stepGraph has an initial, but it doesn't contain the current step, add it to the initial\n      if (!stepGraph.initial.some(step => step.step.id === stepKey)) {\n        stepGraph.initial.push(graphEntry);\n        if (serializedStepGraph) serializedStepGraph.initial.push(graphEntry);\n      }\n      // add the current step to the stepGraph\n      stepGraph[stepKey] = [];\n      if (serializedStepGraph) serializedStepGraph[stepKey] = [];\n    } else {\n      // Normal step addition to main graph\n      if (!this.#stepGraph[stepKey]) this.#stepGraph[stepKey] = [];\n      this.#stepGraph.initial.push(graphEntry);\n      this.#serializedStepGraph.initial.push(graphEntry);\n    }\n    this.#lastStepStack.push(stepKey);\n\n    return this;\n  }\n\n  #makeStepKey(step: Step<any, any, any> | Workflow<any, any>) {\n    // return `${step.id}${this.#delimiter}${Object.keys(this.steps2).length}`;\n    // @ts-ignore\n    return `${step.id ?? step.name}`;\n  }\n\n  then<\n    TStep extends StepAction<string, any, any, any>,\n    CondStep extends StepVariableType<any, any, any, any>,\n    VarStep extends StepVariableType<any, any, any, any>,\n  >(next: TStep | TStep[], config?: StepConfig<TStep, CondStep, VarStep, TTriggerSchema>): this;\n  then<\n    TWorkflow extends Workflow<any, any, any, any>,\n    CondStep extends StepVariableType<any, any, any, any>,\n    VarStep extends StepVariableType<any, any, any, any>,\n  >(\n    next: TWorkflow | TWorkflow[],\n    config?: StepConfig<StepAction<string, any, any, any>, CondStep, VarStep, TTriggerSchema>,\n  ): this;\n  then<\n    TStep extends StepAction<string, any, any, any> | Workflow<any, any, any, any>,\n    CondStep extends StepVariableType<any, any, any, any>,\n    VarStep extends StepVariableType<any, any, any, any>,\n  >(next: TStep | TStep[], config?: StepConfig<StepAction<string, any, any, any>, CondStep, VarStep, TTriggerSchema>) {\n    if (Array.isArray(next)) {\n      const lastStep = this.#steps[this.#lastStepStack[this.#lastStepStack.length - 1] ?? ''];\n      if (!lastStep) {\n        throw new Error('Condition requires a step to be executed after');\n      }\n\n      this.after(lastStep);\n      const nextSteps = next.map(step => {\n        if (isWorkflow(step)) {\n          return workflowToStep(step, { mastra: this.#mastra });\n        }\n        return step;\n      });\n      // @ts-ignore\n      nextSteps.forEach(step => this.step(step, config));\n      this.step(\n        new Step({\n          // @ts-ignore\n          id: `__after_${next.map(step => step?.id ?? step?.name).join('_')}`,\n          execute: async () => {\n            return { success: true };\n          },\n        }),\n      );\n\n      return this;\n    }\n\n    const { variables = {} } = config || {};\n\n    const requiredData: Record<string, any> = {};\n\n    // Add valid variables to requiredData\n    for (const [key, variable] of Object.entries(variables)) {\n      if (variable && isVariableReference(variable)) {\n        requiredData[key] = variable;\n      }\n    }\n\n    const lastStepKey = this.#lastStepStack[this.#lastStepStack.length - 1];\n\n    const step: StepAction<string, any, any, any> = isWorkflow(next)\n      ? workflowToStep(next, { mastra: this.#mastra })\n      : (next as StepAction<string, any, any, any>);\n\n    const stepKey = this.#makeStepKey(step);\n    const when = config?.['#internal']?.when || config?.when;\n\n    const graphEntry: StepNode = {\n      step,\n      config: {\n        ...this.#makeStepDef(stepKey),\n        ...config,\n        loopLabel: config?.['#internal']?.loopLabel,\n        loopType: config?.['#internal']?.loopType,\n        serializedWhen: typeof when === 'function' ? when.toString() : when,\n        data: requiredData,\n      },\n    };\n\n    this.#steps[stepKey] = step;\n    // if then is called without a step, we are done\n    if (!lastStepKey) return this;\n\n    const parentStepKey = this.#afterStepStack[this.#afterStepStack.length - 1];\n    const stepGraph = this.#stepSubscriberGraph[parentStepKey || ''];\n    const serializedStepGraph = this.#serializedStepSubscriberGraph[parentStepKey || ''];\n\n    if (parentStepKey && stepGraph && stepGraph[lastStepKey]) {\n      stepGraph[lastStepKey].push(graphEntry);\n      if (serializedStepGraph && serializedStepGraph[lastStepKey]) serializedStepGraph[lastStepKey].push(graphEntry);\n    } else {\n      // add the step to the graph if not already there.. it should be there though, unless magic\n      if (!this.#stepGraph[lastStepKey]) this.#stepGraph[lastStepKey] = [];\n      if (!this.#serializedStepGraph[lastStepKey]) this.#serializedStepGraph[lastStepKey] = [];\n\n      // add the step to the graph\n      this.#stepGraph[lastStepKey].push(graphEntry);\n      this.#serializedStepGraph[lastStepKey].push(graphEntry);\n    }\n\n    return this;\n  }\n\n  private loop<\n    FallbackStep extends StepAction<string, any, any, any>,\n    CondStep extends StepVariableType<any, any, any, any>,\n    VarStep extends StepVariableType<any, any, any, any>,\n  >(\n    applyOperator: (op: string, value: any, target: any) => { status: string },\n    condition: StepConfig<FallbackStep, CondStep, VarStep, TTriggerSchema, TSteps>['when'],\n    fallbackStep: FallbackStep,\n    loopType?: 'while' | 'until',\n  ) {\n    const lastStepKey = this.#lastStepStack[this.#lastStepStack.length - 1];\n    // If no last step, we can't do anything\n    if (!lastStepKey) return this;\n\n    const fallbackStepKey = this.#makeStepKey(fallbackStep);\n\n    // Store the fallback step\n    this.#steps[fallbackStepKey] = fallbackStep;\n\n    // Create a check step that evaluates the condition\n    const checkStepKey = `__${fallbackStepKey}_${loopType}_loop_check`;\n    const checkStep = {\n      id: checkStepKey,\n      execute: async ({ context }: any) => {\n        if (typeof condition === 'function') {\n          const result = await condition({ context });\n          if (loopType === 'while') {\n            return { status: result ? 'continue' : 'complete' };\n          } else {\n            return { status: result ? 'complete' : 'continue' };\n          }\n        }\n\n        // For query-based conditions, we need to:\n        // 1. Get the actual value from the reference\n        // 2. Compare it with the query\n        if (condition && 'ref' in condition) {\n          const { ref, query } = condition;\n          // Handle both string IDs and step objects with IDs\n          const stepId = typeof ref.step === 'string' ? ref.step : 'id' in ref.step ? ref.step.id : null;\n          if (!stepId) {\n            return { status: 'continue' }; // If we can't get the step ID, continue looping\n          }\n\n          const stepOutput = context.steps?.[stepId]?.output;\n          if (!stepOutput) {\n            return { status: 'continue' }; // If we can't find the value, continue looping\n          }\n\n          // Get the value at the specified path\n          const value = ref.path.split('.').reduce((obj, key) => obj?.[key], stepOutput);\n\n          // Compare the value with the query\n          const operator = Object.keys(query)[0] as keyof typeof query;\n          const target = query[operator];\n\n          return applyOperator(operator as string, value, target);\n        }\n\n        return { status: 'continue' };\n      },\n      outputSchema: z.object({\n        status: z.enum(['continue', 'complete']),\n      }),\n    };\n    this.#steps[checkStepKey] = checkStep;\n\n    // Loop finished step\n    const loopFinishedStepKey = `__${fallbackStepKey}_${loopType}_loop_finished`;\n    const loopFinishedStep = {\n      id: loopFinishedStepKey,\n      execute: async ({ context }: any) => {\n        return { success: true };\n      },\n    };\n    this.#steps[checkStepKey] = checkStep;\n\n    // First add the check step after the last step\n    this.then(checkStep, {\n      '#internal': {\n        loopLabel: `${fallbackStepKey} ${loopType} loop check`,\n      },\n    });\n\n    // Then create a branch after the check step that loops back to the fallback step\n    this.after(checkStep)\n      .step<FallbackStep, any, any, [typeof checkStep]>(fallbackStep, {\n        when: async ({ context }) => {\n          const checkStepResult = context.steps?.[checkStepKey];\n          if (checkStepResult?.status !== 'success') {\n            return WhenConditionReturnValue.ABORT;\n          }\n\n          const status = checkStepResult?.output?.status;\n          return status === 'continue' ? WhenConditionReturnValue.CONTINUE : WhenConditionReturnValue.CONTINUE_FAILED;\n        },\n        '#internal': {\n          // @ts-ignore\n          when: condition!,\n          loopType: loopType!,\n        },\n      })\n      .then(checkStep, {\n        '#internal': {\n          loopLabel: `${fallbackStepKey} ${loopType} loop check`,\n        },\n      })\n      .step<typeof loopFinishedStep, any, any, [typeof checkStep]>(loopFinishedStep, {\n        when: async ({ context }) => {\n          const checkStepResult = context.steps?.[checkStepKey];\n          if (checkStepResult?.status !== 'success') {\n            return WhenConditionReturnValue.CONTINUE_FAILED;\n          }\n\n          const status = checkStepResult?.output?.status;\n          return status === 'complete' ? WhenConditionReturnValue.CONTINUE : WhenConditionReturnValue.CONTINUE_FAILED;\n        },\n        '#internal': {\n          loopLabel: `${fallbackStepKey} ${loopType} loop finished`,\n          //@ts-ignore\n          loopType,\n        },\n      });\n\n    return this;\n  }\n\n  while<\n    FallbackStep extends StepAction<string, any, any, any>,\n    CondStep extends StepVariableType<any, any, any, any>,\n    VarStep extends StepVariableType<any, any, any, any>,\n  >(condition: StepConfig<FallbackStep, CondStep, VarStep, TTriggerSchema>['when'], fallbackStep: FallbackStep) {\n    const applyOperator = (operator: string, value: any, target: any) => {\n      switch (operator) {\n        case '$eq':\n          return { status: value !== target ? 'complete' : 'continue' };\n        case '$ne':\n          return { status: value === target ? 'complete' : 'continue' };\n        case '$gt':\n          return { status: value <= target ? 'complete' : 'continue' };\n        case '$gte':\n          return { status: value < target ? 'complete' : 'continue' };\n        case '$lt':\n          return { status: value >= target ? 'complete' : 'continue' };\n        case '$lte':\n          return { status: value > target ? 'complete' : 'continue' };\n        default:\n          return { status: 'continue' };\n      }\n    };\n\n    return this.loop(applyOperator, condition, fallbackStep, 'while');\n  }\n\n  until<\n    FallbackStep extends StepAction<string, any, any, any>,\n    CondStep extends StepVariableType<any, any, any, any>,\n    VarStep extends StepVariableType<any, any, any, any>,\n  >(\n    condition: StepConfig<FallbackStep, CondStep, VarStep, TTriggerSchema, TSteps>['when'],\n    fallbackStep: FallbackStep,\n  ) {\n    const applyOperator = (operator: string, value: any, target: any) => {\n      switch (operator) {\n        case '$eq':\n          return { status: value === target ? 'complete' : 'continue' };\n        case '$ne':\n          return { status: value !== target ? 'complete' : 'continue' };\n        case '$gt':\n          return { status: value > target ? 'complete' : 'continue' };\n        case '$gte':\n          return { status: value >= target ? 'complete' : 'continue' };\n        case '$lt':\n          return { status: value < target ? 'complete' : 'continue' };\n        case '$lte':\n          return { status: value <= target ? 'complete' : 'continue' };\n        default:\n          return { status: 'continue' };\n      }\n    };\n\n    return this.loop(applyOperator, condition, fallbackStep, 'until');\n  }\n\n  if<TStep extends StepAction<string, any, any, any>>(\n    condition: StepConfig<TStep, any, any, TTriggerSchema>['when'],\n    ifStep?: TStep | Workflow,\n    elseStep?: TStep | Workflow,\n  ) {\n    const lastStep = this.#steps[this.#lastStepStack[this.#lastStepStack.length - 1] ?? ''];\n    if (!lastStep) {\n      throw new Error('Condition requires a step to be executed after');\n    }\n\n    this.after(lastStep);\n\n    if (ifStep) {\n      const _ifStep = isWorkflow(ifStep) ? workflowToStep(ifStep, { mastra: this.#mastra }) : ifStep;\n\n      this.step(_ifStep, {\n        when: condition,\n      });\n\n      if (elseStep) {\n        const _elseStep = isWorkflow(elseStep) ? workflowToStep(elseStep, { mastra: this.#mastra }) : elseStep;\n        this.step(_elseStep, {\n          when:\n            typeof condition === 'function'\n              ? async payload => {\n                  // @ts-ignore\n                  const result = await condition(payload);\n                  return !result;\n                }\n              : { not: condition },\n        });\n\n        this.after([_ifStep, _elseStep]);\n      } else {\n        this.after(_ifStep);\n      }\n\n      this.step(\n        new Step({\n          id: `${lastStep.id}_if_else`,\n          execute: async () => {\n            return { executed: true };\n          },\n        }),\n      );\n\n      return this;\n    }\n\n    const ifStepKey = `__${lastStep.id}_if`;\n    this.step(\n      {\n        id: ifStepKey,\n        execute: async () => {\n          return { executed: true };\n        },\n      },\n      {\n        when: condition,\n      },\n    );\n\n    const elseStepKey = `__${lastStep.id}_else`;\n    this.#ifStack.push({ condition, elseStepKey, condStep: lastStep });\n\n    return this;\n  }\n\n  else() {\n    const activeCondition = this.#ifStack.pop();\n    if (!activeCondition) {\n      throw new Error('No active condition found');\n    }\n\n    this.after(activeCondition.condStep).step(\n      {\n        id: activeCondition.elseStepKey,\n        execute: async () => {\n          return { executed: true };\n        },\n      },\n      {\n        when:\n          typeof activeCondition.condition === 'function'\n            ? async payload => {\n                // @ts-ignore\n                const result = await activeCondition.condition(payload);\n                return !result;\n              }\n            : { not: activeCondition.condition },\n      },\n    );\n\n    return this;\n  }\n\n  after<TStep extends StepAction<string, any, any, any>>(steps: TStep | TStep[]): Omit<typeof this, 'then' | 'after'>;\n  after<TWorkflow extends Workflow<any, any, any, any>>(\n    steps: TWorkflow | TWorkflow[],\n  ): Omit<typeof this, 'then' | 'after'>;\n  after<TStep extends StepAction<string, any, any, any> | Workflow<any, any, any, any>>(\n    steps: TStep | Workflow | (TStep | Workflow)[],\n  ): Omit<typeof this, 'then' | 'after'> {\n    const stepsArray = Array.isArray(steps) ? steps : [steps];\n    const stepKeys = stepsArray.map(step => this.#makeStepKey(step));\n\n    // Create a compound key for multiple steps\n    const compoundKey = stepKeys.join('&&');\n    this.#afterStepStack.push(compoundKey);\n\n    // Initialize subscriber array for this compound step if it doesn't exist\n    if (!this.#stepSubscriberGraph[compoundKey]) {\n      this.#stepSubscriberGraph[compoundKey] = { initial: [] };\n      this.#serializedStepSubscriberGraph[compoundKey] = { initial: [] };\n    }\n\n    return this as Omit<typeof this, 'then' | 'after'>;\n  }\n\n  afterEvent(eventName: string) {\n    const event = this.events?.[eventName];\n    if (!event) {\n      throw new Error(`Event ${eventName} not found`);\n    }\n\n    const lastStep = this.#steps[this.#lastStepStack[this.#lastStepStack.length - 1] ?? ''];\n    if (!lastStep) {\n      throw new Error('Condition requires a step to be executed after');\n    }\n\n    const eventStepKey = `__${eventName}_event`;\n    const eventStep = new Step({\n      id: eventStepKey,\n      execute: async ({ context, suspend }) => {\n        if (context.inputData?.resumedEvent) {\n          return { executed: true, resumedEvent: context.inputData?.resumedEvent };\n        }\n\n        await suspend();\n        return { executed: false };\n      },\n    });\n\n    this.after(lastStep).step(eventStep).after(eventStep);\n\n    return this;\n  }\n\n  /**\n   * Executes the workflow with the given trigger data\n   * @param triggerData - Initial data to start the workflow with\n   * @returns Promise resolving to workflow results or rejecting with error\n   * @throws Error if trigger schema validation fails\n   */\n\n  createRun({\n    runId,\n    events,\n  }: { runId?: string; events?: Record<string, { schema: z.ZodObject<any> }> } = {}): WorkflowResultReturn<\n    TResultSchema,\n    TTriggerSchema,\n    TSteps\n  > {\n    const run = new WorkflowInstance<TSteps, TTriggerSchema, TResultSchema>({\n      logger: this.logger,\n      name: this.name,\n      mastra: this.#mastra,\n      retryConfig: this.#retryConfig,\n      steps: this.#steps,\n      runId,\n      stepGraph: this.#stepGraph,\n      stepSubscriberGraph: this.#stepSubscriberGraph,\n      onStepTransition: this.#onStepTransition,\n      resultMapping: this.resultMapping,\n      onFinish: () => {\n        this.#runs.delete(run.runId);\n      },\n      events,\n    });\n    this.#runs.set(run.runId, run);\n    return {\n      start: run.start.bind(run) as (\n        props?: { triggerData?: z.infer<TTriggerSchema> } | undefined,\n      ) => Promise<WorkflowRunResult<TTriggerSchema, TSteps, TResultSchema>>,\n      runId: run.runId,\n      watch: run.watch.bind(run),\n      resume: run.resume.bind(run),\n      resumeWithEvent: run.resumeWithEvent.bind(run),\n    };\n  }\n\n  /**\n   * Gets a workflow run instance by ID\n   * @param runId - ID of the run to retrieve\n   * @returns The workflow run instance if found, undefined otherwise\n   */\n  getRun(runId: string) {\n    return this.#runs.get(runId);\n  }\n\n  /**\n   * Rebuilds the machine with the current steps configuration and validates the workflow\n   *\n   * This is the last step of a workflow builder method chain\n   * @throws Error if validation fails\n   *\n   * @returns this instance for method chaining\n   */\n  commit() {\n    return this;\n  }\n\n  // record all object paths that leads to a suspended state\n  #getSuspendedPaths({\n    value,\n    path,\n    suspendedPaths,\n  }: {\n    value: string | Record<string, string>;\n    path: string;\n    suspendedPaths: Set<string>;\n  }) {\n    if (typeof value === 'string') {\n      if (value === 'suspended') {\n        suspendedPaths.add(path);\n      }\n    } else {\n      Object.keys(value).forEach(key =>\n        this.#getSuspendedPaths({ value: value[key]!, path: path ? `${path}.${key}` : key, suspendedPaths }),\n      );\n    }\n  }\n\n  async #loadWorkflowSnapshot(runId: string) {\n    if (!this.#mastra?.storage) {\n      this.logger.debug('Snapshot cannot be loaded. Mastra engine is not initialized', { runId });\n      return;\n    }\n\n    const activeRun = this.#runs.get(runId);\n    if (activeRun) {\n      await activeRun.persistWorkflowSnapshot();\n    }\n    return this.#mastra.storage.loadWorkflowSnapshot({ runId, workflowName: this.name });\n  }\n\n  getExecutionSpan(runId: string) {\n    return this.#runs.get(runId)?.executionSpan;\n  }\n\n  #makeStepDef<TStepId extends TSteps[number]['id'], TSteps extends Step<any, any, any>[]>(\n    stepId: TStepId,\n  ): StepDef<TStepId, TSteps, any, any>[TStepId] {\n    const executeStep = (\n      handler: (data: any) => Promise<(data: any) => void>,\n      spanName: string,\n      attributes?: Record<string, string>,\n    ) => {\n      return async (data: any) => {\n        return await otlpContext.with(\n          trace.setSpan(otlpContext.active(), this.getExecutionSpan(attributes?.runId ?? data?.runId) as Span),\n          async () => {\n            if (this?.telemetry) {\n              return this.telemetry.traceMethod(handler, {\n                spanName,\n                attributes,\n              })(data);\n            } else {\n              return handler(data);\n            }\n          },\n        );\n      };\n    };\n\n    // NOTE: destructuring rest breaks some injected runtime fields, like runId\n    // TODO: investigate why that is exactly\n    const handler = async ({ context, ...rest }: ActionContext<TSteps[number]['inputSchema']>) => {\n      const targetStep = this.#steps[stepId];\n      if (!targetStep) throw new Error(`Step not found`);\n\n      const { payload = {}, execute = async () => {} } = targetStep;\n\n      // Merge static payload with dynamically resolved variables\n      // Variables take precedence over payload values\n\n      // Only trace if telemetry is available and action exists\n      const finalAction = this.telemetry\n        ? executeStep(execute, `workflow.${this.name}.action.${stepId}`, {\n            componentName: this.name,\n            runId: rest.runId as string,\n          })\n        : execute;\n\n      return finalAction\n        ? await finalAction({\n            context: { ...context, inputData: { ...(context?.inputData || {}), ...(payload as {}) } },\n            ...rest,\n          })\n        : {};\n    };\n\n    // Only trace handler if telemetry is available\n\n    const finalHandler = ({ context, ...rest }: ActionContext<TSteps[number]['inputSchema']>) => {\n      if (this.getExecutionSpan(rest?.runId as string)) {\n        return executeStep(handler, `workflow.${this.name}.step.${stepId}`, {\n          componentName: this.name,\n          runId: rest?.runId as string,\n        })({ context, ...rest });\n      }\n\n      return handler({ context, ...rest });\n    };\n\n    return {\n      handler: finalHandler,\n      data: {},\n    };\n  }\n\n  #getActivePathsAndStatus(value: Record<string, any>): Array<{\n    stepPath: string[];\n    stepId: string;\n    status: string;\n  }> {\n    const paths: Array<{\n      stepPath: string[];\n      stepId: string;\n      status: string;\n    }> = [];\n\n    const traverse = (current: Record<string, any>, path: string[] = []) => {\n      for (const [key, value] of Object.entries(current)) {\n        const currentPath = [...path, key];\n\n        if (typeof value === 'string') {\n          // Found a leaf state\n          paths.push({\n            stepPath: currentPath,\n            stepId: key,\n            status: value,\n          });\n        } else if (typeof value === 'object' && value !== null) {\n          // Continue traversing\n          traverse(value, currentPath);\n        }\n      }\n    };\n\n    traverse(value);\n    return paths;\n  }\n\n  async getState(runId: string): Promise<WorkflowRunState | null> {\n    // If this is the currently running workflow\n    const run = this.#runs.get(runId);\n    if (run) {\n      return run.getState();\n    }\n\n    // If workflow is suspended/stored, get from storage\n    const storedSnapshot = await this.#mastra?.storage?.loadWorkflowSnapshot({\n      runId,\n      workflowName: this.name,\n    });\n\n    if (storedSnapshot) {\n      const parsed = storedSnapshot;\n\n      const m = this.#getActivePathsAndStatus(parsed.value);\n\n      return {\n        runId,\n        value: parsed.value,\n        context: parsed.context,\n        activePaths: m,\n        timestamp: Date.now(),\n      };\n    }\n\n    return null;\n  }\n\n  async resume({\n    runId,\n    stepId,\n    context: resumeContext,\n  }: {\n    runId: string;\n    stepId: string;\n    context?: Record<string, any>;\n  }) {\n    this.logger.warn(`Please use 'resume' on the 'createRun' call instead, resume is deprecated`);\n\n    const activeRun = this.#runs.get(runId);\n    if (activeRun) {\n      return activeRun.resume({ stepId, context: resumeContext });\n    }\n\n    const run = this.createRun({ runId });\n    return run.resume({ stepId, context: resumeContext });\n  }\n\n  watch(onTransition: (state: WorkflowRunState) => void): () => void {\n    this.logger.warn(`Please use 'watch' on the 'createRun' call instead, watch is deprecated`);\n    this.#onStepTransition.add(onTransition);\n\n    return () => {\n      this.#onStepTransition.delete(onTransition);\n    };\n  }\n\n  async resumeWithEvent(runId: string, eventName: string, data: any) {\n    this.logger.warn(`Please use 'resumeWithEvent' on the 'createRun' call instead, resumeWithEvent is deprecated`);\n    const event = this.events?.[eventName];\n    if (!event) {\n      throw new Error(`Event ${eventName} not found`);\n    }\n\n    const results = await this.resume({ runId, stepId: `__${eventName}_event`, context: { resumedEvent: data } });\n    return results;\n  }\n\n  __registerMastra(mastra: Mastra) {\n    this.#mastra = mastra;\n  }\n\n  __registerPrimitives(p: MastraPrimitives) {\n    if (p.telemetry) {\n      this.__setTelemetry(p.telemetry);\n    }\n\n    if (p.logger) {\n      this.__setLogger(p.logger);\n    }\n  }\n\n  get stepGraph() {\n    return this.#stepGraph;\n  }\n\n  get stepSubscriberGraph() {\n    return this.#stepSubscriberGraph;\n  }\n\n  get serializedStepGraph() {\n    return this.#serializedStepGraph;\n  }\n\n  get serializedStepSubscriberGraph() {\n    return this.#serializedStepSubscriberGraph;\n  }\n\n  get steps() {\n    return this.#steps;\n  }\n\n  setNested(isNested: boolean) {\n    this.#isNested = isNested;\n  }\n\n  get isNested() {\n    return this.#isNested;\n  }\n\n  toStep(): Step<TStepId, TTriggerSchema, z.ZodType<WorkflowRunResult<TTriggerSchema, TSteps, TResultSchema>>, any> {\n    const x = workflowToStep<TSteps, TStepId, TTriggerSchema, TResultSchema>(this, { mastra: this.#mastra });\n    return new Step(x);\n  }\n}\n"]}