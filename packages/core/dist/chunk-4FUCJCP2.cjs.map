{"version":3,"sources":["../src/hooks/mitt.ts","../src/hooks/index.ts"],"names":["__name","AvailableHooks"],"mappings":";;;;;AAqCe,SAAR,KACL,GACiB,EAAA;AAEjB,EAAM,GAAA,GAAA,GAAA,wBAAW,GAAI,EAAA;AAErB,EAAO,OAAA;AAAA;AAAA;AAAA;AAAA,IAIL,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAQA,EAAA,CAA6B,MAAW,OAA8B,EAAA;AACpE,MAAM,MAAA,QAAA,GAAmD,GAAK,CAAA,GAAA,CAAI,IAAI,CAAA;AACtE,MAAA,IAAI,QAAU,EAAA;AACZ,QAAA,QAAA,CAAS,KAAK,OAAO,CAAA;AAAA,OAChB,MAAA;AACL,QAAA,GAAA,CAAK,GAAI,CAAA,IAAA,EAAM,CAAC,OAAO,CAA2C,CAAA;AAAA;AACpE,KACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IASA,GAAA,CAA8B,MAAW,OAA+B,EAAA;AACtE,MAAM,MAAA,QAAA,GAAmD,GAAK,CAAA,GAAA,CAAI,IAAI,CAAA;AACtE,MAAA,IAAI,QAAU,EAAA;AACZ,QAAA,IAAI,OAAS,EAAA;AACX,UAAA,QAAA,CAAS,OAAO,QAAS,CAAA,OAAA,CAAQ,OAAO,CAAA,KAAM,GAAG,CAAC,CAAA;AAAA,SAC7C,MAAA;AACL,UAAK,GAAA,CAAA,GAAA,CAAI,IAAM,EAAA,EAAE,CAAA;AAAA;AACnB;AACF,KACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAYA,IAAA,CAA+B,MAAW,GAAmB,EAAA;AAC3D,MAAI,IAAA,QAAA,GAAW,GAAK,CAAA,GAAA,CAAI,IAAI,CAAA;AAC5B,MAAA,IAAI,QAAU,EAAA;AACZ,QAAC,QAAoD,CAAA,KAAA,EAAQ,CAAA,GAAA,CAAI,CAAW,OAAA,KAAA;AAC1E,UAAA,OAAA,CAAQ,GAAI,CAAA;AAAA,SACb,CAAA;AAAA;AAGH,MAAW,QAAA,GAAA,GAAA,CAAK,IAAI,GAAG,CAAA;AACvB,MAAA,IAAI,QAAU,EAAA;AACZ,QAAC,QAA8C,CAAA,KAAA,EAAQ,CAAA,GAAA,CAAI,CAAW,OAAA,KAAA;AACpE,UAAA,OAAA,CAAQ,MAAM,GAAI,CAAA;AAAA,SACnB,CAAA;AAAA;AACH;AACF,GACF;AACF;AAvEwBA,wBAAA,CAAA,IAAA,EAAA,MAAA,CAAA;;;AC/BZ,IAAA,cAAA,qBAAAC,eAAL,KAAA;AACL,EAAAA,gBAAA,eAAgB,CAAA,GAAA,cAAA;AAChB,EAAAA,gBAAA,eAAgB,CAAA,GAAA,cAAA;AAFN,EAAAA,OAAAA,eAAAA;AAAA,CAAA,EAAA,cAAA,IAAA,EAAA;AAKZ,IAAM,QAAQ,IAAK,EAAA;AAyBZ,SAAS,YAAA,CAAa,MAA2B,MAA4B,EAAA;AAClF,EAAM,KAAA,CAAA,EAAA,CAAG,MAAM,MAAM,CAAA;AACvB;AAFgBD,wBAAA,CAAA,YAAA,EAAA,cAAA,CAAA;AAOT,SAAS,WAAA,CAAY,MAA2B,IAAqB,EAAA;AAE1E,EAAA,YAAA,CAAa,MAAM;AACjB,IAAM,KAAA,CAAA,IAAA,CAAK,MAAM,IAAI,CAAA;AAAA,GACtB,CAAA;AACH;AALgBA,wBAAA,CAAA,WAAA,EAAA,aAAA,CAAA","file":"chunk-4FUCJCP2.cjs","sourcesContent":["// copied from https://github.com/developit/mitt\n\nexport type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = unknown> = (event: T) => void;\nexport type WildcardHandler<T = Record<string, unknown>> = (type: keyof T, event: T[keyof T]) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList<T = unknown> = Array<Handler<T>>;\nexport type WildCardEventHandlerList<T = Record<string, unknown>> = Array<WildcardHandler<T>>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap<Events extends Record<EventType, unknown>> = Map<\n  keyof Events | '*',\n  EventHandlerList<Events[keyof Events]> | WildCardEventHandlerList<Events>\n>;\n\nexport interface Emitter<Events extends Record<EventType, unknown>> {\n  all: EventHandlerMap<Events>;\n\n  on<Key extends keyof Events>(type: Key, handler: Handler<Events[Key]>): void;\n  on(type: '*', handler: WildcardHandler<Events>): void;\n\n  off<Key extends keyof Events>(type: Key, handler?: Handler<Events[Key]>): void;\n  off(type: '*', handler: WildcardHandler<Events>): void;\n\n  emit<Key extends keyof Events>(type: Key, event: Events[Key]): void;\n  emit<Key extends keyof Events>(type: undefined extends Events[Key] ? Key : never): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt<Events extends Record<EventType, unknown>>(\n  all?: EventHandlerMap<Events>,\n): Emitter<Events> {\n  type GenericEventHandler = Handler<Events[keyof Events]> | WildcardHandler<Events>;\n  all = all || new Map();\n\n  return {\n    /**\n     * A Map of event names to registered handler functions.\n     */\n    all,\n\n    /**\n     * Register an event handler for the given type.\n     * @param {string|symbol} type Type of event to listen for, or `'*'` for all events\n     * @param {Function} handler Function to call in response to given event\n     * @memberOf mitt\n     */\n    on<Key extends keyof Events>(type: Key, handler: GenericEventHandler) {\n      const handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n      if (handlers) {\n        handlers.push(handler);\n      } else {\n        all!.set(type, [handler] as EventHandlerList<Events[keyof Events]>);\n      }\n    },\n\n    /**\n     * Remove an event handler for the given type.\n     * If `handler` is omitted, all handlers of the given type are removed.\n     * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)\n     * @param {Function} [handler] Handler function to remove\n     * @memberOf mitt\n     */\n    off<Key extends keyof Events>(type: Key, handler?: GenericEventHandler) {\n      const handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n      if (handlers) {\n        if (handler) {\n          handlers.splice(handlers.indexOf(handler) >>> 0, 1);\n        } else {\n          all!.set(type, []);\n        }\n      }\n    },\n\n    /**\n     * Invoke all handlers for the given type.\n     * If present, `'*'` handlers are invoked after type-matched handlers.\n     *\n     * Note: Manually firing '*' handlers is not supported.\n     *\n     * @param {string|symbol} type The event type to invoke\n     * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n     * @memberOf mitt\n     */\n    emit<Key extends keyof Events>(type: Key, evt?: Events[Key]) {\n      let handlers = all!.get(type);\n      if (handlers) {\n        (handlers as EventHandlerList<Events[keyof Events]>).slice().map(handler => {\n          handler(evt!);\n        });\n      }\n\n      handlers = all!.get('*');\n      if (handlers) {\n        (handlers as WildCardEventHandlerList<Events>).slice().map(handler => {\n          handler(type, evt!);\n        });\n      }\n    },\n  };\n}\n","import type { Metric, MetricResult } from '../eval/metric';\nimport type { TestInfo } from '../eval/types';\n\nimport mitt from './mitt';\nimport type { Handler } from './mitt';\n\nexport enum AvailableHooks {\n  ON_EVALUATION = 'onEvaluation',\n  ON_GENERATION = 'onGeneration',\n}\n\nconst hooks = mitt();\n\ntype EvaluationHookData = {\n  input: string;\n  output: string;\n  result: MetricResult;\n  agentName: string;\n  metricName: string;\n  instructions: string;\n  runId: string;\n  globalRunId: string;\n  testInfo?: TestInfo;\n};\n\ntype GenerationHookData = {\n  input: string;\n  output: string;\n  metric: Metric;\n  runId: string;\n  agentName: string;\n  instructions: string;\n};\n\nexport function registerHook(hook: AvailableHooks.ON_EVALUATION, action: Handler<EvaluationHookData>): void;\nexport function registerHook(hook: AvailableHooks.ON_GENERATION, action: Handler<GenerationHookData>): void;\nexport function registerHook(hook: `${AvailableHooks}`, action: Handler<any>): void {\n  hooks.on(hook, action);\n}\n\nexport function executeHook(hook: AvailableHooks.ON_EVALUATION, action: EvaluationHookData): void;\nexport function executeHook(hook: AvailableHooks.ON_GENERATION, action: GenerationHookData): void;\n\nexport function executeHook(hook: `${AvailableHooks}`, data: unknown): void {\n  // do not block the main thread\n  setImmediate(() => {\n    hooks.emit(hook, data);\n  });\n}\n"]}