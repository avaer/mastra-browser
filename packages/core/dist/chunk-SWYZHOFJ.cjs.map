{"version":3,"sources":["../src/vector/vector.ts"],"names":["MastraBase","__publicField","__name"],"mappings":";;;;;;AAaO,IAAe,aAAA,GAAf,MAAe,aAAA,SAAqBA,4BAAW,CAAA;AAAA,EACpD,WAAc,GAAA;AACZ,IAAA,KAAA,CAAM,EAAE,IAAA,EAAM,cAAgB,EAAA,SAAA,EAAW,UAAU,CAAA;AAGrD,IAAAC,+BAAA,CAAA,IAAA,EAAiB,UAAW,EAAA;AAAA,MAC1B,KAAO,EAAA,CAAC,aAAe,EAAA,MAAA,EAAQ,UAAU,eAAe,CAAA;AAAA,MACxD,MAAQ,EAAA,CAAC,SAAW,EAAA,UAAA,EAAY,KAAK,CAAA;AAAA,MACrC,WAAA,EAAa,CAAC,WAAA,EAAa,QAAQ;AAAA,KACrC,CAAA;AAAA;AANA,EAQU,aAAA,CACR,QACA,CAAC,KAAA,EAAO,GAAG,IAAI,CAAA,EACf,YAAyB,GAAA,EACtB,EAAA;AACH,IAAI,IAAA,OAAO,UAAU,QAAU,EAAA;AAC7B,MAAO,OAAA,KAAA;AAAA;AAGT,IAAA,IAAA,CAAK,MAAO,CAAA,IAAA;AAAA,MACV,wDAAwD,MAAM,CAAA,yDAAA;AAAA,KAEhE;AAEA,IAAA,MAAM,QAAW,GAAA,IAAA,CAAK,QAAS,CAAA,MAAoC,KAAK,EAAC;AACzE,IAAM,MAAA,SAAA,GAAY,CAAC,GAAG,QAAU,EAAA,GAAG,YAAY,CAAE,CAAA,KAAA,CAAM,CAAG,EAAA,IAAA,CAAK,MAAM,CAAA;AAErE,IAAO,OAAA;AAAA,MACL,SAAW,EAAA,KAAA;AAAA,MACX,GAAG,MAAA,CAAO,WAAY,CAAA,SAAA,CAAU,IAAI,CAAC,GAAA,EAAK,CAAM,KAAA,CAAC,GAAK,EAAA,IAAA,CAAK,CAAC,CAAC,CAAC,CAAC;AAAA,KACjE;AAAA;AACF,EAoBA,MAAM,eAAA,CACJ,UACA,EAAA,GAAA,EACA,OACe,EAAA;AACf,IAAM,MAAA,IAAI,MAAM,wCAAwC,CAAA;AAAA;AAC1D,EACA,MAAM,eAAgB,CAAA,UAAA,EAAoB,GAA4B,EAAA;AACpE,IAAM,MAAA,IAAI,MAAM,mCAAmC,CAAA;AAAA;AAEvD,CAAA;AA9DsDC,wBAAA,CAAA,aAAA,EAAA,cAAA,CAAA;AAA/C,IAAe,YAAf,GAAA","file":"chunk-SWYZHOFJ.cjs","sourcesContent":["import { MastraBase } from '../base';\nimport type {\n  CreateIndexParams,\n  UpsertVectorParams,\n  QueryVectorParams,\n  IndexStats,\n  ParamsToArgs,\n  QueryResult,\n  CreateIndexArgs,\n  UpsertVectorArgs,\n  QueryVectorArgs,\n} from './types';\n\nexport abstract class MastraVector extends MastraBase {\n  constructor() {\n    super({ name: 'MastraVector', component: 'VECTOR' });\n  }\n\n  private readonly baseKeys = {\n    query: ['queryVector', 'topK', 'filter', 'includeVector'],\n    upsert: ['vectors', 'metadata', 'ids'],\n    createIndex: ['dimension', 'metric'],\n  } as const;\n\n  protected normalizeArgs<T, E extends any[] = never>(\n    method: string,\n    [first, ...rest]: ParamsToArgs<T> | E,\n    extendedKeys: string[] = [],\n  ): T {\n    if (typeof first === 'object') {\n      return first as T;\n    }\n\n    this.logger.warn(\n      `Deprecation Warning: Passing individual arguments to ${method}() is deprecated. ` +\n        'Please use an object parameter instead.',\n    );\n\n    const baseKeys = this.baseKeys[method as keyof typeof this.baseKeys] || [];\n    const paramKeys = [...baseKeys, ...extendedKeys].slice(0, rest.length);\n\n    return {\n      indexName: first as string,\n      ...Object.fromEntries(paramKeys.map((key, i) => [key, rest[i]])),\n    } as T;\n  }\n  // Adds type checks for positional arguments if used\n  abstract query<E extends QueryVectorArgs = QueryVectorArgs>(\n    ...args: ParamsToArgs<QueryVectorParams> | E\n  ): Promise<QueryResult[]>;\n  // Adds type checks for positional arguments if used\n  abstract upsert<E extends UpsertVectorArgs = UpsertVectorArgs>(\n    ...args: ParamsToArgs<UpsertVectorParams> | E\n  ): Promise<string[]>;\n  // Adds type checks for positional arguments if used\n  abstract createIndex<E extends CreateIndexArgs = CreateIndexArgs>(\n    ...args: ParamsToArgs<CreateIndexParams> | E\n  ): Promise<void>;\n\n  abstract listIndexes(): Promise<string[]>;\n\n  abstract describeIndex(indexName: string): Promise<IndexStats>;\n\n  abstract deleteIndex(indexName: string): Promise<void>;\n\n  async updateIndexById(\n    _indexName: string,\n    _id: string,\n    _update: { vector?: number[]; metadata?: Record<string, any> },\n  ): Promise<void> {\n    throw new Error('updateIndexById is not implemented yet');\n  }\n  async deleteIndexById(_indexName: string, _id: string): Promise<void> {\n    throw new Error('deleteById is not implemented yet');\n  }\n}\n"]}