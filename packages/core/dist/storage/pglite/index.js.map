{"version":3,"sources":["../../../src/storage/pglite/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import { join, resolve, isAbsolute } from 'path';\nimport { PGlite } from '@electric-sql/pglite';\nimport { MemoryFS } from '@electric-sql/pglite';\n\nimport type { MetricResult, TestInfo } from '../../eval';\nimport type { MessageType, StorageThreadType } from '../../memory/types';\nimport { MastraStorage } from '../base';\nimport { TABLE_EVALS, TABLE_MESSAGES, TABLE_THREADS, TABLE_TRACES, TABLE_WORKFLOW_SNAPSHOT } from '../constants';\nimport type { TABLE_NAMES } from '../constants';\nimport type { StorageColumn, StorageGetMessagesArg, EvalRow } from '../types';\n\nfunction safelyParseJSON(jsonString: string): any {\n  try {\n    return JSON.parse(jsonString);\n  } catch {\n    return {};\n  }\n}\n\nexport interface PGliteConfig {\n  url: string;\n  authToken?: string;\n}\n\ninterface ThreadRow {\n  id: string;\n  resourceId: string;\n  title: string;\n  createdAt: string;\n  updatedAt: string;\n  metadata: string | Record<string, unknown>;\n}\n\ninterface TraceRow {\n  id: string;\n  parentSpanId: string;\n  traceId: string;\n  name: string;\n  scope: string;\n  kind: string;\n  status: string;\n  events: string;\n  links: string;\n  attributes: string;\n  startTime: string | number;  // Could be stored as number (bigint)\n  endTime: string | number;  // Could be stored as number (bigint)\n  other: string;\n  createdAt: string;\n}\n\nexport class PGliteStore extends MastraStorage {\n  private client: PGlite | null = null;\n  private clientPromise: Promise<PGlite> | null = null;\n\n  constructor({ config }: { config: PGliteConfig }) {\n    super({ name: `PGliteStore` });\n\n    // need to re-init every time for in memory dbs or the tables might not exist\n    if (config.url === ':memory:' || config.url.startsWith('file::memory:')) {\n      this.shouldCacheInit = false;\n    }\n\n    this.clientPromise = this.initClient(config);\n  }\n\n  private async initClient(config: PGliteConfig): Promise<PGlite> {\n    const url = this.rewriteDbUrl(config.url);\n    this.logger.debug(`Initializing PGlite with URL: ${url}`);\n    \n    try {\n      // interface PGliteOptions<TExtensions extends Extensions = Extensions> {\n      //   dataDir?: string;\n      //   username?: string;\n      //   database?: string;\n      //   fs?: Filesystem;\n      //   debug?: DebugLevel;\n      //   relaxedDurability?: boolean;\n      //   extensions?: TExtensions;\n      //   loadDataDir?: Blob | File;\n      //   initialMemory?: number;\n      //   wasmModule?: WebAssembly.Module;\n      //   fsBundle?: Blob | File;\n      //   parsers?: ParserOptions;\n      //   serializers?: SerializerOptions;\n      // }\n      const client = await PGlite.create(url, {\n        fs: new MemoryFS(),\n      });\n      this.client = client;\n      return client;\n    } catch (error) {\n      this.logger.error(`Error initializing PGlite client: ${error}`);\n      throw error;\n    }\n  }\n\n  private async getClient(): Promise<PGlite> {\n    if (!this.client && this.clientPromise) {\n      this.client = await this.clientPromise;\n    }\n    if (!this.client) {\n      throw new Error('PGlite client not initialized');\n    }\n    return this.client;\n  }\n\n  // Rewrite DB URL to match the LibSQLStore logic for consistent file paths\n  protected rewriteDbUrl(url: string): string {\n    if (url.startsWith('file:') && url !== 'file::memory:') {\n      const pathPart = url.slice('file:'.length);\n\n      if (isAbsolute(pathPart)) {\n        return url;\n      }\n\n      const cwd = process.cwd();\n\n      if (cwd.includes('.mastra') && (cwd.endsWith(`output`) || cwd.endsWith(`output/`) || cwd.endsWith(`output\\\\`))) {\n        const baseDir = join(cwd, `..`, `..`); // <- .mastra/output/../../\n\n        const fullPath = resolve(baseDir, pathPart);\n\n        this.logger.debug(\n          `Initializing PGlite db with url ${url} with relative file path from inside .mastra/output directory. Rewriting relative file url to \"file:${fullPath}\". This ensures it's outside the .mastra/output directory.`,\n        );\n\n        return `file:${fullPath}`;\n      }\n    }\n\n    return url;\n  }\n\n  private getCreateTableSQL(tableName: TABLE_NAMES, schema: Record<string, StorageColumn>): string {\n    const columns = Object.entries(schema).map(([name, col]) => {\n      let type = col.type.toUpperCase();\n      if (type === 'TEXT') type = 'TEXT';\n      if (type === 'TIMESTAMP') type = 'TEXT'; // Store timestamps as ISO strings\n      // Match LibSQL type handling\n      if (type === 'JSONB') type = 'JSONB';\n      if (type === 'BIGINT') type = 'BIGINT';\n      if (type === 'INTEGER') type = 'INTEGER';\n\n      const nullable = col.nullable ? '' : 'NOT NULL';\n      const primaryKey = col.primaryKey ? 'PRIMARY KEY' : '';\n\n      return `\"${name}\" ${type} ${nullable} ${primaryKey}`.trim();\n    });\n\n    // For workflow_snapshot table, create a composite primary key\n    if (tableName === TABLE_WORKFLOW_SNAPSHOT) {\n      const stmnt = `CREATE TABLE IF NOT EXISTS ${tableName} (\n                ${columns.join(',\\n')},\n                PRIMARY KEY (workflow_name, run_id)\n            )`;\n      return stmnt;\n    }\n\n    return `CREATE TABLE IF NOT EXISTS ${tableName} (${columns.join(', ')})`;\n  }\n\n  async createTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n  }): Promise<void> {\n    try {\n      this.logger.debug(`Creating database table`, { tableName, operation: 'schema init' });\n      const sql = this.getCreateTableSQL(tableName, schema);\n      const client = await this.getClient();\n      await client.exec(sql);\n    } catch (error) {\n      this.logger.error(`Error creating table ${tableName}: ${error}`);\n      throw error;\n    }\n  }\n\n  async clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    try {\n      const client = await this.getClient();\n      await client.exec(`DELETE FROM ${tableName}`);\n    } catch (e) {\n      if (e instanceof Error) {\n        this.logger.error(e.message);\n      }\n    }\n  }\n\n  private prepareParams(record: Record<string, any>): Record<string, any> {\n    return Object.fromEntries(\n      Object.entries(record).map(([k, v]) => {\n        if (typeof v === `undefined`) {\n          // Return null for undefined values\n          return [k, null];\n        }\n        if (v instanceof Date) {\n          return [k, v.toISOString()];\n        }\n        if (typeof v === 'object') {\n          return [k, JSON.stringify(v)];\n        }\n        return [k, v];\n      })\n    );\n  }\n\n  async insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void> {\n    try {\n      const client = await this.getClient();\n      const columns = Object.keys(record);\n      const placeholders = columns.map((_, i) => `$${i + 1}`).join(', ');\n      const params = this.prepareParams(record);\n      const values = Object.values(params);\n\n      // Quote all column names to preserve case\n      const quotedColumns = columns.map(col => `\"${col}\"`);\n      \n      await client.query(\n        `INSERT INTO ${tableName} (${quotedColumns.join(', ')}) VALUES (${placeholders}) \n         ON CONFLICT (${this.getPrimaryKeys(tableName)}) DO UPDATE SET \n         ${columns.map((col, i) => `\"${col}\" = $${i + 1}`).join(', ')}`,\n        values\n      );\n    } catch (error) {\n      this.logger.error(`Error upserting into table ${tableName}: ${error}`);\n      throw error;\n    }\n  }\n\n  // Helper to get primary keys for upsert operation\n  private getPrimaryKeys(tableName: TABLE_NAMES): string {\n    switch (tableName) {\n      case TABLE_THREADS:\n      case TABLE_MESSAGES:\n      case TABLE_TRACES:\n        return '\"id\"';\n      case TABLE_WORKFLOW_SNAPSHOT:\n        return '\"workflow_name\", \"run_id\"';\n      default:\n        return '\"id\"'; // Default to 'id' for other tables\n    }\n  }\n\n  async batchInsert({ tableName, records }: { tableName: TABLE_NAMES; records: Record<string, any>[] }): Promise<void> {\n    if (records.length === 0) return;\n\n    try {\n      const client = await this.getClient();\n      \n      // Use a transaction for the batch insert\n      await client.transaction(async (tx) => {\n        for (const record of records) {\n          const columns = Object.keys(record);\n          const placeholders = columns.map((_, i) => `$${i + 1}`).join(', ');\n          const params = this.prepareParams(record);\n          const values = Object.values(params);\n          \n          // Quote all column names to preserve case\n          const quotedColumns = columns.map(col => `\"${col}\"`);\n\n          await tx.query(\n            `INSERT INTO ${tableName} (${quotedColumns.join(', ')}) VALUES (${placeholders}) \n             ON CONFLICT (${this.getPrimaryKeys(tableName)}) DO UPDATE SET \n             ${columns.map((col, i) => `\"${col}\" = $${i + 1}`).join(', ')}`,\n            values\n          );\n        }\n      });\n    } catch (error) {\n      this.logger.error(`Error batch upserting into table ${tableName}: ${error}`);\n      throw error;\n    }\n  }\n\n  async load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, string> }): Promise<R | null> {\n    const conditions = Object.keys(keys).map((key, i) => `\"${key}\" = $${i + 1}`).join(' AND ');\n    const values = Object.values(keys);\n\n    const client = await this.getClient();\n    try {\n      const result = await client.query(\n        `SELECT * FROM ${tableName} WHERE ${conditions} ORDER BY \"createdAt\" DESC LIMIT 1`,\n        values\n      );\n\n      if (!result.rows || result.rows.length === 0) {\n        return null;\n      }\n\n      const row = result.rows[0];\n      // Parse JSON strings in the result\n      const parsed = Object.fromEntries(\n        Object.entries(row || {}).map(([k, v]) => {\n          try {\n            return [k, typeof v === 'string' ? (v.startsWith('{') || v.startsWith('[') ? JSON.parse(v) : v) : v];\n          } catch {\n            return [k, v];\n          }\n        }),\n      );\n\n      return parsed as R;\n    } catch (error) {\n      this.logger.error(`Error querying table ${tableName}: ${error}`);\n      throw error;\n    }\n  }\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    const result = await this.load<ThreadRow>({\n      tableName: TABLE_THREADS,\n      keys: { id: threadId },\n    });\n\n    if (!result) {\n      return null;\n    }\n\n    return {\n      ...result,\n      createdAt: typeof result.createdAt === 'string' ? new Date(result.createdAt) : result.createdAt,\n      updatedAt: typeof result.updatedAt === 'string' ? new Date(result.updatedAt) : result.updatedAt,\n      metadata: typeof result.metadata === 'string' ? JSON.parse(result.metadata) : result.metadata,\n    } as StorageThreadType;\n  }\n\n  async getThreadsByResourceId({ resourceId }: { resourceId: string }): Promise<StorageThreadType[]> {\n    const client = await this.getClient();\n    const result = await client.query<ThreadRow>(\n      `SELECT * FROM ${TABLE_THREADS} WHERE \"resourceId\" = $1`,\n      [resourceId]\n    );\n\n    return (result.rows ?? []).map(thread => ({\n      id: thread.id,\n      resourceId: thread.resourceId,\n      title: thread.title,\n      createdAt: typeof thread.createdAt === 'string' ? new Date(thread.createdAt) : thread.createdAt,\n      updatedAt: typeof thread.updatedAt === 'string' ? new Date(thread.updatedAt) : thread.updatedAt,\n      metadata: typeof thread.metadata === 'string' ? JSON.parse(thread.metadata) : thread.metadata,\n    })) as StorageThreadType[];\n  }\n\n  async saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType> {\n    await this.insert({\n      tableName: TABLE_THREADS,\n      record: {\n        ...thread,\n        metadata: JSON.stringify(thread.metadata),\n      },\n    });\n\n    return thread;\n  }\n\n  async updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType> {\n    const thread = await this.getThreadById({ threadId: id });\n    if (!thread) {\n      throw new Error(`Thread ${id} not found`);\n    }\n\n    const updatedThread = {\n      ...thread,\n      title,\n      metadata: {\n        ...thread.metadata,\n        ...metadata,\n      },\n    };\n\n    const client = await this.getClient();\n    await client.query(\n      `UPDATE ${TABLE_THREADS} SET title = $1, metadata = $2 WHERE id = $3`,\n      [title, JSON.stringify(updatedThread.metadata), id]\n    );\n\n    return updatedThread;\n  }\n\n  async deleteThread({ threadId }: { threadId: string }): Promise<void> {\n    const client = await this.getClient();\n    await client.query(\n      `DELETE FROM ${TABLE_THREADS} WHERE id = $1`,\n      [threadId]\n    );\n    // Messages will need to be deleted separately since PGlite might not support CASCADE\n    await client.query(\n      `DELETE FROM ${TABLE_MESSAGES} WHERE thread_id = $1`,\n      [threadId]\n    );\n  }\n\n  private parseRow(row: any): MessageType {\n    let content = row.content;\n    try {\n      content = JSON.parse(row.content);\n    } catch {\n      // use content as is if it's not JSON\n    }\n    return {\n      id: row.id,\n      content,\n      role: row.role,\n      type: row.type,\n      createdAt: new Date(row.createdAt as string),\n      threadId: row.thread_id,\n    } as MessageType;\n  }\n\n  async getMessages<T extends MessageType[]>({ threadId, selectBy }: StorageGetMessagesArg): Promise<T> {\n    try {\n      const client = await this.getClient();\n      const messages: MessageType[] = [];\n      const limit = typeof selectBy?.last === `number` ? selectBy.last : 40;\n\n      // If we have specific messages to select\n      if (selectBy?.include?.length) {\n        const includeIds = selectBy.include.map(i => i.id);\n        const maxPrev = Math.max(...selectBy.include.map(i => i.withPreviousMessages || 0));\n        const maxNext = Math.max(...selectBy.include.map(i => i.withNextMessages || 0));\n\n        // Get messages around all specified IDs using a window function\n        const includeResult = await client.query(\n          `\n          WITH numbered_messages AS (\n            SELECT \n              id,\n              content,\n              role,\n              type,\n              \"createdAt\",\n              thread_id,\n              ROW_NUMBER() OVER (ORDER BY \"createdAt\" ASC) as row_num\n            FROM \"${TABLE_MESSAGES}\"\n            WHERE thread_id = $1\n          ),\n          target_positions AS (\n            SELECT row_num as target_pos\n            FROM numbered_messages\n            WHERE id IN (${includeIds.map((_, i) => `$${i + 2}`).join(', ')})\n          )\n          SELECT DISTINCT m.*\n          FROM numbered_messages m\n          CROSS JOIN target_positions t\n          WHERE m.row_num BETWEEN (t.target_pos - $${includeIds.length + 2}) AND (t.target_pos + $${includeIds.length + 3})\n          ORDER BY m.\"createdAt\" ASC\n          `,\n          [threadId, ...includeIds, maxPrev, maxNext]\n        );\n\n        if (includeResult.rows && includeResult.rows.length > 0) {\n          messages.push(...includeResult.rows.map((row: any) => this.parseRow(row)));\n        }\n      }\n\n      // Get remaining messages, excluding already fetched IDs\n      const excludeIds = messages.map(m => m.id);\n      \n      let remainingSql;\n      let remainingArgs;\n      \n      if (excludeIds.length) {\n        remainingSql = `\n          SELECT \n            id, \n            content, \n            role, \n            type,\n            \"createdAt\", \n            thread_id\n          FROM \"${TABLE_MESSAGES}\"\n          WHERE thread_id = $1\n          AND id NOT IN (${excludeIds.map((_, i) => `$${i + 2}`).join(', ')})\n          ORDER BY \"createdAt\" DESC\n          LIMIT $${excludeIds.length + 2}\n        `;\n        remainingArgs = [threadId, ...excludeIds, limit];\n      } else {\n        remainingSql = `\n          SELECT \n            id, \n            content, \n            role, \n            type,\n            \"createdAt\", \n            thread_id\n          FROM \"${TABLE_MESSAGES}\"\n          WHERE thread_id = $1\n          ORDER BY \"createdAt\" DESC\n          LIMIT $2\n        `;\n        remainingArgs = [threadId, limit];\n      }\n\n      const remainingResult = await client.query(remainingSql, remainingArgs);\n      \n      if (remainingResult.rows && remainingResult.rows.length > 0) {\n        messages.push(...remainingResult.rows.map((row: any) => this.parseRow(row)));\n      }\n\n      // Sort all messages by creation date\n      messages.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n\n      return messages as T;\n    } catch (error) {\n      this.logger.error('Error getting messages:', error as Error);\n      throw error;\n    }\n  }\n\n  async saveMessages({ messages }: { messages: MessageType[] }): Promise<MessageType[]> {\n    if (messages.length === 0) return messages;\n\n    const client = await this.getClient();\n    try {\n      const threadId = messages[0]?.threadId;\n      if (!threadId) {\n        throw new Error('Thread ID is required');\n      }\n\n      await client.transaction(async (tx) => {\n        for (const message of messages) {\n          const time = message.createdAt || new Date();\n          await tx.query(\n            `INSERT INTO ${TABLE_MESSAGES} (id, thread_id, content, role, type, \"createdAt\") \n              VALUES ($1, $2, $3, $4, $5, $6)\n              ON CONFLICT (id) DO UPDATE SET\n              content = $3, role = $4, type = $5, \"createdAt\" = $6`,\n            [\n              message.id,\n              threadId,\n              typeof message.content === 'object' ? JSON.stringify(message.content) : message.content,\n              message.role,\n              message.type,\n              time instanceof Date ? time.toISOString() : time,\n            ]\n          );\n        }\n      });\n\n      return messages;\n    } catch (error) {\n      this.logger.error('Failed to save messages in database: ' + (error as any)?.message);\n      throw error;\n    }\n  }\n\n  private transformEvalRow(row: Record<string, any>): EvalRow {\n    const resultValue = typeof row.result === 'string' ? JSON.parse(row.result) : row.result;\n    const testInfoValue = row.test_info ? \n      (typeof row.test_info === 'string' ? JSON.parse(row.test_info) : row.test_info) : \n      undefined;\n\n    if (!resultValue || typeof resultValue !== 'object' || !('score' in resultValue)) {\n      throw new Error(`Invalid MetricResult format: ${JSON.stringify(resultValue)}`);\n    }\n\n    return {\n      input: row.input as string,\n      output: row.output as string,\n      result: resultValue as MetricResult,\n      agentName: row.agent_name as string,\n      metricName: row.metric_name as string,\n      instructions: row.instructions as string,\n      testInfo: testInfoValue as TestInfo,\n      globalRunId: row.global_run_id as string,\n      runId: row.run_id as string,\n      createdAt: row.created_at as string,\n    };\n  }\n\n  async getEvalsByAgentName(agentName: string, type?: 'test' | 'live'): Promise<EvalRow[]> {\n    try {\n      const client = await this.getClient();\n      const baseQuery = `SELECT * FROM ${TABLE_EVALS} WHERE agent_name = $1`;\n      \n      let typeCondition = '';\n      if (type === 'test') {\n        typeCondition = \" AND test_info IS NOT NULL AND test_info->>'testPath' IS NOT NULL\";\n      } else if (type === 'live') {\n        typeCondition = \" AND (test_info IS NULL OR test_info->>'testPath' IS NULL)\";\n      }\n\n      const result = await client.query(\n        `${baseQuery}${typeCondition} ORDER BY created_at DESC`,\n        [agentName]\n      );\n\n      return (result.rows?.map(row => this.transformEvalRow(row as Record<string, any>)) ?? []);\n    } catch (error) {\n      // Handle case where table doesn't exist yet\n      if (error instanceof Error && error.message.includes('no such table')) {\n        return [];\n      }\n      this.logger.error('Failed to get evals for the specified agent: ' + (error as any)?.message);\n      throw error;\n    }\n  }\n\n  async getTraces(\n    {\n      name,\n      scope,\n      page,\n      perPage,\n      attributes,\n    }: { name?: string; scope?: string; page: number; perPage: number; attributes?: Record<string, string> } = {\n      page: 0,\n      perPage: 100,\n    },\n  ): Promise<any[]> {\n    const limit = perPage;\n    const offset = page * perPage;\n\n    const args: any[] = [];\n\n    const conditions: string[] = [];\n    if (name) {\n      conditions.push(\"name LIKE $\" + (args.length + 1) + \" || '%'\");\n      args.push(name);\n    }\n    if (scope) {\n      conditions.push('scope = $' + (args.length + 1));\n      args.push(scope);\n    }\n    if (attributes) {\n      Object.keys(attributes).forEach(key => {\n        conditions.push(`attributes->>'${key}' = $${args.length + 1}`);\n      });\n    }\n\n    if (attributes) {\n      for (const [_key, value] of Object.entries(attributes)) {\n        args.push(value);\n      }\n    }\n\n    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n    args.push(limit, offset);\n\n    const client = await this.getClient();\n    const result = await client.query<TraceRow>(\n      `SELECT * FROM ${TABLE_TRACES} ${whereClause} ORDER BY \"startTime\" DESC LIMIT $${args.length-1} OFFSET $${args.length}`,\n      args\n    );\n\n    if (!result.rows) {\n      return [];\n    }\n\n    return result.rows.map(row => ({\n      id: row.id,\n      parentSpanId: row.parentSpanId,\n      traceId: row.traceId,\n      name: row.name,\n      scope: row.scope,\n      kind: row.kind,\n      status: safelyParseJSON(row.status as string),\n      events: safelyParseJSON(row.events as string),\n      links: safelyParseJSON(row.links as string),\n      attributes: safelyParseJSON(row.attributes as string),\n      startTime: row.startTime,\n      endTime: row.endTime,\n      other: safelyParseJSON(row.other as string),\n      createdAt: row.createdAt,\n    })) as any;\n  }\n}\n\nexport { PGliteStore as DefaultStorage };"]}