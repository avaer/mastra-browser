{"version":3,"sources":["../../../src/storage/libsql/index.ts"],"names":["__name","MastraStorage","__publicField","createClient","isAbsolute","join","resolve","TABLE_WORKFLOW_SNAPSHOT","TABLE_THREADS","TABLE_MESSAGES","TABLE_EVALS","TABLE_TRACES"],"mappings":"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","file":"index.cjs","sourcesContent":["import { join, resolve, isAbsolute } from 'node:path';\nimport { createClient } from '@libsql/client';\nimport type { Client, InValue } from '@libsql/client';\n\nimport type { MetricResult, TestInfo } from '../../eval';\nimport type { MessageType, StorageThreadType } from '../../memory/types';\nimport { MastraStorage } from '../base';\nimport { TABLE_EVALS, TABLE_MESSAGES, TABLE_THREADS, TABLE_TRACES, TABLE_WORKFLOW_SNAPSHOT } from '../constants';\nimport type { TABLE_NAMES } from '../constants';\nimport type { StorageColumn, StorageGetMessagesArg, EvalRow } from '../types';\n\nfunction safelyParseJSON(jsonString: string): any {\n  try {\n    return JSON.parse(jsonString);\n  } catch {\n    return {};\n  }\n}\n\nexport interface LibSQLConfig {\n  url: string;\n  authToken?: string;\n}\n\nexport class LibSQLStore extends MastraStorage {\n  private client: Client;\n\n  constructor({ config }: { config: LibSQLConfig }) {\n    super({ name: `LibSQLStore` });\n\n    // need to re-init every time for in memory dbs or the tables might not exist\n    if (config.url === ':memory:' || config.url.startsWith('file::memory:')) {\n      this.shouldCacheInit = false;\n    }\n\n    this.client = createClient({\n      url: this.rewriteDbUrl(config.url),\n      authToken: config.authToken,\n    });\n  }\n\n  // If we're in the .mastra/output directory, use the dir outside .mastra dir\n  // reason we need to do this is libsql relative file paths are based on cwd, not current file path\n  // since mastra dev sets cwd to .mastra/output this means running an agent directly vs running with mastra dev\n  // will put db files in different locations, leading to an inconsistent experience between the two.\n  // Ex: with `file:ex.db`\n  // 1. `mastra dev`: ${cwd}/.mastra/output/ex.db\n  // 2. `tsx src/index.ts`: ${cwd}/ex.db\n  // so if we're in .mastra/output we need to rewrite the file url to be relative to the project root dir\n  // or the experience will be inconsistent\n  // this means `file:` urls are always relative to project root\n  // TODO: can we make this easier via bundling? https://github.com/mastra-ai/mastra/pull/2783#pullrequestreview-2662444241\n  protected rewriteDbUrl(url: string): string {\n    if (url.startsWith('file:') && url !== 'file::memory:') {\n      const pathPart = url.slice('file:'.length);\n\n      if (isAbsolute(pathPart)) {\n        return url;\n      }\n\n      const cwd = process.cwd();\n\n      if (cwd.includes('.mastra') && (cwd.endsWith(`output`) || cwd.endsWith(`output/`) || cwd.endsWith(`output\\\\`))) {\n        const baseDir = join(cwd, `..`, `..`); // <- .mastra/output/../../\n\n        const fullPath = resolve(baseDir, pathPart);\n\n        this.logger.debug(\n          `Initializing LibSQL db with url ${url} with relative file path from inside .mastra/output directory. Rewriting relative file url to \"file:${fullPath}\". This ensures it's outside the .mastra/output directory.`,\n        );\n\n        return `file:${fullPath}`;\n      }\n    }\n\n    return url;\n  }\n\n  private getCreateTableSQL(tableName: TABLE_NAMES, schema: Record<string, StorageColumn>): string {\n    const columns = Object.entries(schema).map(([name, col]) => {\n      let type = col.type.toUpperCase();\n      if (type === 'TEXT') type = 'TEXT';\n      if (type === 'TIMESTAMP') type = 'TEXT'; // Store timestamps as ISO strings\n      // if (type === 'BIGINT') type = 'INTEGER';\n\n      const nullable = col.nullable ? '' : 'NOT NULL';\n      const primaryKey = col.primaryKey ? 'PRIMARY KEY' : '';\n\n      return `${name} ${type} ${nullable} ${primaryKey}`.trim();\n    });\n\n    // For workflow_snapshot table, create a composite primary key\n    if (tableName === TABLE_WORKFLOW_SNAPSHOT) {\n      const stmnt = `CREATE TABLE IF NOT EXISTS ${tableName} (\n                ${columns.join(',\\n')},\n                PRIMARY KEY (workflow_name, run_id)\n            )`;\n      return stmnt;\n    }\n\n    return `CREATE TABLE IF NOT EXISTS ${tableName} (${columns.join(', ')})`;\n  }\n\n  async createTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n  }): Promise<void> {\n    try {\n      this.logger.debug(`Creating database table`, { tableName, operation: 'schema init' });\n      const sql = this.getCreateTableSQL(tableName, schema);\n      await this.client.execute(sql);\n    } catch (error) {\n      this.logger.error(`Error creating table ${tableName}: ${error}`);\n      throw error;\n    }\n  }\n\n  async clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    try {\n      await this.client.execute(`DELETE FROM ${tableName}`);\n    } catch (e) {\n      if (e instanceof Error) {\n        this.logger.error(e.message);\n      }\n    }\n  }\n\n  private prepareStatement({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): {\n    sql: string;\n    args: InValue[];\n  } {\n    const columns = Object.keys(record);\n    const values = Object.values(record).map(v => {\n      if (typeof v === `undefined`) {\n        // returning an undefined value will cause libsql to throw\n        return null;\n      }\n      if (v instanceof Date) {\n        return v.toISOString();\n      }\n      return typeof v === 'object' ? JSON.stringify(v) : v;\n    });\n    const placeholders = values.map(() => '?').join(', ');\n\n    return {\n      sql: `INSERT OR REPLACE INTO ${tableName} (${columns.join(', ')}) VALUES (${placeholders})`,\n      args: values,\n    };\n  }\n\n  async insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void> {\n    try {\n      await this.client.execute(\n        this.prepareStatement({\n          tableName,\n          record,\n        }),\n      );\n    } catch (error) {\n      this.logger.error(`Error upserting into table ${tableName}: ${error}`);\n      throw error;\n    }\n  }\n\n  async batchInsert({ tableName, records }: { tableName: TABLE_NAMES; records: Record<string, any>[] }): Promise<void> {\n    if (records.length === 0) return;\n\n    try {\n      const batchStatements = records.map(r => this.prepareStatement({ tableName, record: r }));\n      await this.client.batch(batchStatements, 'write');\n    } catch (error) {\n      this.logger.error(`Error upserting into table ${tableName}: ${error}`);\n      throw error;\n    }\n  }\n\n  async load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, string> }): Promise<R | null> {\n    const conditions = Object.entries(keys)\n      .map(([key]) => `${key} = ?`)\n      .join(' AND ');\n    const values = Object.values(keys);\n\n    const result = await this.client.execute({\n      sql: `SELECT * FROM ${tableName} WHERE ${conditions} ORDER BY createdAt DESC LIMIT 1`,\n      args: values,\n    });\n\n    if (!result.rows || result.rows.length === 0) {\n      return null;\n    }\n\n    const row = result.rows[0];\n    // Checks whether the string looks like a JSON object ({}) or array ([])\n    // If the string starts with { or [, it assumes it's JSON and parses it\n    // Otherwise, it just returns, preventing unintended number conversions\n    const parsed = Object.fromEntries(\n      Object.entries(row || {}).map(([k, v]) => {\n        try {\n          return [k, typeof v === 'string' ? (v.startsWith('{') || v.startsWith('[') ? JSON.parse(v) : v) : v];\n        } catch {\n          return [k, v];\n        }\n      }),\n    );\n\n    return parsed as R;\n  }\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    const result = await this.load<StorageThreadType>({\n      tableName: TABLE_THREADS,\n      keys: { id: threadId },\n    });\n\n    if (!result) {\n      return null;\n    }\n\n    return {\n      ...result,\n      metadata: typeof result.metadata === 'string' ? JSON.parse(result.metadata) : result.metadata,\n    };\n  }\n\n  async getThreadsByResourceId({ resourceId }: { resourceId: string }): Promise<StorageThreadType[]> {\n    const result = await this.client.execute({\n      sql: `SELECT * FROM ${TABLE_THREADS} WHERE resourceId = ?`,\n      args: [resourceId],\n    });\n\n    if (!result.rows) {\n      return [];\n    }\n\n    return result.rows.map(thread => ({\n      id: thread.id,\n      resourceId: thread.resourceId,\n      title: thread.title,\n      createdAt: thread.createdAt,\n      updatedAt: thread.updatedAt,\n      metadata: typeof thread.metadata === 'string' ? JSON.parse(thread.metadata) : thread.metadata,\n    })) as any as StorageThreadType[];\n  }\n\n  async saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType> {\n    await this.insert({\n      tableName: TABLE_THREADS,\n      record: {\n        ...thread,\n        metadata: JSON.stringify(thread.metadata),\n      },\n    });\n\n    return thread;\n  }\n\n  async updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType> {\n    const thread = await this.getThreadById({ threadId: id });\n    if (!thread) {\n      throw new Error(`Thread ${id} not found`);\n    }\n\n    const updatedThread = {\n      ...thread,\n      title,\n      metadata: {\n        ...thread.metadata,\n        ...metadata,\n      },\n    };\n\n    await this.client.execute({\n      sql: `UPDATE ${TABLE_THREADS} SET title = ?, metadata = ? WHERE id = ?`,\n      args: [title, JSON.stringify(updatedThread.metadata), id],\n    });\n\n    return updatedThread;\n  }\n\n  async deleteThread({ threadId }: { threadId: string }): Promise<void> {\n    await this.client.execute({\n      sql: `DELETE FROM ${TABLE_THREADS} WHERE id = ?`,\n      args: [threadId],\n    });\n    // Messages will be automatically deleted due to CASCADE constraint\n  }\n\n  private parseRow(row: any): MessageType {\n    let content = row.content;\n    try {\n      content = JSON.parse(row.content);\n    } catch {\n      // use content as is if it's not JSON\n    }\n    return {\n      id: row.id,\n      content,\n      role: row.role,\n      type: row.type,\n      createdAt: new Date(row.createdAt as string),\n      threadId: row.thread_id,\n    } as MessageType;\n  }\n\n  async getMessages<T extends MessageType[]>({ threadId, selectBy }: StorageGetMessagesArg): Promise<T> {\n    try {\n      const messages: MessageType[] = [];\n      const limit = typeof selectBy?.last === `number` ? selectBy.last : 40;\n\n      // If we have specific messages to select\n      if (selectBy?.include?.length) {\n        const includeIds = selectBy.include.map(i => i.id);\n        const maxPrev = Math.max(...selectBy.include.map(i => i.withPreviousMessages || 0));\n        const maxNext = Math.max(...selectBy.include.map(i => i.withNextMessages || 0));\n\n        // Get messages around all specified IDs in one query using row numbers\n        const includeResult = await this.client.execute({\n          sql: `\n            WITH numbered_messages AS (\n              SELECT \n                id,\n                content,\n                role,\n                type,\n                \"createdAt\",\n                thread_id,\n                ROW_NUMBER() OVER (ORDER BY \"createdAt\" ASC) as row_num\n              FROM \"${TABLE_MESSAGES}\"\n              WHERE thread_id = ?\n            ),\n            target_positions AS (\n              SELECT row_num as target_pos\n              FROM numbered_messages\n              WHERE id IN (${includeIds.map(() => '?').join(', ')})\n            )\n            SELECT DISTINCT m.*\n            FROM numbered_messages m\n            CROSS JOIN target_positions t\n            WHERE m.row_num BETWEEN (t.target_pos - ?) AND (t.target_pos + ?)\n            ORDER BY m.\"createdAt\" ASC\n          `,\n          args: [threadId, ...includeIds, maxPrev, maxNext],\n        });\n\n        if (includeResult.rows) {\n          messages.push(...includeResult.rows.map((row: any) => this.parseRow(row)));\n        }\n      }\n\n      // Get remaining messages, excluding already fetched IDs\n      const excludeIds = messages.map(m => m.id);\n      const remainingSql = `\n        SELECT \n          id, \n          content, \n          role, \n          type,\n          \"createdAt\", \n          thread_id\n        FROM \"${TABLE_MESSAGES}\"\n        WHERE thread_id = ?\n        ${excludeIds.length ? `AND id NOT IN (${excludeIds.map(() => '?').join(', ')})` : ''}\n        ORDER BY \"createdAt\" DESC\n        LIMIT ?\n      `;\n      const remainingArgs = [threadId, ...(excludeIds.length ? excludeIds : []), limit];\n\n      const remainingResult = await this.client.execute({\n        sql: remainingSql,\n        args: remainingArgs,\n      });\n\n      if (remainingResult.rows) {\n        messages.push(...remainingResult.rows.map((row: any) => this.parseRow(row)));\n      }\n\n      // Sort all messages by creation date\n      messages.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n\n      return messages as T;\n    } catch (error) {\n      this.logger.error('Error getting messages:', error as Error);\n      throw error;\n    }\n  }\n\n  async saveMessages({ messages }: { messages: MessageType[] }): Promise<MessageType[]> {\n    if (messages.length === 0) return messages;\n\n    const tx = await this.client.transaction('write');\n\n    try {\n      const threadId = messages[0]?.threadId;\n      if (!threadId) {\n        throw new Error('Thread ID is required');\n      }\n\n      for (const message of messages) {\n        const time = message.createdAt || new Date();\n        await tx.execute({\n          sql: `INSERT INTO ${TABLE_MESSAGES} (id, thread_id, content, role, type, createdAt) \n                              VALUES (?, ?, ?, ?, ?, ?)`,\n          args: [\n            message.id,\n            threadId,\n            typeof message.content === 'object' ? JSON.stringify(message.content) : message.content,\n            message.role,\n            message.type,\n            time instanceof Date ? time.toISOString() : time,\n          ],\n        });\n      }\n\n      await tx.commit();\n\n      return messages;\n    } catch (error) {\n      this.logger.error('Failed to save messages in database: ' + (error as any)?.message);\n      await tx.rollback();\n      throw error;\n    }\n  }\n\n  private transformEvalRow(row: Record<string, any>): EvalRow {\n    const resultValue = JSON.parse(row.result as string);\n    const testInfoValue = row.test_info ? JSON.parse(row.test_info as string) : undefined;\n\n    if (!resultValue || typeof resultValue !== 'object' || !('score' in resultValue)) {\n      throw new Error(`Invalid MetricResult format: ${JSON.stringify(resultValue)}`);\n    }\n\n    return {\n      input: row.input as string,\n      output: row.output as string,\n      result: resultValue as MetricResult,\n      agentName: row.agent_name as string,\n      metricName: row.metric_name as string,\n      instructions: row.instructions as string,\n      testInfo: testInfoValue as TestInfo,\n      globalRunId: row.global_run_id as string,\n      runId: row.run_id as string,\n      createdAt: row.created_at as string,\n    };\n  }\n\n  async getEvalsByAgentName(agentName: string, type?: 'test' | 'live'): Promise<EvalRow[]> {\n    try {\n      const baseQuery = `SELECT * FROM ${TABLE_EVALS} WHERE agent_name = ?`;\n      const typeCondition =\n        type === 'test'\n          ? \" AND test_info IS NOT NULL AND test_info->>'testPath' IS NOT NULL\"\n          : type === 'live'\n            ? \" AND (test_info IS NULL OR test_info->>'testPath' IS NULL)\"\n            : '';\n\n      const result = await this.client.execute({\n        sql: `${baseQuery}${typeCondition} ORDER BY created_at DESC`,\n        args: [agentName],\n      });\n\n      return result.rows?.map(row => this.transformEvalRow(row)) ?? [];\n    } catch (error) {\n      // Handle case where table doesn't exist yet\n      if (error instanceof Error && error.message.includes('no such table')) {\n        return [];\n      }\n      this.logger.error('Failed to get evals for the specified agent: ' + (error as any)?.message);\n      throw error;\n    }\n  }\n\n  // TODO: add types\n  async getTraces(\n    {\n      name,\n      scope,\n      page,\n      perPage,\n      attributes,\n    }: { name?: string; scope?: string; page: number; perPage: number; attributes?: Record<string, string> } = {\n      page: 0,\n      perPage: 100,\n    },\n  ): Promise<any[]> {\n    const limit = perPage;\n    const offset = page * perPage;\n\n    const args: (string | number)[] = [];\n\n    const conditions: string[] = [];\n    if (name) {\n      conditions.push(\"name LIKE CONCAT(?, '%')\");\n    }\n    if (scope) {\n      conditions.push('scope = ?');\n    }\n    if (attributes) {\n      Object.keys(attributes).forEach(key => {\n        conditions.push(`attributes->>'$.${key}' = ?`);\n      });\n    }\n\n    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';\n\n    if (name) {\n      args.push(name);\n    }\n\n    if (scope) {\n      args.push(scope);\n    }\n\n    if (attributes) {\n      for (const [_key, value] of Object.entries(attributes)) {\n        args.push(value);\n      }\n    }\n\n    args.push(limit, offset);\n\n    const result = await this.client.execute({\n      sql: `SELECT * FROM ${TABLE_TRACES} ${whereClause} ORDER BY \"startTime\" DESC LIMIT ? OFFSET ?`,\n      args,\n    });\n\n    if (!result.rows) {\n      return [];\n    }\n\n    return result.rows.map(row => ({\n      id: row.id,\n      parentSpanId: row.parentSpanId,\n      traceId: row.traceId,\n      name: row.name,\n      scope: row.scope,\n      kind: row.kind,\n      status: safelyParseJSON(row.status as string),\n      events: safelyParseJSON(row.events as string),\n      links: safelyParseJSON(row.links as string),\n      attributes: safelyParseJSON(row.attributes as string),\n      startTime: row.startTime,\n      endTime: row.endTime,\n      other: safelyParseJSON(row.other as string),\n      createdAt: row.createdAt,\n    })) as any;\n  }\n}\n\nexport { LibSQLStore as DefaultStorage };\n"]}