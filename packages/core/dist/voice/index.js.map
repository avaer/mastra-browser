{"version":3,"sources":["../../src/voice/voice.ts","../../src/voice/composite-voice.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAAA,IAAA,cAAA;AAgCA,IAAA;AAAiB,GACP,GAAA,EAAA,EAAA;AAAA,IACQ,KAAA,CAAA;AAClB,MAAC,SAAA,EAAA,OAAA;AACM,MAAe;AAOD,KAUnB,CAAA;AACE,IAAM,aAAA,CAAA,IAAA,EAAA,gBAAA,CAAA;AAAA,IAAA,aACO,CAAA,IAAA,EAAA,aAAA,CAAA;AAAA,IACX,aAAA,CAAA,IAAA,EAAA,SAAA,CAAA;AAAA,IACF,aAAC,CAAA,IAAA,EAAA,gBAAA,CAAA;AAbH,IAAU,IAAA,CAAA,cAAA,GAAA,cAAA;AACV,IAAU,IAAA,CAAA,WAAA,GAAA,WAAA;AACV,IAAU,IAAA,CAAA,OAAA,GAAA,OAAA;AACV,IAAU,IAAA,CAAA,cAAA,GAAA,cAAA;AAWR;AACA,EAAA,MAAA,CAAK,MAAc,EAAA,UAAA,EAAA;AACnB,IAAA,OAAe,IAAA,CAAA,SAAA,EAAA,WAAA,CAAA,MAAA,EAAA;AACf,MAAA,QAAsB,EAAA,CAAA,MAAA,EAAA,UAAA,CAAA,CAAA;AAAA,MACxB,UAAA,EAAA;AAAA,QAEA,YAA6D,EAAA,IAAA,CAAA,WAAA,EAAA,IAAA,IAAA,IAAA,CAAA,cAAA,EAAA,IAAA,IAAA;AAC3D;AACsC,KAClC,CAAA,IAAA,MAAU;AAAmB;AACjB,EAAA,qBACS,EAAA;AAAkD,IACvE,IAAA,CAAA,MAAA,CAAA,IAAA,CAAA,qDAAA,CAAA;AAAA;AACI;AAEV;AAuCE;AAAsE;AACxE,EAAA,OAAA,CAAA,QAAA,EAAA;AAAA,IAAA,IAAA,CAAA,MAAA,CAAA,IAAA,CAAA,gDAAA,CAAA;AAAA,IAAA,OAAA,OAAA,CAAA,OAAA,EAAA;AAAA;AAAA;AAQE;AACA;AAAuB;AACzB,EAAA,IAAA,CAAA,UAAA,EAAA;AAAA,IAAA,IAAA,CAAA,MAAA,CAAA,IAAA,CAAA,8CAAA,CAAA;AAAA,IAAA,OAAA,OAAA,CAAA,OAAA,EAAA;AAAA;AAAA;AAQE;AACA;AAAuB,EACzB,MAAA,CAAA,QAAA,EAAA;AAAA,IAAA,IAAA,CAAA,MAAA,CAAA,IAAA,CAAA,+CAAA,CAAA;AAAA,IAAA,OAAA,OAAA,CAAA,OAAA,EAAA;AAAA;AAAA;AAME;AACA;AAAuB;AACzB,EAAA,eAAA,CAAA,aAAA,EAAA;AAAA,IAAA,IAAA,CAAA,MAAA,CAAA,IAAA,CAAA,wDAAA,CAAA;AAAA;AAAA;AAAA;AAQE;AAAyE;AAC3E,EAAA,QAAA,CAAA,MAAA,EAAA;AAAA,IAAA,IAAA,CAAA,MAAA,CAAA,IAAA,CAAA,iDAAA,CAAA;AAAA;AAAA;AAAA;AAQE;AAAkE,EACpE,KAAA,GAAA;AAAA,IAAA,IAAA,CAAA,MAAA,CAAA,IAAA,CAAA,8CAAA,CAAA;AAAA;AAAA;AAAA;AAOE;AAA+D;AACjE;AAAA,EAAA,EAAA,CAAA,MAAA,EAAA,SAAA,EAAA;AAAA,IAAA,IAAA,CAAA,MAAA,CAAA,IAAA,CAAA,2CAAA,CAAA;AAAA;AAAA;AAAA;AAYE;AAA4D;AAC9D;AAAA,EAAA,GAAA,CAAA,MAAA,EAAA,SAAA,EAAA;AAAA,IAAA,IAAA,CAAA,MAAA,CAAA,IAAA,CAAA,4CAAA,CAAA;AAAA;AAAA;AAAA;AAYE;AAA6D;AAC/D,EAAA,WAAA,GAAA;AAAA,IAAA,IAAA,CAAA,MAAA,CAAA,IAAA,CAAA,oDAAA,CAAA;AAAA,IAAA,OAAA,OAAA,CAAA,OAAA,CAAA,EAAA,CAAA;AAAA;AAAA,CAAA;AAcE,YAAK,gBAAgE,CAAA,CAAA,IAAA;AACrE,EAAO,KAAA,GAAA,gBAAgB,CAAA,EAAE,CAAA;AAAA,EAC3B,YAAA,GAAA,iBAAA,CAAA,KAAA,EAAA,CAAA,EAAA,aAAA,EAAA,uBAAA,EAAA,YAAA,CAAA;AACF,EAAA,MAAA,CAAA,YAAA,EAAA,aAAA,CAAA;AA9KO,EAAA,OAAA,YAAA;AAAe,CAAA,EAAf;AAOc,iBAAA,CAAA,KAAA,EAAA,CAAA,EAAA,YAAA,CAAA;AAPC,IAAA,WAAA,GAAA;;;;AChCf,EAAM,WAAA,CAAA;AAAyF,IAKxF,aAAA;AAAA,IACV,cAAA;AAAA,IACA;AAAA,GACA,EAAA;AAAA,IAKC,KAAA,EAAA;AACD,IAAM,aAAA,CAAA,IAAA,EAAA,eAAA,CAAA;AAbR,IAAU,aAAA,CAAA,IAAA,EAAA,gBAAA,CAAA;AACV,IAAU,aAAA,CAAA,IAAA,EAAA,kBAAA,CAAA;AACV,IAAU,IAAA,CAAA,aAAA,GAAA,aAAA;AAYR,IAAA,IAAA,CAAK,cAAgB,GAAA,cAAA;AACrB,IAAA,IAAA,CAAK,gBAAiB,GAAA,gBAAA;AACtB;AAAwB;AAC1B;AAAA;AAAA;AAAA;AAAA;AAAA,EAAA,MAAA,KAAA,CAAA,KAAA,EAAA,OAAA,EAAA;AAAA,IAQA,IAAM,IACJ,CAAA,gBAEuC,EAAA;AACvC,MAAA,OAAS,IAAkB,CAAA,gBAAA,CAAA,KAAA,CAAA,KAAA,EAAA,OAAA,CAAA;AACzB,KAAA,MAAA,IAAY,IAAA,CAAA,aAAA,EAAiB;AAAoB,MACnD,OAAA,kBAA+B,CAAA,KAAA,CAAA,KAAA,EAAA,OAAA,CAAA;AAC7B;AAA8C,IAChD,MAAA,IAAA,KAAA,CAAA,mDAAA,CAAA;AAEA;AAAmE,EACrE,MAAA,MAAA,CAAA,WAAA,EAAA,OAAA,EAAA;AAAA,IAEA,IAAM,IAAO,CAAA,gBAAmD,EAAA;AAC9D,MAAA,OAAS,MAAkB,IAAA,CAAA,gBAAA,CAAA,MAAA,CAAA,WAAA,EAAA,OAAA,CAAA;AACzB,KAAA,MAAA,IAAa,IAAA,CAAA,cAAsB,EAAA;AAA2B,MAChE,OAAA,UAAgC,CAAA,cAAA,CAAA,MAAA,CAAA,WAAA,EAAA,OAAA,CAAA;AAC9B;AAA4D,IAC9D,MAAA,IAAA,KAAA,CAAA,oDAAA,CAAA;AAEA;AAAoE,EACtE,MAAA,WAAA,GAAA;AAAA,QAEM,IAAc,CAAA,gBAAA,EAAA;AAClB,MAAA,OAAS,IAAkB,CAAA,gBAAA,CAAA,WAAA,EAAA;AACzB,KAAO,MAAA,IAAA,oBAAsB;AAAY,MAC3C,OAAA,kBAA+B,CAAA,WAAA,EAAA;AAC7B;AAAsC,IACxC,MAAA,IAAA,KAAA,CAAA,mDAAA,CAAA;AAEA;AAAmE,EACrE,YAAA,CAAA,OAAA,EAAA;AAAA,8BAEqD,EAAA;AACnD,MAAI;AACF;AAAA,IACF,IAAA,CAAA,gBAAA,CAAA,YAAA,CAAA,OAAA,CAAA;AACA;AAA0C;AAC5C;AAAA;AAAA;AAAA,EAAA,OAAA,CAAA,OAAA,EAAA;AAAA,aAM0D,CAAA,gBAAA,EAAA;AACxD,MAAI,UAAwB,KAAA,CAAA,iCAAA,CAAA;AAC1B;AAAiD,IACnD,OAAA,IAAA,CAAA,gBAAA,CAAA,OAAA,CAAA,OAAA,CAAA;AACA;AAA4C;AAC9C;AAAA;AAAA;AAAA,EAAA,IAAA,CAAA,SAAA,EAAA;AAAA,QAMmE,CAAA,IAAA,CAAA,gBAAA,EAAA;AACjE,MAAI,UAAwB,KAAA,CAAA,iCAAA,CAAA;AAC1B;AAAiD,IACnD,OAAA,IAAA,CAAA,gBAAA,CAAA,IAAA,CAAA,SAAA,CAAA;AACA;AAA2C;AAC7C;AAAA;AAAA,EAAA,MAAA,CAAA,OAAA,EAAA;AAAA,SAKO,IAAkD,CAAA,gBAAA,EAAA;AACvD,MAAI,UAAwB,KAAA,CAAA,iCAAA,CAAA;AAC1B;AAAiD,IACnD,OAAA,IAAA,CAAA,gBAAA,CAAA,MAAA,CAAA,OAAA,CAAA;AACA;AAA2C;AAC7C;AAAA;AAAA;AAAA,EAAA,eAAA,CAAA,YAAA,EAAA;AAAA,8BAM4C,EAAA;AAC1C,MAAI;AACF;AAAA,IACF,IAAA,CAAA,gBAAA,CAAA,eAAA,CAAA,YAAA,CAAA;AACA;AAAkD;AACpD;AAAA;AAAA;AAAA,EAAA,QAAA,CAAA,KAAA,EAAA;AAAA,aAMkC,CAAA,gBAAA,EAAA;AAChC,MAAI;AACF;AAAA,IACF,IAAA,CAAA,gBAAA,CAAA,QAAA,CAAA,KAAA,CAAA;AACA;AAAoC;AACtC;AAAA;AAAA,EAAA,KAAA,GAAA;AAAA,IAKc,IAAA,CAAA,IAAA,CAAA,gBAAA,EAAA;AACZ,MAAI,UAAwB,KAAA,CAAA,iCAAA,CAAA;AAC1B;AAAiD,IACnD,IAAA,CAAA,gBAAA,CAAA,KAAA,EAAA;AACA;AAA4B;AAC9B;AAAA;AAAA;AAAA;AAAA,EAAA,EAAA,CAAA,KAAA,EAAA,QAAA,EAAA;AAAA,IAOA,SAGQ,CAAA,gBAAA,EAAA;AACN,MAAI,UAAwB,KAAA,CAAA,iCAAA,CAAA;AAC1B;AAAiD,IACnD,IAAA,CAAA,gBAAA,CAAA,EAAA,CAAA,KAAA,EAAA,QAAA,CAAA;AACA;AAAwC;AAC1C;AAAA;AAAA;AAAA;AAAA,EAAA,GAAA,CAAA,KAAA,EAAA,QAAA,EAAA;AAAA,IAOA,SAEE,CACM,gBAAA,EAAA;AACN,MAAI,UAAwB,KAAA,CAAA,iCAAA,CAAA;AAC1B;AAAiD,IACnD,IAAA,CAAA,gBAAA,CAAA,GAAA,CAAA,KAAA,EAAA,QAAA,CAAA;AACA;AAAyC,CAC3C;AACF,MAAA,CAAA,eAAA,EAAA,gBAAA,CAAA;AA/JsG,IAAA,cAAA,GAAA","file":"index.js","sourcesContent":["import type { ToolsInput } from '../agent';\nimport { MastraBase } from '../base';\nimport { InstrumentClass } from '../telemetry';\n\nexport type VoiceEventType = 'speaking' | 'writing' | 'error' | string;\n\nexport interface VoiceEventMap {\n  speaker: NodeJS.ReadableStream;\n  speaking: { audio?: string };\n  writing: { text: string; role: 'assistant' | 'user' };\n  error: { message: string; code?: string; details?: unknown };\n  [key: string]: unknown;\n}\n\ninterface BuiltInModelConfig {\n  name: string;\n  baseURL?: string;\n  apiKey?: string;\n}\n\nexport interface VoiceConfig<T = unknown> {\n  listeningModel?: BuiltInModelConfig;\n  speechModel?: BuiltInModelConfig;\n  speaker?: string;\n  name?: string;\n  realtimeConfig?: {\n    model?: string;\n    apiKey?: string;\n    options?: T;\n  };\n}\n\n@InstrumentClass({\n  prefix: 'voice',\n  excludeMethods: ['__setTools', '__setLogger', '__setTelemetry', '#log'],\n})\nexport abstract class MastraVoice<\n  TOptions = unknown,\n  TSpeakOptions = unknown,\n  TListenOptions = unknown,\n  TTools extends ToolsInput = ToolsInput,\n  TEventArgs extends VoiceEventMap = VoiceEventMap,\n  TSpeakerMetadata = unknown,\n> extends MastraBase {\n  protected listeningModel?: BuiltInModelConfig;\n  protected speechModel?: BuiltInModelConfig;\n  protected speaker?: string;\n  protected realtimeConfig?: {\n    model?: string;\n    apiKey?: string;\n    options?: TOptions;\n  };\n\n  constructor({ listeningModel, speechModel, speaker, realtimeConfig, name }: VoiceConfig<TOptions> = {}) {\n    super({\n      component: 'VOICE',\n      name,\n    });\n    this.listeningModel = listeningModel;\n    this.speechModel = speechModel;\n    this.speaker = speaker;\n    this.realtimeConfig = realtimeConfig;\n  }\n\n  traced<T extends Function>(method: T, methodName: string): T {\n    return (\n      this.telemetry?.traceMethod(method, {\n        spanName: `voice.${methodName}`,\n        attributes: {\n          'voice.type': this.speechModel?.name || this.listeningModel?.name || 'unknown',\n        },\n      }) ?? method\n    );\n  }\n\n  /**\n   * Convert text to speech\n   * @param input Text or text stream to convert to speech\n   * @param options Speech options including speaker and provider-specific options\n   * @returns Audio stream\n   */\n  /**\n   * Convert text to speech\n   * @param input Text or text stream to convert to speech\n   * @param options Speech options including speaker and provider-specific options\n   * @returns Audio stream or void if in chat mode\n   */\n  abstract speak(\n    input: string | NodeJS.ReadableStream,\n    options?: {\n      speaker?: string;\n    } & TSpeakOptions,\n  ): Promise<NodeJS.ReadableStream | void>;\n\n  /**\n   * Convert speech to text\n   * @param audioStream Audio stream to transcribe\n   * @param options Provider-specific transcription options\n   * @returns Text or text stream\n   */\n  /**\n   * Convert speech to text\n   * @param audioStream Audio stream to transcribe\n   * @param options Provider-specific transcription options\n   * @returns Text, text stream, or void if in chat mode\n   */\n  abstract listen(\n    audioStream: NodeJS.ReadableStream | unknown, // Allow other audio input types for OpenAI realtime API\n    options?: TListenOptions,\n  ): Promise<string | NodeJS.ReadableStream | void>;\n\n  updateConfig(_options: Record<string, unknown>): void {\n    this.logger.warn('updateConfig not implemented by this voice provider');\n  }\n\n  /**\n   * Initializes a WebSocket or WebRTC connection for real-time communication\n   * @returns Promise that resolves when the connection is established\n   */\n  connect(_options?: Record<string, unknown>): Promise<void> {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('connect not implemented by this voice provider');\n    return Promise.resolve();\n  }\n\n  /**\n   * Relay audio data to the voice provider for real-time processing\n   * @param audioData Audio data to relay\n   */\n  send(_audioData: NodeJS.ReadableStream | Int16Array): Promise<void> {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('relay not implemented by this voice provider');\n    return Promise.resolve();\n  }\n\n  /**\n   * Trigger voice providers to respond\n   */\n  answer(_options?: Record<string, unknown>): Promise<void> {\n    this.logger.warn('answer not implemented by this voice provider');\n    return Promise.resolve();\n  }\n\n  /**\n   * Equip the voice provider with instructions\n   * @param instructions Instructions to add\n   */\n  addInstructions(_instructions?: string): void {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('addInstructions not implemented by this voice provider');\n  }\n\n  /**\n   * Equip the voice provider with tools\n   * @param tools Array of tools to add\n   */\n  addTools(_tools: TTools): void {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('addTools not implemented by this voice provider');\n  }\n\n  /**\n   * Disconnect from the WebSocket or WebRTC connection\n   */\n  close(): void {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('close not implemented by this voice provider');\n  }\n\n  /**\n   * Register an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function that receives event data\n   */\n  on<E extends VoiceEventType>(\n    _event: E,\n    _callback: (data: E extends keyof TEventArgs ? TEventArgs[E] : unknown) => void,\n  ): void {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('on not implemented by this voice provider');\n  }\n\n  /**\n   * Remove an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function to remove\n   */\n  off<E extends VoiceEventType>(\n    _event: E,\n    _callback: (data: E extends keyof TEventArgs ? TEventArgs[E] : unknown) => void,\n  ): void {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('off not implemented by this voice provider');\n  }\n\n  /**\n   * Get available speakers/voices\n   * @returns Array of available voice IDs and their metadata\n   */\n  getSpeakers(): Promise<\n    Array<\n      {\n        voiceId: string;\n      } & TSpeakerMetadata\n    >\n  > {\n    // Default implementation - voice providers can override if they support this feature\n    this.logger.warn('getSpeakers not implemented by this voice provider');\n    return Promise.resolve([]);\n  }\n}\n","import type { ToolsInput } from '../agent';\nimport { MastraVoice } from '.';\nimport type { VoiceEventType, VoiceEventMap } from '.';\n\nexport class CompositeVoice extends MastraVoice<unknown, unknown, unknown, ToolsInput, VoiceEventMap> {\n  protected speakProvider?: MastraVoice;\n  protected listenProvider?: MastraVoice;\n  protected realtimeProvider?: MastraVoice;\n\n  constructor({\n    speakProvider,\n    listenProvider,\n    realtimeProvider,\n  }: {\n    speakProvider?: MastraVoice;\n    listenProvider?: MastraVoice;\n    realtimeProvider?: MastraVoice;\n  }) {\n    super();\n    this.speakProvider = speakProvider;\n    this.listenProvider = listenProvider;\n    this.realtimeProvider = realtimeProvider;\n  }\n\n  /**\n   * Convert text to speech using the configured provider\n   * @param input Text or text stream to convert to speech\n   * @param options Speech options including speaker and provider-specific options\n   * @returns Audio stream or void if in realtime mode\n   */\n  async speak(\n    input: string | NodeJS.ReadableStream,\n    options?: { speaker?: string } & any,\n  ): Promise<NodeJS.ReadableStream | void> {\n    if (this.realtimeProvider) {\n      return this.realtimeProvider.speak(input, options);\n    } else if (this.speakProvider) {\n      return this.speakProvider.speak(input, options);\n    }\n\n    throw new Error('No speak provider or realtime provider configured');\n  }\n\n  async listen(audioStream: NodeJS.ReadableStream, options?: any) {\n    if (this.realtimeProvider) {\n      return await this.realtimeProvider.listen(audioStream, options);\n    } else if (this.listenProvider) {\n      return await this.listenProvider.listen(audioStream, options);\n    }\n\n    throw new Error('No listen provider or realtime provider configured');\n  }\n\n  async getSpeakers() {\n    if (this.realtimeProvider) {\n      return this.realtimeProvider.getSpeakers();\n    } else if (this.speakProvider) {\n      return this.speakProvider.getSpeakers();\n    }\n\n    throw new Error('No speak provider or realtime provider configured');\n  }\n\n  updateConfig(options: Record<string, unknown>): void {\n    if (!this.realtimeProvider) {\n      return;\n    }\n    this.realtimeProvider.updateConfig(options);\n  }\n\n  /**\n   * Initializes a WebSocket or WebRTC connection for real-time communication\n   * @returns Promise that resolves when the connection is established\n   */\n  connect(options?: Record<string, unknown>): Promise<void> {\n    if (!this.realtimeProvider) {\n      throw new Error('No realtime provider configured');\n    }\n    return this.realtimeProvider.connect(options);\n  }\n\n  /**\n   * Relay audio data to the voice provider for real-time processing\n   * @param audioData Audio data to send\n   */\n  send(audioData: NodeJS.ReadableStream | Int16Array): Promise<void> {\n    if (!this.realtimeProvider) {\n      throw new Error('No realtime provider configured');\n    }\n    return this.realtimeProvider.send(audioData);\n  }\n\n  /**\n   * Trigger voice providers to respond\n   */\n  answer(options?: Record<string, unknown>): Promise<void> {\n    if (!this.realtimeProvider) {\n      throw new Error('No realtime provider configured');\n    }\n    return this.realtimeProvider.answer(options);\n  }\n\n  /**\n   * Equip the voice provider with instructions\n   * @param instructions Instructions to add\n   */\n  addInstructions(instructions: string): void {\n    if (!this.realtimeProvider) {\n      return;\n    }\n    this.realtimeProvider.addInstructions(instructions);\n  }\n\n  /**\n   * Equip the voice provider with tools\n   * @param tools Array of tools to add\n   */\n  addTools(tools: ToolsInput): void {\n    if (!this.realtimeProvider) {\n      return;\n    }\n    this.realtimeProvider.addTools(tools);\n  }\n\n  /**\n   * Disconnect from the WebSocket or WebRTC connection\n   */\n  close(): void {\n    if (!this.realtimeProvider) {\n      throw new Error('No realtime provider configured');\n    }\n    this.realtimeProvider.close();\n  }\n\n  /**\n   * Register an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function that receives event data\n   */\n  on<E extends VoiceEventType>(\n    event: E,\n    callback: (data: E extends keyof VoiceEventMap ? VoiceEventMap[E] : unknown) => void,\n  ): void {\n    if (!this.realtimeProvider) {\n      throw new Error('No realtime provider configured');\n    }\n    this.realtimeProvider.on(event, callback);\n  }\n\n  /**\n   * Remove an event listener\n   * @param event Event name (e.g., 'speaking', 'writing', 'error')\n   * @param callback Callback function to remove\n   */\n  off<E extends VoiceEventType>(\n    event: E,\n    callback: (data: E extends keyof VoiceEventMap ? VoiceEventMap[E] : unknown) => void,\n  ): void {\n    if (!this.realtimeProvider) {\n      throw new Error('No realtime provider configured');\n    }\n    this.realtimeProvider.off(event, callback);\n  }\n}\n"]}