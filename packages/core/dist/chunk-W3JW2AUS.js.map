{"version":3,"sources":["../src/vector/filter/base.ts"],"names":[],"mappings":"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","file":"chunk-W3JW2AUS.js","sourcesContent":["type BasicOperator =\n  | '$eq' // Matches values equal to specified value\n  | '$ne'; // Matches values not equal\n\ntype NumericOperator =\n  | '$gt' // Greater than\n  | '$gte' // Greater than or equal\n  | '$lt' // Less than\n  | '$lte'; // Less than or equal\n\ntype LogicalOperator =\n  | '$and' // Joins query clauses with logical AND\n  | '$not' // Inverts the effect of a query expression\n  | '$nor' // Joins query clauses with logical NOR\n  | '$or'; // Joins query clauses with logical OR\n\ntype ArrayOperator =\n  | '$all' // Matches arrays containing all elements\n  | '$in' // Matches any value in array\n  | '$nin' // Matches none of the values in array\n  | '$elemMatch'; // Matches documents that contain an array field with at least one element that matches all the specified query criteria\n\ntype ElementOperator = '$exists'; // Matches documents that have the specified field\n\ntype RegexOperator = '$regex' | '$options'; // Matches documents that have the specified field\n\n// Union of all supported operators\ntype QueryOperator =\n  | BasicOperator\n  | NumericOperator\n  | LogicalOperator\n  | ArrayOperator\n  | ElementOperator\n  | RegexOperator;\n\n// Type for a field condition using an operator\ntype OperatorCondition = {\n  [K in QueryOperator]?: any;\n};\n\n// Type for a field condition that can be either a direct value or use operators\ntype FieldCondition = OperatorCondition | any;\n\n// Type for the overall filter structure\ntype VectorFilter =\n  | {\n      [field: string]: FieldCondition | VectorFilter;\n    }\n  | null\n  | undefined;\n\ntype OperatorSupport = {\n  logical?: LogicalOperator[];\n  array?: ArrayOperator[];\n  basic?: BasicOperator[];\n  numeric?: NumericOperator[];\n  element?: ElementOperator[];\n  regex?: RegexOperator[];\n  custom?: string[];\n};\n\n// Base abstract class for filter translators\nabstract class BaseFilterTranslator {\n  abstract translate(filter: VectorFilter): unknown;\n\n  /**\n   * Operator type checks\n   */\n  protected isOperator(key: string): key is QueryOperator {\n    return key.startsWith('$');\n  }\n\n  protected static readonly BASIC_OPERATORS: BasicOperator[] = ['$eq', '$ne'];\n  protected static readonly NUMERIC_OPERATORS: NumericOperator[] = ['$gt', '$gte', '$lt', '$lte'];\n  protected static readonly ARRAY_OPERATORS: ArrayOperator[] = ['$in', '$nin', '$all', '$elemMatch'];\n  protected static readonly LOGICAL_OPERATORS: LogicalOperator[] = ['$and', '$or', '$not', '$nor'];\n  protected static readonly ELEMENT_OPERATORS: ElementOperator[] = ['$exists'];\n  protected static readonly REGEX_OPERATORS: RegexOperator[] = ['$regex', '$options'];\n\n  public static readonly DEFAULT_OPERATORS = {\n    logical: BaseFilterTranslator.LOGICAL_OPERATORS,\n    basic: BaseFilterTranslator.BASIC_OPERATORS,\n    numeric: BaseFilterTranslator.NUMERIC_OPERATORS,\n    array: BaseFilterTranslator.ARRAY_OPERATORS,\n    element: BaseFilterTranslator.ELEMENT_OPERATORS,\n    regex: BaseFilterTranslator.REGEX_OPERATORS,\n  };\n\n  protected isLogicalOperator(key: string): key is LogicalOperator {\n    return BaseFilterTranslator.DEFAULT_OPERATORS.logical.includes(key as LogicalOperator);\n  }\n\n  protected isBasicOperator(key: string): key is BasicOperator {\n    return BaseFilterTranslator.DEFAULT_OPERATORS.basic.includes(key as BasicOperator);\n  }\n\n  protected isNumericOperator(key: string): key is NumericOperator {\n    return BaseFilterTranslator.DEFAULT_OPERATORS.numeric.includes(key as NumericOperator);\n  }\n\n  protected isArrayOperator(key: string): key is ArrayOperator {\n    return BaseFilterTranslator.DEFAULT_OPERATORS.array.includes(key as ArrayOperator);\n  }\n\n  protected isElementOperator(key: string): key is ElementOperator {\n    return BaseFilterTranslator.DEFAULT_OPERATORS.element.includes(key as ElementOperator);\n  }\n\n  protected isRegexOperator(key: string): key is RegexOperator {\n    return BaseFilterTranslator.DEFAULT_OPERATORS.regex.includes(key as RegexOperator);\n  }\n\n  protected isFieldOperator(key: string): key is QueryOperator {\n    return this.isOperator(key) && !this.isLogicalOperator(key);\n  }\n\n  protected isCustomOperator(key: string): boolean {\n    const support = this.getSupportedOperators();\n    return support.custom?.includes(key) ?? false;\n  }\n\n  protected getSupportedOperators(): OperatorSupport {\n    return BaseFilterTranslator.DEFAULT_OPERATORS;\n  }\n\n  protected isValidOperator(key: string): boolean {\n    const support = this.getSupportedOperators();\n    const allSupported = Object.values(support).flat();\n    return allSupported.includes(key as QueryOperator);\n  }\n\n  /**\n   * Value normalization for comparison operators\n   */\n  protected normalizeComparisonValue(value: any): any {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n\n    // Handle -0 case\n    if (typeof value === 'number' && Object.is(value, -0)) {\n      return 0;\n    }\n    return value;\n  }\n\n  /**\n   * Helper method to simulate $all operator using $and + $eq when needed.\n   * Some vector stores don't support $all natively.\n   */\n  protected simulateAllOperator(field: string, values: any[]): VectorFilter {\n    return {\n      $and: values.map(value => ({\n        [field]: { $in: [this.normalizeComparisonValue(value)] },\n      })),\n    };\n  }\n\n  /**\n   * Utility functions for type checking\n   */\n  protected isPrimitive(value: any): boolean {\n    return (\n      value === null ||\n      value === undefined ||\n      typeof value === 'string' ||\n      typeof value === 'number' ||\n      typeof value === 'boolean'\n    );\n  }\n\n  protected isRegex(value: any): boolean {\n    return value instanceof RegExp;\n  }\n\n  protected isEmpty(obj: any): boolean {\n    return obj === null || obj === undefined || (typeof obj === 'object' && Object.keys(obj).length === 0);\n  }\n\n  protected static readonly ErrorMessages = {\n    UNSUPPORTED_OPERATOR: (op: string) => `Unsupported operator: ${op}`,\n    INVALID_LOGICAL_OPERATOR_LOCATION: (op: string, path: string) =>\n      `Logical operator ${op} cannot be used at field level: ${path}`,\n    NOT_REQUIRES_OBJECT: `$not operator requires an object`,\n    NOT_CANNOT_BE_EMPTY: `$not operator cannot be empty`,\n    INVALID_LOGICAL_OPERATOR_CONTENT: (path: string) =>\n      `Logical operators must contain field conditions, not direct operators: ${path}`,\n    INVALID_TOP_LEVEL_OPERATOR: (op: string) => `Invalid top-level operator: ${op}`,\n    ELEM_MATCH_REQUIRES_OBJECT: `$elemMatch requires an object with conditions`,\n  } as const;\n\n  /**\n   * Helper to handle array value normalization consistently\n   */\n  protected normalizeArrayValues(values: any[]): any[] {\n    return values.map(value => this.normalizeComparisonValue(value));\n  }\n\n  protected validateFilter(filter: VectorFilter): void {\n    const validation = this.validateFilterSupport(filter);\n    if (!validation.supported) {\n      throw new Error(validation.messages.join(', '));\n    }\n  }\n\n  /**\n   * Validates if a filter structure is supported by the specific vector DB\n   * and returns detailed validation information.\n   */\n  private validateFilterSupport(\n    node: VectorFilter | FieldCondition,\n    path: string = '',\n  ): {\n    supported: boolean;\n    messages: string[];\n  } {\n    const messages: string[] = [];\n\n    // Handle primitives and empty values\n    if (this.isPrimitive(node) || this.isEmpty(node)) {\n      return { supported: true, messages: [] };\n    }\n\n    // Handle arrays\n    if (Array.isArray(node)) {\n      const arrayResults = node.map(item => this.validateFilterSupport(item, path));\n      const arrayMessages = arrayResults.flatMap(r => r.messages);\n      return {\n        supported: arrayResults.every(r => r.supported),\n        messages: arrayMessages,\n      };\n    }\n\n    // Process object entries\n    const nodeObj = node as Record<string, any>;\n    let isSupported = true;\n\n    for (const [key, value] of Object.entries(nodeObj)) {\n      const newPath = path ? `${path}.${key}` : key;\n      // Check if the key is an operator\n      if (this.isOperator(key)) {\n        if (!this.isValidOperator(key)) {\n          isSupported = false;\n          messages.push(BaseFilterTranslator.ErrorMessages.UNSUPPORTED_OPERATOR(key));\n          continue;\n        }\n\n        // Add check for non-logical operators at top level\n        if (!path && !this.isLogicalOperator(key)) {\n          isSupported = false;\n          messages.push(BaseFilterTranslator.ErrorMessages.INVALID_TOP_LEVEL_OPERATOR(key));\n          continue;\n        }\n\n        // In the translate method or wherever operators are handled\n        if (key === '$elemMatch' && (typeof value !== 'object' || Array.isArray(value))) {\n          isSupported = false;\n          messages.push(BaseFilterTranslator.ErrorMessages.ELEM_MATCH_REQUIRES_OBJECT);\n          continue;\n        }\n\n        // Special validation for logical operators\n        if (this.isLogicalOperator(key)) {\n          if (key === '$not') {\n            if (Array.isArray(value) || typeof value !== 'object') {\n              isSupported = false;\n              messages.push(BaseFilterTranslator.ErrorMessages.NOT_REQUIRES_OBJECT);\n              continue;\n            }\n            if (this.isEmpty(value)) {\n              isSupported = false;\n              messages.push(BaseFilterTranslator.ErrorMessages.NOT_CANNOT_BE_EMPTY);\n              continue;\n            }\n            // $not can be used at field level or top level\n            continue;\n          }\n          // Other logical operators can only be at top level or nested in logical operators\n          if (path && !this.isLogicalOperator(path.split('.').pop()!)) {\n            isSupported = false;\n            messages.push(BaseFilterTranslator.ErrorMessages.INVALID_LOGICAL_OPERATOR_LOCATION(key, newPath));\n            continue;\n          }\n\n          if (Array.isArray(value)) {\n            const hasDirectOperators = value.some(\n              item =>\n                typeof item === 'object' &&\n                Object.keys(item).length === 1 &&\n                this.isFieldOperator(Object.keys(item)[0]!),\n            );\n\n            if (hasDirectOperators) {\n              isSupported = false;\n              messages.push(BaseFilterTranslator.ErrorMessages.INVALID_LOGICAL_OPERATOR_CONTENT(newPath));\n              continue;\n            }\n          }\n        }\n      }\n\n      // Recursively validate nested value\n      const nestedValidation = this.validateFilterSupport(value, newPath);\n      if (!nestedValidation.supported) {\n        isSupported = false;\n        messages.push(...nestedValidation.messages);\n      }\n    }\n\n    return { supported: isSupported, messages };\n  }\n}\n\n// Export types and base class\nexport {\n  type QueryOperator,\n  type BasicOperator,\n  type NumericOperator,\n  type LogicalOperator,\n  type ArrayOperator,\n  type RegexOperator,\n  type ElementOperator,\n  type VectorFilter,\n  type FieldCondition,\n  type OperatorCondition,\n  type OperatorSupport,\n  BaseFilterTranslator,\n};\n"]}