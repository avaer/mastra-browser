{"version":3,"sources":["../src/telemetry/utility.ts","../src/telemetry/telemetry.decorators.ts","../src/telemetry/storage-exporter.ts","../src/telemetry/telemetry.ts"],"names":["trace","acc","context","otlpContext","SpanStatusCode","recordResult","propagation","wrappedFn"],"mappings":"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","file":"chunk-GCXZG37R.js","sourcesContent":["import { trace } from '@opentelemetry/api';\n\n// Helper function to check if telemetry is active\nexport function hasActiveTelemetry(tracerName: string = 'default-tracer'): boolean {\n  try {\n    return !!trace.getTracer(tracerName);\n  } catch {\n    return false;\n  }\n}\n","import { trace, context, SpanStatusCode, SpanKind, propagation } from '@opentelemetry/api';\n\nimport { hasActiveTelemetry } from './utility';\n\n// Decorator factory that takes optional spanName\nexport function withSpan(options: {\n  spanName?: string;\n  skipIfNoTelemetry?: boolean;\n  spanKind?: SpanKind;\n  tracerName?: string;\n}): any {\n  return function (_target: any, propertyKey: string | symbol, descriptor?: PropertyDescriptor | number) {\n    if (!descriptor || typeof descriptor === 'number') return;\n\n    const originalMethod = descriptor.value;\n    const methodName = String(propertyKey);\n\n    descriptor.value = function (...args: any[]) {\n      // Skip if no telemetry is available and skipIfNoTelemetry is true\n      if (options?.skipIfNoTelemetry && !hasActiveTelemetry(options?.tracerName)) {\n        return originalMethod.apply(this, args);\n      }\n\n      const tracer = trace.getTracer(options?.tracerName ?? 'default-tracer');\n\n      // Determine span name and kind\n      let spanName: string;\n      let spanKind: SpanKind | undefined;\n\n      if (typeof options === 'string') {\n        spanName = options;\n      } else if (options) {\n        spanName = options.spanName || methodName;\n        spanKind = options.spanKind;\n      } else {\n        spanName = methodName;\n      }\n\n      // Start the span with optional kind\n      const span = tracer.startSpan(spanName, { kind: spanKind });\n      let ctx = trace.setSpan(context.active(), span);\n\n      // Record input arguments as span attributes\n      args.forEach((arg, index) => {\n        try {\n          span.setAttribute(`${spanName}.argument.${index}`, JSON.stringify(arg));\n        } catch {\n          span.setAttribute(`${spanName}.argument.${index}`, '[Not Serializable]');\n        }\n      });\n\n      const currentBaggage = propagation.getBaggage(ctx);\n      // @ts-ignore\n      if (currentBaggage?.componentName) {\n        // @ts-ignore\n        span.setAttribute('componentName', currentBaggage?.componentName);\n        // @ts-ignore\n        span.setAttribute('runId', currentBaggage?.runId);\n        // @ts-ignore\n      } else if (this && this.name) {\n        // @ts-ignore\n        span.setAttribute('componentName', this.name);\n        // @ts-ignore\n        span.setAttribute('runId', this.runId);\n        // @ts-ignore\n        ctx = propagation.setBaggage(ctx, { componentName: this.name, runId: this.runId });\n      }\n\n      let result;\n      try {\n        // Call the original method within the context\n        result = context.with(ctx, () => originalMethod.apply(this, args));\n\n        // Handle promises\n        if (result instanceof Promise) {\n          return result\n            .then(resolvedValue => {\n              try {\n                span.setAttribute(`${spanName}.result`, JSON.stringify(resolvedValue));\n              } catch {\n                span.setAttribute(`${spanName}.result`, '[Not Serializable]');\n              }\n              return resolvedValue;\n            })\n            .finally(() => span.end());\n        }\n\n        // Record result for non-promise returns\n        try {\n          span.setAttribute(`${spanName}.result`, JSON.stringify(result));\n        } catch {\n          span.setAttribute(`${spanName}.result`, '[Not Serializable]');\n        }\n\n        // Return regular results\n        return result;\n      } catch (error) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: error instanceof Error ? error.message : 'Unknown error',\n        });\n        if (error instanceof Error) {\n          span.recordException(error);\n        }\n        throw error;\n      } finally {\n        // End span for non-promise returns\n        if (!(result instanceof Promise)) {\n          span.end();\n        }\n      }\n    };\n\n    return descriptor;\n  };\n}\n\n// class-telemetry.decorator.ts\nexport function InstrumentClass(options?: {\n  prefix?: string;\n  spanKind?: SpanKind;\n  excludeMethods?: string[];\n  methodFilter?: (methodName: string) => boolean;\n  tracerName?: string;\n}) {\n  return function (target: any) {\n    const methods = Object.getOwnPropertyNames(target.prototype);\n\n    methods.forEach(method => {\n      // Skip excluded methods\n      if (options?.excludeMethods?.includes(method) || method === 'constructor') return;\n      // Apply method filter if provided\n      if (options?.methodFilter && !options.methodFilter(method)) return;\n\n      const descriptor = Object.getOwnPropertyDescriptor(target.prototype, method);\n      if (descriptor && typeof descriptor.value === 'function') {\n        Object.defineProperty(\n          target.prototype,\n          method,\n          withSpan({\n            spanName: options?.prefix ? `${options.prefix}.${method}` : method,\n            skipIfNoTelemetry: true,\n            spanKind: options?.spanKind || SpanKind.INTERNAL,\n            tracerName: options?.tracerName,\n          })(target, method, descriptor),\n        );\n      }\n    });\n\n    return target;\n  };\n}\n","import { ExportResultCode } from '@opentelemetry/core';\nimport type { ExportResult } from '@opentelemetry/core';\nimport { JsonTraceSerializer } from '@opentelemetry/otlp-transformer';\nimport type { ReadableSpan, SpanExporter } from '@opentelemetry/sdk-trace-base';\n\nimport type { Logger } from '../logger';\nimport type { MastraStorage } from '../storage/base';\nimport { TABLE_TRACES } from '../storage/constants';\n\nexport class OTLPTraceExporter implements SpanExporter {\n  private storage: MastraStorage;\n  private queue: { data: any[]; resultCallback: (result: ExportResult) => void }[] = [];\n  private serializer: typeof JsonTraceSerializer;\n  private logger: Logger;\n  private activeFlush: Promise<void> | undefined = undefined;\n\n  constructor({ logger, storage }: { logger: Logger; storage: MastraStorage }) {\n    this.storage = storage;\n    this.serializer = JsonTraceSerializer;\n    this.logger = logger;\n  }\n\n  export(internalRepresentation: ReadableSpan[], resultCallback: (result: ExportResult) => void): void {\n    const serializedRequest = this.serializer.serializeRequest(internalRepresentation);\n    // @ts-ignore\n    const payload = JSON.parse(Buffer.from(serializedRequest.buffer, 'utf8'));\n    const items = payload?.resourceSpans?.[0]?.scopeSpans;\n    this.logger.debug(`Exporting telemetry: ${items.length} scope spans to be processed [trace batch]`);\n\n    this.queue.push({ data: items, resultCallback });\n\n    if (!this.activeFlush) {\n      this.activeFlush = this.flush();\n    }\n  }\n  shutdown(): Promise<void> {\n    return this.forceFlush();\n  }\n\n  flush(): Promise<void> {\n    const now = new Date();\n    const items = this.queue.shift();\n    if (!items) return Promise.resolve();\n\n    const allSpans: any[] = items.data.reduce((acc, scopedSpans) => {\n      const { scope, spans } = scopedSpans;\n      for (const span of spans) {\n        const {\n          spanId,\n          parentSpanId,\n          traceId,\n          name,\n          kind,\n          attributes,\n          status,\n          events,\n          links,\n          startTimeUnixNano,\n          endTimeUnixNano,\n          ...rest\n        } = span;\n\n        const startTime = Number(BigInt(startTimeUnixNano) / 1000n);\n        const endTime = Number(BigInt(endTimeUnixNano) / 1000n);\n\n        acc.push({\n          id: spanId,\n          parentSpanId,\n          traceId,\n          name,\n          scope: scope.name,\n          kind,\n          status: JSON.stringify(status),\n          events: JSON.stringify(events),\n          links: JSON.stringify(links),\n          attributes: JSON.stringify(\n            attributes.reduce((acc: Record<string, any>, attr: any) => {\n              const valueKey = Object.keys(attr.value)[0];\n              if (valueKey) {\n                acc[attr.key] = attr.value[valueKey];\n              }\n              return acc;\n            }, {}),\n          ),\n          startTime,\n          endTime,\n          other: JSON.stringify(rest),\n          createdAt: now,\n        });\n      }\n      return acc;\n    }, []);\n\n    return this.storage\n      .__batchInsert({\n        tableName: TABLE_TRACES,\n        records: allSpans,\n      })\n      .then(() => {\n        items.resultCallback({\n          code: ExportResultCode.SUCCESS,\n        });\n      })\n      .catch(e => {\n        this.logger.error('span err:' + e?.message);\n        items.resultCallback({\n          code: ExportResultCode.FAILED,\n          error: e,\n        });\n      })\n      .finally(() => {\n        this.activeFlush = undefined;\n      });\n  }\n  async forceFlush(): Promise<void> {\n    if (!this.queue.length) {\n      return;\n    }\n\n    await this.activeFlush;\n    while (this.queue.length) {\n      await this.flush();\n    }\n  }\n\n  __setLogger(logger: Logger) {\n    this.logger = logger;\n  }\n}\n","import { context as otlpContext, SpanStatusCode, trace, propagation, context } from '@opentelemetry/api';\nimport type { Tracer, SpanOptions, Context, Span } from '@opentelemetry/api';\n\nimport type { OtelConfig } from './types';\nimport { hasActiveTelemetry } from './utility';\n\nlet __TELEMETRY__: Telemetry | undefined;\n\nexport class Telemetry {\n  public tracer: Tracer = trace.getTracer('default');\n  name: string = 'default-service';\n\n  private constructor(config: OtelConfig) {\n    this.name = config.serviceName ?? 'default-service';\n\n    this.tracer = trace.getTracer(this.name);\n  }\n\n  /**\n   * @deprecated This method does not do anything\n   */\n  public async shutdown() {}\n\n  /**\n   * Initialize telemetry with the given configuration\n   * @param config - Optional telemetry configuration object\n   * @returns Telemetry instance that can be used for tracing\n   */\n  static init(config: OtelConfig = {}): Telemetry {\n    try {\n      if (!__TELEMETRY__) {\n        __TELEMETRY__ = new Telemetry(config);\n      }\n\n      return __TELEMETRY__;\n    } catch (error) {\n      console.error('Failed to initialize telemetry:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get the global telemetry instance\n   * @throws {Error} If telemetry has not been initialized\n   * @returns {Telemetry} The global telemetry instance\n   */\n  static get(): Telemetry {\n    if (!__TELEMETRY__) {\n      throw new Error('Telemetry not initialized');\n    }\n    return __TELEMETRY__;\n  }\n\n  /**\n   * Wraps a class instance with telemetry tracing\n   * @param instance The class instance to wrap\n   * @param options Optional configuration for tracing\n   * @returns Wrapped instance with all methods traced\n   */\n  traceClass<T extends object>(\n    instance: T,\n    options: {\n      /** Base name for spans (e.g. 'integration', 'agent') */\n      spanNamePrefix?: string;\n      /** Additional attributes to add to all spans */\n      attributes?: Record<string, string>;\n      /** Methods to exclude from tracing */\n      excludeMethods?: string[];\n      /** Skip tracing if telemetry is not active */\n      skipIfNoTelemetry?: boolean;\n    } = {},\n  ): T {\n    const { skipIfNoTelemetry = true } = options;\n\n    // Skip if no telemetry is active and skipIfNoTelemetry is true\n    if (skipIfNoTelemetry && !hasActiveTelemetry()) {\n      return instance;\n    }\n\n    const { spanNamePrefix = instance.constructor.name.toLowerCase(), attributes = {}, excludeMethods = [] } = options;\n\n    return new Proxy(instance, {\n      get: (target, prop: string | symbol) => {\n        const value = target[prop as keyof T];\n\n        // Skip tracing for excluded methods, constructors, private methods\n        if (\n          typeof value === 'function' &&\n          prop !== 'constructor' &&\n          !prop.toString().startsWith('_') &&\n          !excludeMethods.includes(prop.toString())\n        ) {\n          return this.traceMethod(value.bind(target), {\n            spanName: `${spanNamePrefix}.${prop.toString()}`,\n            attributes: {\n              ...attributes,\n              [`${spanNamePrefix}.name`]: target.constructor.name,\n              [`${spanNamePrefix}.method.name`]: prop.toString(),\n            },\n          });\n        }\n\n        return value;\n      },\n    });\n  }\n\n  /**\n   * method to trace individual methods with proper context\n   * @param method The method to trace\n   * @param context Additional context for the trace\n   * @returns Wrapped method with tracing\n   */\n  traceMethod<TMethod extends Function>(\n    method: TMethod,\n    context: {\n      spanName: string;\n      attributes?: Record<string, string>;\n      skipIfNoTelemetry?: boolean;\n      parentSpan?: Span;\n    },\n  ): TMethod {\n    let ctx = otlpContext.active();\n    const { skipIfNoTelemetry = true } = context;\n\n    // Skip if no telemetry is active and skipIfNoTelemetry is true\n    if (skipIfNoTelemetry && !hasActiveTelemetry()) {\n      return method;\n    }\n\n    return ((...args: unknown[]) => {\n      const span = this.tracer.startSpan(context.spanName);\n\n      function handleError(error: unknown) {\n        span.recordException(error as Error);\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: (error as Error).message,\n        });\n        span.end();\n        throw error;\n      }\n      try {\n        // Add all context attributes to span\n        if (context.attributes) {\n          span.setAttributes(context.attributes);\n        }\n\n        if (context.attributes?.componentName) {\n          // @ts-ignore\n          ctx = propagation.setBaggage(ctx, {\n            // @ts-ignore\n            componentName: context.attributes.componentName,\n            runId: context.attributes.runId,\n          });\n        } else {\n          // @ts-ignore\n          const currentBaggage = propagation.getBaggage(ctx);\n          // @ts-ignore\n          if (currentBaggage?.componentName) {\n            // @ts-ignore\n            span.setAttribute('componentName', currentBaggage?.componentName);\n            // @ts-ignore\n            span.setAttribute('runId', currentBaggage?.runId);\n            // @ts-ignore\n          } else if (this && this.name) {\n            // @ts-ignore\n            span.setAttribute('componentName', this.name);\n            // @ts-ignore\n            span.setAttribute('runId', this.runId);\n            // @ts-ignore\n            ctx = propagation.setBaggage(ctx, { componentName: this.name, runId: this.runId });\n          }\n        }\n\n        // Record input arguments as span attributes\n        args.forEach((arg, index) => {\n          try {\n            span.setAttribute(`${context.spanName}.argument.${index}`, JSON.stringify(arg));\n          } catch {\n            span.setAttribute(`${context.spanName}.argument.${index}`, '[Not Serializable]');\n          }\n        });\n\n        let result: any;\n        otlpContext.with(trace.setSpan(ctx, span), () => {\n          result = method(...args);\n        });\n\n        function recordResult(res: any) {\n          try {\n            span.setAttribute(`${context.spanName}.result`, JSON.stringify(res));\n          } catch {\n            span.setAttribute(`${context.spanName}.result`, '[Not Serializable]');\n          }\n\n          span.end();\n\n          return res;\n        }\n\n        if (result instanceof Promise) {\n          return result.then(recordResult).catch(handleError);\n        } else {\n          return recordResult(result);\n        }\n      } catch (error) {\n        handleError(error);\n      }\n    }) as unknown as TMethod;\n  }\n\n  getBaggageTracer(): Tracer {\n    return new BaggageTracer(this.tracer);\n  }\n}\n\nclass BaggageTracer implements Tracer {\n  private _tracer: Tracer;\n\n  constructor(tracer: Tracer) {\n    this._tracer = tracer;\n  }\n\n  startSpan(name: string, options: SpanOptions = {}, ctx: Context) {\n    ctx = ctx ?? otlpContext.active();\n    const span = this._tracer.startSpan(name, options, ctx);\n    const currentBaggage = propagation.getBaggage(ctx);\n    // @ts-ignore\n    span.setAttribute('componentName', currentBaggage?.componentName);\n    // @ts-ignore\n    span.setAttribute('runId', currentBaggage?.runId);\n\n    return span;\n  }\n\n  startActiveSpan<F extends (span: Span) => unknown>(name: string, fn: F): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => unknown>(name: string, options: SpanOptions, fn: F): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => unknown>(\n    name: string,\n    options: SpanOptions,\n    ctx: Context,\n    fn: F,\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => unknown>(\n    name: string,\n    optionsOrFn: SpanOptions | F,\n    ctxOrFn?: Context | F,\n    fn?: F,\n  ): ReturnType<F> {\n    if (typeof optionsOrFn === 'function') {\n      const wrappedFn = (span: Span) => {\n        const currentBaggage = propagation.getBaggage(otlpContext.active());\n        // @ts-ignore\n        span.setAttribute('componentName', currentBaggage?.componentName);\n\n        return optionsOrFn(span);\n      };\n      return this._tracer.startActiveSpan(name, {}, context.active(), wrappedFn as F);\n    }\n    if (typeof ctxOrFn === 'function') {\n      const wrappedFn = (span: Span) => {\n        const currentBaggage = propagation.getBaggage(otlpContext.active());\n        // @ts-ignore\n        span.setAttribute('componentName', currentBaggage?.componentName);\n\n        return ctxOrFn(span);\n      };\n      return this._tracer.startActiveSpan(name, optionsOrFn, context.active(), wrappedFn as F);\n    }\n    const wrappedFn = (span: Span) => {\n      const currentBaggage = propagation.getBaggage(ctxOrFn ?? otlpContext.active());\n      // @ts-ignore\n      span.setAttribute('componentName', currentBaggage?.componentName);\n\n      return fn!(span);\n    };\n    return this._tracer.startActiveSpan(name, optionsOrFn, ctxOrFn!, wrappedFn as F);\n  }\n}\n"]}