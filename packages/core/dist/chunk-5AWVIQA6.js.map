{"version":3,"sources":["../src/vector/pglite/filter.ts","../src/vector/pglite/sql-builder.ts","../src/vector/pglite/index.ts","../src/memory/memory.ts"],"names":["result","traverse","conditions","operator","operatorValue","vector","messages","chatMessages"],"mappings":"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","file":"chunk-5AWVIQA6.js","sourcesContent":["import { BaseFilterTranslator } from '../filter';\nimport type { FieldCondition, VectorFilter, OperatorSupport } from '../filter';\n\n/**\n * Translates MongoDB-style filters to PGlite compatible filters for use with pgvector.\n */\nexport class PGliteFilterTranslator extends BaseFilterTranslator {\n  protected override getSupportedOperators(): OperatorSupport {\n    return {\n      ...BaseFilterTranslator.DEFAULT_OPERATORS,\n      regex: [],\n      custom: ['$contains', '$size'],\n    };\n  }\n\n  translate(filter?: VectorFilter): VectorFilter {\n    if (this.isEmpty(filter)) {\n      return filter;\n    }\n    this.validateFilter(filter);\n    return this.translateNode(filter);\n  }\n\n  private translateNode(node: VectorFilter | FieldCondition, currentPath: string = ''): any {\n    if (this.isRegex(node)) {\n      throw new Error('Direct regex pattern format is not supported in PGlite');\n    }\n    // Helper to wrap result with path if needed\n    const withPath = (result: any) => (currentPath ? { [currentPath]: result } : result);\n\n    // Handle primitives\n    if (this.isPrimitive(node)) {\n      return withPath({ $eq: this.normalizeComparisonValue(node) });\n    }\n\n    // Handle arrays\n    if (Array.isArray(node)) {\n      return withPath({ $in: this.normalizeArrayValues(node) });\n    }\n\n    const entries = Object.entries(node as Record<string, any>);\n    const result: Record<string, any> = {};\n\n    // Process remaining entries\n    for (const [key, value] of entries) {\n      const newPath = currentPath ? `${currentPath}.${key}` : key;\n\n      if (this.isLogicalOperator(key)) {\n        result[key] = Array.isArray(value)\n          ? value.map((filter: VectorFilter) => this.translateNode(filter))\n          : this.translateNode(value);\n      } else if (this.isOperator(key)) {\n        if (this.isArrayOperator(key) && !Array.isArray(value) && key !== '$elemMatch') {\n          result[key] = [value];\n        } else if (this.isBasicOperator(key) && Array.isArray(value)) {\n          result[key] = JSON.stringify(value);\n        } else {\n          result[key] = value;\n        }\n      } else if (typeof value === 'object' && value !== null) {\n        // Handle nested objects\n        const hasOperators = Object.keys(value).some(k => this.isOperator(k));\n        if (hasOperators) {\n          result[newPath] = this.translateNode(value);\n        } else {\n          Object.assign(result, this.translateNode(value, newPath));\n        }\n      } else {\n        result[newPath] = this.translateNode(value);\n      }\n    }\n\n    return result;\n  }\n}\n","import type {\n  BasicOperator,\n  NumericOperator,\n  ArrayOperator,\n  ElementOperator,\n  LogicalOperator,\n  RegexOperator,\n  VectorFilter,\n} from '../filter';\n\nexport type OperatorType =\n  | BasicOperator\n  | NumericOperator\n  | ArrayOperator\n  | ElementOperator\n  | LogicalOperator\n  | '$contains'\n  | Exclude<RegexOperator, '$options'>;\n\ntype FilterOperator = {\n  sql: string;\n  needsValue: boolean;\n  transformValue?: (value: any) => any;\n};\n\ntype OperatorFn = (key: string, value?: any) => FilterOperator;\n\n// Helper functions to create operators\nconst createBasicOperator = (symbol: string) => {\n  return (key: string): FilterOperator => ({\n    sql: `CASE \n      WHEN $1 IS NULL THEN metadata->>'${handleKey(key)}' IS ${symbol === '=' ? '' : 'NOT'} NULL\n      ELSE metadata->>'${handleKey(key)}' ${symbol} $1\n    END`,\n    needsValue: true,\n  });\n};\nconst createNumericOperator = (symbol: string) => {\n  return (key: string): FilterOperator => ({\n    sql: `CAST(metadata->>'${handleKey(key)}' AS NUMERIC) ${symbol} $1`,\n    needsValue: true,\n  });\n};\n\nconst validateJsonArray = (key: string) =>\n  `jsonb_typeof(metadata->'${handleKey(key)}') = 'array'`;\n\n// Define all filter operators\nexport const FILTER_OPERATORS: Record<string, OperatorFn> = {\n  $eq: createBasicOperator('='),\n  $ne: createBasicOperator('!='),\n  $gt: createNumericOperator('>'),\n  $gte: createNumericOperator('>='),\n  $lt: createNumericOperator('<'),\n  $lte: createNumericOperator('<='),\n\n  // Array Operators\n  $in: (key: string, value: any) => ({\n    sql: `metadata->>'${handleKey(key)}' IN (${value.map((_: any, i: number) => `$${i + 1}`).join(',')})`,\n    needsValue: true,\n  }),\n\n  $nin: (key: string, value: any) => ({\n    sql: `metadata->>'${handleKey(key)}' NOT IN (${value.map((_: any, i: number) => `$${i + 1}`).join(',')})`,\n    needsValue: true,\n  }),\n  $all: (key: string) => ({\n    sql: `metadata->>'${handleKey(key)}' = $1`,\n    needsValue: true,\n    transformValue: (value: any) => {\n      const arrayValue = Array.isArray(value) ? value : [value];\n      if (arrayValue.length === 0) {\n        return {\n          sql: '1 = 0',\n          values: [],\n        };\n      }\n\n      return {\n        sql: `(\n          CASE\n            WHEN ${validateJsonArray(key)} THEN\n                NOT EXISTS (\n                    SELECT value \n                    FROM jsonb_array_elements_text($1::jsonb) \n                    WHERE value::text NOT IN (\n                    SELECT value::text \n                    FROM jsonb_array_elements_text(metadata->'${handleKey(key)}')\n                )\n            )\n            ELSE FALSE\n          END\n        )`,\n        values: [JSON.stringify(arrayValue)],\n      };\n    },\n  }),\n  $elemMatch: (key: string) => ({\n    sql: `metadata->>'${handleKey(key)}' = $1`,\n    needsValue: true,\n    transformValue: (value: any) => {\n      if (typeof value !== 'object' || Array.isArray(value)) {\n        throw new Error('$elemMatch requires an object with conditions');\n      }\n\n      // For nested object conditions\n      const conditions = Object.entries(value).map(([field, fieldValue]) => {\n        if (field.startsWith('$')) {\n          // Direct operators on array elements ($in, $gt, etc)\n          const { sql, values } = buildCondition('elem.value', { [field]: fieldValue }, '');\n          // Replace the metadata path with elem.value\n          const pattern = /metadata->>'[^']*'/g;\n          const elemSql = sql.replace(pattern, 'elem.value');\n          return { sql: elemSql, values };\n        } else if (typeof fieldValue === 'object' && !Array.isArray(fieldValue)) {\n          // Nested field with operators (count: { $gt: 20 })\n          const { sql, values } = buildCondition(field, fieldValue, '');\n          // Replace the field path with elem.value path\n          const pattern = /metadata->>'[^']*'/g;\n          const elemSql = sql.replace(pattern, `elem.value->>'${field}'`);\n          return { sql: elemSql, values };\n        } else {\n          // Simple field equality (warehouse: 'A')\n          return {\n            sql: `elem.value->>'${field}' = $1`,\n            values: [fieldValue],\n          };\n        }\n      });\n\n      return {\n        sql: `(\n          CASE\n            WHEN ${validateJsonArray(key)} THEN\n              EXISTS (\n                SELECT 1 \n                FROM jsonb_array_elements(metadata->'${handleKey(key)}') as elem\n                WHERE ${conditions.map(c => c.sql).join(' AND ')}\n              )\n            ELSE FALSE\n          END\n        )`,\n        values: conditions.flatMap(c => c.values),\n      };\n    },\n  }),\n\n  // Element Operators\n  $exists: (key: string) => ({\n    sql: `metadata ? '${handleKey(key)}'`,\n    needsValue: false,\n  }),\n\n  // Logical Operators\n  $and: (key: string) => ({\n    sql: `(${key})`,\n    needsValue: false,\n  }),\n  $or: (key: string) => ({\n    sql: `(${key})`,\n    needsValue: false,\n  }),\n  $not: key => ({ sql: `NOT (${key})`, needsValue: false }),\n  $nor: (key: string) => ({\n    sql: `NOT (${key})`,\n    needsValue: false,\n  }),\n  $size: (key: string) => ({\n    sql: `(\n    CASE\n      WHEN jsonb_typeof(metadata->'${handleKey(key)}') = 'array' THEN \n        jsonb_array_length(metadata->'${handleKey(key)}') = $1\n      ELSE FALSE\n    END\n  )`,\n    needsValue: true,\n  }),\n  $contains: (key: string) => ({\n    sql: `metadata->>'${handleKey(key)}' = $1`,\n    needsValue: true,\n    transformValue: (value: any) => {\n      // Array containment\n      if (Array.isArray(value)) {\n        return {\n          sql: `(\n            SELECT ${validateJsonArray(key)}\n            AND EXISTS (\n              SELECT 1 \n              FROM jsonb_array_elements(metadata->'${handleKey(key)}') as m\n              WHERE m.value IN (SELECT value FROM jsonb_array_elements($1::jsonb))\n            )\n          )`,\n          values: [JSON.stringify(value)],\n        };\n      }\n\n      // Nested object traversal\n      if (value && typeof value === 'object') {\n        const paths: string[] = [];\n        const values: any[] = [];\n\n        function traverse(obj: any, path: string[] = []) {\n          for (const [k, v] of Object.entries(obj)) {\n            const currentPath = [...path, k];\n            if (v && typeof v === 'object' && !Array.isArray(v)) {\n              traverse(v, currentPath);\n            } else {\n              paths.push(currentPath.join('->'));\n              values.push(v);\n            }\n          }\n        }\n\n        traverse(value);\n        return {\n          sql: `(${paths.map((path, i) => `metadata->'${handleKey(key)}'->>'${path}' = $${i + 1}`).join(' AND ')})`,\n          values,\n        };\n      }\n\n      return value;\n    },\n  }),\n};\n\nexport interface FilterResult {\n  sql: string;\n  values: any[];\n}\n\nexport const handleKey = (key: string) => {\n  return key.replace(/\\./g, '->>');\n};\n\nexport function buildFilterQuery(filter: VectorFilter): FilterResult {\n  if (!filter) {\n    return { sql: '', values: [] };\n  }\n\n  const values: any[] = [];\n  const conditions = Object.entries(filter)\n    .map(([key, value]) => {\n      const condition = buildCondition(key, value, '');\n      values.push(...condition.values);\n      return condition.sql;\n    })\n    .join(' AND ');\n\n  return {\n    sql: conditions ? `WHERE ${conditions}` : '',\n    values,\n  };\n}\n\nfunction buildCondition(key: string, value: any, parentPath: string): FilterResult {\n  // Handle logical operators ($and/$or)\n  if (['$and', '$or', '$not', '$nor'].includes(key)) {\n    return handleLogicalOperator(key as '$and' | '$or' | '$not' | '$nor', value, parentPath);\n  }\n\n  // If condition is not a FilterCondition object, assume it's an equality check\n  if (!value || typeof value !== 'object') {\n    return {\n      sql: `metadata->>'${key}' = $1`,\n      values: [value],\n    };\n  }\n\n  // Handle operator conditions\n  return handleOperator(key, value);\n}\n\nfunction handleLogicalOperator(\n  key: '$and' | '$or' | '$not' | '$nor',\n  value: VectorFilter[] | VectorFilter,\n  parentPath: string,\n): FilterResult {\n  // Handle empty conditions\n  if (!value || value.length === 0) {\n    switch (key) {\n      case '$and':\n      case '$nor':\n        return { sql: 'true', values: [] };\n      case '$or':\n        return { sql: 'false', values: [] };\n      case '$not':\n        throw new Error('$not operator cannot be empty');\n      default:\n        return { sql: 'true', values: [] };\n    }\n  }\n\n  if (key === '$not') {\n    // For top-level $not\n    const entries = Object.entries(value);\n    const conditions = entries.map(([fieldKey, fieldValue]) => buildCondition(fieldKey, fieldValue, key));\n    return {\n      sql: `NOT (${conditions.map(c => c.sql).join(' AND ')})`,\n      values: conditions.flatMap(c => c.values),\n    };\n  }\n\n  const values: any[] = [];\n  const joinOperator = key === '$or' || key === '$nor' ? 'OR' : 'AND';\n  const conditions = Array.isArray(value)\n    ? value.map(f => {\n        const entries = Object.entries(f);\n        return entries.map(([k, v]) => buildCondition(k, v, key));\n      })\n    : [buildCondition(key, value, parentPath)];\n\n  const joined = conditions\n    .flat()\n    .map(c => {\n      values.push(...c.values);\n      return c.sql;\n    })\n    .join(` ${joinOperator} `);\n\n  return {\n    sql: key === '$nor' ? `NOT (${joined})` : `(${joined})`,\n    values,\n  };\n}\n\nfunction handleOperator(key: string, value: any): FilterResult {\n  if (typeof value === 'object' && !Array.isArray(value)) {\n    const entries = Object.entries(value);\n    const results = entries.map(([operator, operatorValue]) =>\n      operator === '$not'\n        ? {\n            sql: `NOT (${Object.entries(operatorValue as Record<string, any>)\n              .map(([op, val]) => processOperator(key, op, val).sql)\n              .join(' AND ')})`,\n            values: Object.entries(operatorValue as Record<string, any>).flatMap(\n              ([op, val]) => processOperator(key, op, val).values,\n            ),\n          }\n        : processOperator(key, operator, operatorValue),\n    );\n\n    return {\n      sql: `(${results.map(r => r.sql).join(' AND ')})`,\n      values: results.flatMap(r => r.values),\n    };\n  }\n\n  // Handle single operator\n  const [[operator, operatorValue] = []] = Object.entries(value);\n  return processOperator(key, operator as string, operatorValue);\n}\n\nconst processOperator = (key: string, operator: string, operatorValue: any): FilterResult => {\n  if (!operator.startsWith('$') || !FILTER_OPERATORS[operator]) {\n    throw new Error(`Invalid operator: ${operator}`);\n  }\n  const operatorFn = FILTER_OPERATORS[operator]!;\n  const operatorResult = operatorFn(key, operatorValue);\n\n  if (!operatorResult.needsValue) {\n    return { sql: operatorResult.sql, values: [] };\n  }\n\n  const transformed = operatorResult.transformValue ? operatorResult.transformValue(operatorValue) : operatorValue;\n\n  if (transformed && typeof transformed === 'object' && 'sql' in transformed) {\n    return transformed;\n  }\n\n  return {\n    sql: operatorResult.sql,\n    values: Array.isArray(transformed) ? transformed : [transformed],\n  };\n};\n","import { join, resolve, isAbsolute } from 'path';\nimport { PGlite } from '@electric-sql/pglite';\nimport { MemoryFS } from '@electric-sql/pglite';\nimport { vector } from '@electric-sql/pglite/vector';\n\nimport type { VectorFilter } from '../filter';\nimport { MastraVector } from '../index';\nimport type {\n  CreateIndexParams,\n  IndexStats,\n  QueryVectorParams,\n  QueryResult,\n  UpsertVectorParams,\n  ParamsToArgs,\n  QueryVectorArgs,\n} from '../index';\n\nimport { PGliteFilterTranslator } from './filter';\nimport { buildFilterQuery } from './sql-builder';\n\ninterface PGliteQueryParams extends QueryVectorParams {\n  minScore?: number;\n}\n\ntype PGliteQueryArgs = [...QueryVectorArgs, number?];\n\nexport class PGliteVector extends MastraVector {\n  private client: PGlite | null = null;\n  private clientPromise: Promise<PGlite> | null = null;\n\n  constructor({\n    connectionUrl,\n    authToken,\n    syncUrl,\n    syncInterval,\n  }: {\n    connectionUrl: string;\n    authToken?: string;\n    syncUrl?: string;\n    syncInterval?: number;\n  }) {\n    super();\n\n    this.clientPromise = this.initClient(connectionUrl);\n  }\n\n  private async initClient(connectionUrl: string): Promise<PGlite> {\n    try {\n      const client = await PGlite.create(this.rewriteDbUrl(connectionUrl), {\n        fs: new MemoryFS(),\n        extensions: {\n          vector, // Enable pgvector support\n        },\n      });\n      this.client = client;\n      return client;\n    } catch (error) {\n      this.logger.error(`Error initializing PGlite client: ${error}`);\n      throw error;\n    }\n  }\n\n  // If we're in the .mastra/output directory, use the dir outside .mastra dir\n  protected rewriteDbUrl(url: string): string {\n    if (url.startsWith('file:') && url !== 'file::memory:') {\n      const pathPart = url.slice('file:'.length);\n\n      if (isAbsolute(pathPart)) {\n        return url;\n      }\n\n      const cwd = process.cwd();\n\n      if (cwd.includes('.mastra') && (cwd.endsWith(`output`) || cwd.endsWith(`output/`) || cwd.endsWith(`output\\\\`))) {\n        const baseDir = join(cwd, `..`, `..`); // <- .mastra/output/../../\n\n        const fullPath = resolve(baseDir, pathPart);\n\n        this.logger.debug(\n          `Initializing PGlite db with url ${url} with relative file path from inside .mastra/output directory. Rewriting relative file url to \"file:${fullPath}\". This ensures it's outside the .mastra/output directory.`,\n        );\n\n        return `file:${fullPath}`;\n      }\n    }\n\n    return url;\n  }\n\n  private async getClient(): Promise<PGlite> {\n    if (!this.client && this.clientPromise) {\n      this.client = await this.clientPromise;\n    }\n    if (!this.client) {\n      throw new Error('PGlite client not initialized');\n    }\n    return this.client;\n  }\n\n  transformFilter(filter?: VectorFilter) {\n    const translator = new PGliteFilterTranslator();\n    return translator.translate(filter);\n  }\n\n  async query(...args: ParamsToArgs<PGliteQueryParams> | PGliteQueryArgs): Promise<QueryResult[]> {\n    const params = this.normalizeArgs<PGliteQueryParams, PGliteQueryArgs>('query', args, ['minScore']);\n\n    try {\n      const { indexName, queryVector, topK = 10, filter, includeVector = false, minScore = 0 } = params;\n      const client = await this.getClient();\n\n      // Convert JavaScript array to vector literal\n      const vectorLiteral = `[${queryVector.join(',')}]`;\n\n      const translatedFilter = this.transformFilter(filter);\n      const { sql: filterQuery, values: filterValues } = buildFilterQuery(translatedFilter);\n      \n      // Start parameter index where filter values left off\n      const scoreParamIndex = filterValues.length + 1;\n      const queryParams = [...filterValues, minScore];\n\n      const query = `\n        WITH vector_scores AS (\n          SELECT\n            vector_id as id,\n            1 - (embedding <=> '${vectorLiteral}'::vector) as score,\n            metadata\n            ${includeVector ? ', embedding::float4[] as vector' : ''}\n          FROM ${indexName}\n          ${filterQuery}\n        )\n        SELECT *\n        FROM vector_scores\n        WHERE score > $${scoreParamIndex}\n        ORDER BY score DESC\n        LIMIT ${topK}`;\n\n      const result = await client.query(query, queryParams);\n\n      return (result.rows || []).map((row: any) => {\n        const { id, score, metadata, vector } = row;\n        return {\n          id: id as string,\n          score: score as number,\n          metadata: typeof metadata === 'string' ? JSON.parse(metadata) : metadata,\n          ...(includeVector && vector && { vector: vector as number[] }),\n        };\n      });\n    } catch (error) {\n      this.logger.error(`Error querying vectors: ${error}`);\n      throw error;\n    }\n  }\n\n  async upsert(...args: ParamsToArgs<UpsertVectorParams>): Promise<string[]> {\n    const params = this.normalizeArgs<UpsertVectorParams>('upsert', args);\n    const { indexName, vectors, metadata, ids } = params;\n    const client = await this.getClient();\n\n    try {\n      const vectorIds = ids || vectors.map(() => crypto.randomUUID());\n      \n      await client.transaction(async (tx) => {\n        for (let i = 0; i < vectors.length; i++) {\n          // Use non-null assertion as we know vectors[i] exists within the bounds of the loop\n          const vectorLiteral = `[${vectors[i]!.join(',')}]`;\n          const metadataJson = JSON.stringify(metadata?.[i] || {});\n          \n          await tx.query(\n            `INSERT INTO ${indexName} (vector_id, embedding, metadata)\n            VALUES ($1, $2::vector, $3::jsonb)\n            ON CONFLICT(vector_id) DO UPDATE SET\n              embedding = $2::vector,\n              metadata = $3::jsonb`,\n            [vectorIds[i]!, vectorLiteral, metadataJson]\n          );\n        }\n      });\n\n      return vectorIds;\n    } catch (error) {\n      this.logger.error(`Error upserting vectors: ${error}`);\n      throw error;\n    }\n  }\n\n  async createIndex(...args: ParamsToArgs<CreateIndexParams>): Promise<void> {\n    const params = this.normalizeArgs<CreateIndexParams>('createIndex', args);\n\n    const { indexName, dimension, metric = 'cosine' } = params;\n    try {\n      // Validate inputs\n      if (!indexName.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/)) {\n        throw new Error('Invalid index name format');\n      }\n      if (!Number.isInteger(dimension) || dimension <= 0) {\n        throw new Error('Dimension must be a positive integer');\n      }\n\n      const client = await this.getClient();\n\n      // Create the table using the pgvector extension\n      // PG syntax: vector(dimension) vs SQLite syntax: F32_BLOB(dimension)\n      await client.query(`\n        CREATE TABLE IF NOT EXISTS ${indexName} (\n          id SERIAL PRIMARY KEY,\n          vector_id TEXT UNIQUE NOT NULL,\n          embedding vector(${dimension}) NOT NULL,\n          metadata JSONB DEFAULT '{}'::jsonb\n        )\n      `);\n\n      // Create an appropriate index based on the metric\n      // The index operators differ by distance metric\n      let operator = '';\n      switch (metric) {\n        case 'cosine':\n          operator = 'vector_cosine_ops';\n          break;\n        case 'euclidean':\n          operator = 'vector_l2_ops';\n          break;\n        case 'dotproduct':\n          operator = 'vector_ip_ops';\n          break;\n        default:\n          operator = 'vector_cosine_ops'; // Default to cosine\n      }\n\n      // Create a vector index using HNSW (recommended for performance)\n      await client.query(`\n        CREATE INDEX IF NOT EXISTS ${indexName}_vector_idx\n        ON ${indexName} USING hnsw (embedding ${operator})\n      `);\n    } catch (error) {\n      this.logger.error(`Failed to create vector table: ${error}`);\n      throw error;\n    }\n  }\n\n  async deleteIndex(indexName: string): Promise<void> {\n    try {\n      const client = await this.getClient();\n      await client.query(`DROP TABLE IF EXISTS ${indexName}`);\n    } catch (error) {\n      this.logger.error(`Failed to delete vector table: ${error}`);\n      throw error;\n    }\n  }\n\n  async listIndexes(): Promise<string[]> {\n    try {\n      const client = await this.getClient();\n      const vectorTablesQuery = `\n        SELECT tablename FROM pg_tables \n        WHERE tablename IN (\n          SELECT table_name \n          FROM information_schema.columns \n          WHERE data_type = 'USER-DEFINED' AND udt_name = 'vector'\n        )\n      `;\n      const result = await client.query(vectorTablesQuery);\n      return (result.rows || []).map((row: any) => row.tablename as string);\n    } catch (error) {\n      this.logger.error(`Failed to list vector tables: ${error}`);\n      throw error;\n    }\n  }\n\n  async describeIndex(indexName: string): Promise<IndexStats> {\n    try {\n      const client = await this.getClient();\n      \n      // Get dimension from table schema\n      const dimensionQuery = `\n        SELECT a.atttypmod as dimension\n        FROM pg_attribute a\n        JOIN pg_class c ON a.attrelid = c.oid\n        WHERE c.relname = $1 AND a.attname = 'embedding'\n      `;\n      const dimensionResult = await client.query(dimensionQuery, [indexName]);\n      const dimensionRow = dimensionResult.rows?.[0] as any;\n      const dimension = dimensionRow?.dimension || 0;\n\n      // Get row count\n      const countQuery = `SELECT COUNT(*) as count FROM ${indexName}`;\n      const countResult = await client.query(countQuery);\n      const countRow = countResult.rows?.[0] as any;\n      const count = countRow?.count || 0;\n\n      // Get metric type from index\n      const metricQuery = `\n        SELECT amname, opcname\n        FROM pg_index i\n        JOIN pg_class c ON i.indexrelid = c.oid\n        JOIN pg_opclass op ON i.indclass[0] = op.oid\n        JOIN pg_am am ON op.opcmethod = am.oid\n        WHERE c.relname LIKE $1 || '%'\n      `;\n      const metricResult = await client.query(metricQuery, [indexName]);\n      \n      let metric: 'cosine' | 'euclidean' | 'dotproduct' = 'cosine';\n      if (metricResult.rows?.length > 0) {\n        const row = metricResult.rows[0] as any;\n        const opcname = row?.opcname as string;\n        if (opcname?.includes('l2')) {\n          metric = 'euclidean';\n        } else if (opcname?.includes('ip')) {\n          metric = 'dotproduct';\n        }\n        // Default is already 'cosine'\n      }\n\n      return {\n        dimension,\n        count: parseInt(count as string, 10),\n        metric,\n      };\n    } catch (error) {\n      this.logger.error(`Failed to describe vector table: ${error}`);\n      throw error;\n    }\n  }\n\n  async updateIndexById(\n    indexName: string,\n    id: string,\n    update: { vector?: number[]; metadata?: Record<string, any> },\n  ): Promise<void> {\n    try {\n      const client = await this.getClient();\n      const updates = [];\n      const values = [id];\n      let paramIndex = 2;\n\n      if (update.vector) {\n        const vectorLiteral = `[${update.vector.join(',')}]`;\n        updates.push(`embedding = $${paramIndex}::vector`);\n        values.push(vectorLiteral);\n        paramIndex++;\n      }\n\n      if (update.metadata) {\n        updates.push(`metadata = $${paramIndex}::jsonb`);\n        values.push(JSON.stringify(update.metadata));\n        paramIndex++;\n      }\n\n      if (updates.length === 0) {\n        throw new Error('No updates provided');\n      }\n\n      const query = `\n        UPDATE ${indexName}\n        SET ${updates.join(', ')}\n        WHERE vector_id = $1\n      `;\n\n      await client.query(query, values);\n    } catch (error) {\n      this.logger.error(`Failed to update index by id: ${id} for index: ${indexName}: ${error}`);\n      throw error;\n    }\n  }\n\n  async deleteIndexById(indexName: string, id: string): Promise<void> {\n    try {\n      const client = await this.getClient();\n      await client.query(`DELETE FROM ${indexName} WHERE vector_id = $1`, [id]);\n    } catch (error) {\n      this.logger.error(`Failed to delete index by id: ${id} for index: ${indexName}: ${error}`);\n      throw error;\n    }\n  }\n\n  async truncateIndex(indexName: string) {\n    try {\n      const client = await this.getClient();\n      await client.query(`DELETE FROM ${indexName}`);\n    } catch (error) {\n      this.logger.error(`Failed to truncate index: ${indexName}: ${error}`);\n      throw error;\n    }\n  }\n}\n\nexport { PGliteVector as DefaultVectorDB };\n","// import { existsSync } from 'fs';\n// import { join } from 'path';\nimport type {\n  AssistantContent,\n  ToolResultPart,\n  UserContent,\n  CoreToolMessage,\n  ToolInvocation,\n  CoreMessage,\n  EmbeddingModel,\n} from 'ai';\n\nimport { MastraBase } from '../base';\nimport type { MastraStorage, StorageGetMessagesArg } from '../storage';\nimport { DefaultProxyStorage } from '../storage/default-proxy-storage';\nimport type { CoreTool } from '../tools';\nimport { deepMerge } from '../utils';\nimport type { MastraVector } from '../vector';\n// import { defaultEmbedder } from '../vector/fastembed';\n// import { DefaultVectorDB } from '../vector/libsql';\nimport { DefaultVectorDB } from '../vector/pglite';\n\nimport type { MessageType, SharedMemoryConfig, StorageThreadType, MemoryConfig, AiMessageType } from './types';\n\n/**\n * Abstract Memory class that defines the interface for storing and retrieving\n * conversation threads and messages.\n */\nexport abstract class MastraMemory extends MastraBase {\n  MAX_CONTEXT_TOKENS?: number;\n\n  storage: MastraStorage;\n  vector: MastraVector;\n  embedder: EmbeddingModel<string>;\n\n  protected threadConfig: MemoryConfig = {\n    lastMessages: 40,\n    semanticRecall: true,\n    threads: {\n      generateTitle: true, // TODO: should we disable this by default to reduce latency?\n    },\n  };\n\n  constructor(config: { name: string } & SharedMemoryConfig) {\n    super({ component: 'MEMORY', name: config.name });\n\n    this.storage =\n      config.storage ||\n      new DefaultProxyStorage({\n        config: {\n          url: 'file:memory.db',\n        },\n      });\n\n    if (config.vector) {\n      this.vector = config.vector;\n    } else {\n      // // for backwards compat reasons, check if there's a memory-vector.db in cwd or in cwd/.mastra\n      // // if it's there we need to use it, otherwise use the same file:memory.db\n      // // We used to need two separate DBs because we would get schema errors\n      // // Creating a new index for each vector dimension size fixed that, so we no longer need a separate sqlite db\n      // const oldDb = 'memory-vector.db';\n      // const hasOldDb = existsSync(join(process.cwd(), oldDb)) || existsSync(join(process.cwd(), '.mastra', oldDb));\n      // const newDb = 'memory.db';\n\n      // if (hasOldDb) {\n      //   this.logger.warn(\n      //     `Found deprecated Memory vector db file ${oldDb} this db is now merged with the default ${newDb} file. Delete the old one to use the new one. You will need to migrate any data if that's important to you. For now the deprecated path will be used but in a future breaking change we will only use the new db file path.`,\n      //   );\n      // }\n\n      // this.vector = new DefaultVectorDB({\n      //   connectionUrl: hasOldDb ? `file:${oldDb}` : `file:${newDb}`,\n      // });\n      this.vector = new DefaultVectorDB({\n        connectionUrl: ':memory:',\n      });\n    }\n\n    if (config.embedder) {\n      this.embedder = config.embedder;\n    } else {\n      // this.embedder = defaultEmbedder('bge-small-en-v1.5'); // https://huggingface.co/BAAI/bge-small-en-v1.5#model-list we're using small 1.5 because it's much faster than base 1.5 and only scores slightly worse despite being roughly 100MB smaller - small is ~130MB while base is ~220MB\n      throw new Error('Embedder config is required');\n    }\n\n    if (config.options) {\n      this.threadConfig = this.getMergedThreadConfig(config.options);\n    }\n  }\n\n  public setStorage(storage: MastraStorage) {\n    this.storage = storage;\n  }\n\n  public setVector(vector: MastraVector) {\n    this.vector = vector;\n  }\n\n  public setEmbedder(embedder: EmbeddingModel<string>) {\n    this.embedder = embedder;\n  }\n\n  /**\n   * Get a system message to inject into the conversation.\n   * This will be called before each conversation turn.\n   * Implementations can override this to inject custom system messages.\n   */\n  public async getSystemMessage(_input: { threadId: string; memoryConfig?: MemoryConfig }): Promise<string | null> {\n    return null;\n  }\n\n  /**\n   * Get tools that should be available to the agent.\n   * This will be called when converting tools for the agent.\n   * Implementations can override this to provide additional tools.\n   */\n  public getTools(_config?: MemoryConfig): Record<string, CoreTool> {\n    return {};\n  }\n\n  protected async createEmbeddingIndex(): Promise<{ indexName: string }> {\n    const defaultDimensions = 1536;\n\n    // AI SDK doesn't expose a way to check how many dimensions a model uses.\n    const dimensionsByModelId: Record<string, number> = {\n      'bge-small-en-v1.5': 384,\n      'bge-base-en-v1.5': 768,\n      'voyage-3-lite': 512\n    };\n\n    const dimensions = dimensionsByModelId[this.embedder.modelId] || defaultDimensions;\n    const isDefault = dimensions === defaultDimensions;\n    const indexName = isDefault ? 'memory_messages' : `memory_messages_${dimensions}`;\n\n    await this.vector.createIndex({ indexName, dimension: dimensions });\n    return { indexName };\n  }\n\n  public getMergedThreadConfig(config?: MemoryConfig): MemoryConfig {\n    return deepMerge(this.threadConfig, config || {});\n  }\n\n  abstract rememberMessages({\n    threadId,\n    resourceId,\n    vectorMessageSearch,\n    config,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    vectorMessageSearch?: string;\n    config?: MemoryConfig;\n  }): Promise<{\n    threadId: string;\n    messages: CoreMessage[];\n    uiMessages: AiMessageType[];\n  }>;\n\n  estimateTokens(text: string): number {\n    return Math.ceil(text.split(' ').length * 1.3);\n  }\n\n  protected parseMessages(messages: MessageType[]): CoreMessage[] {\n    return messages.map(msg => ({\n      ...msg,\n      content:\n        typeof msg.content === 'string' && (msg.content.startsWith('[') || msg.content.startsWith('{'))\n          ? JSON.parse((msg as MessageType).content as string)\n          : typeof msg.content === 'number'\n            ? String(msg.content)\n            : msg.content,\n    }));\n  }\n\n  protected convertToUIMessages(messages: MessageType[]): AiMessageType[] {\n    function addToolMessageToChat({\n      toolMessage,\n      messages,\n      toolResultContents,\n    }: {\n      toolMessage: CoreToolMessage;\n      messages: Array<AiMessageType>;\n      toolResultContents: Array<ToolResultPart>;\n    }): { chatMessages: Array<AiMessageType>; toolResultContents: Array<ToolResultPart> } {\n      const chatMessages = messages.map(message => {\n        if (message.toolInvocations) {\n          return {\n            ...message,\n            toolInvocations: message.toolInvocations.map(toolInvocation => {\n              const toolResult = toolMessage.content.find(tool => tool.toolCallId === toolInvocation.toolCallId);\n\n              if (toolResult) {\n                return {\n                  ...toolInvocation,\n                  state: 'result',\n                  result: toolResult.result,\n                };\n              }\n\n              return toolInvocation;\n            }),\n          };\n        }\n\n        return message;\n      }) as Array<AiMessageType>;\n\n      const resultContents = [...toolResultContents, ...toolMessage.content];\n\n      return { chatMessages, toolResultContents: resultContents };\n    }\n\n    const { chatMessages } = messages.reduce(\n      (obj: { chatMessages: Array<AiMessageType>; toolResultContents: Array<ToolResultPart> }, message) => {\n        if (message.role === 'tool') {\n          return addToolMessageToChat({\n            toolMessage: message as CoreToolMessage,\n            messages: obj.chatMessages,\n            toolResultContents: obj.toolResultContents,\n          });\n        }\n\n        let textContent = '';\n        let toolInvocations: Array<ToolInvocation> = [];\n\n        if (typeof message.content === 'string') {\n          textContent = message.content;\n        } else if (typeof message.content === 'number') {\n          textContent = String(message.content);\n        } else if (Array.isArray(message.content)) {\n          for (const content of message.content) {\n            if (content.type === 'text') {\n              textContent += content.text;\n            } else if (content.type === 'tool-call') {\n              const toolResult = obj.toolResultContents.find(tool => tool.toolCallId === content.toolCallId);\n              toolInvocations.push({\n                state: toolResult ? 'result' : 'call',\n                toolCallId: content.toolCallId,\n                toolName: content.toolName,\n                args: content.args,\n                result: toolResult?.result,\n              });\n            }\n          }\n        }\n\n        obj.chatMessages.push({\n          id: (message as MessageType).id,\n          role: message.role as AiMessageType['role'],\n          content: textContent,\n          toolInvocations,\n        });\n\n        return obj;\n      },\n      { chatMessages: [], toolResultContents: [] } as {\n        chatMessages: Array<AiMessageType>;\n        toolResultContents: Array<ToolResultPart>;\n      },\n    );\n\n    return chatMessages;\n  }\n\n  /**\n   * Retrieves a specific thread by its ID\n   * @param threadId - The unique identifier of the thread\n   * @returns Promise resolving to the thread or null if not found\n   */\n  abstract getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null>;\n\n  abstract getThreadsByResourceId({ resourceId }: { resourceId: string }): Promise<StorageThreadType[]>;\n\n  /**\n   * Saves or updates a thread\n   * @param thread - The thread data to save\n   * @returns Promise resolving to the saved thread\n   */\n  abstract saveThread({\n    thread,\n    memoryConfig,\n  }: {\n    thread: StorageThreadType;\n    memoryConfig?: MemoryConfig;\n  }): Promise<StorageThreadType>;\n\n  /**\n   * Saves messages to a thread\n   * @param messages - Array of messages to save\n   * @returns Promise resolving to the saved messages\n   */\n  abstract saveMessages({\n    messages,\n    memoryConfig,\n  }: {\n    messages: MessageType[];\n    memoryConfig: MemoryConfig | undefined;\n  }): Promise<MessageType[]>;\n\n  /**\n   * Retrieves all messages for a specific thread\n   * @param threadId - The unique identifier of the thread\n   * @returns Promise resolving to array of messages and uiMessages\n   */\n  abstract query({\n    threadId,\n    resourceId,\n    selectBy,\n  }: StorageGetMessagesArg): Promise<{ messages: CoreMessage[]; uiMessages: AiMessageType[] }>;\n\n  /**\n   * Helper method to create a new thread\n   * @param title - Optional title for the thread\n   * @param metadata - Optional metadata for the thread\n   * @returns Promise resolving to the created thread\n   */\n  async createThread({\n    threadId,\n    resourceId,\n    title,\n    metadata,\n    memoryConfig,\n  }: {\n    resourceId: string;\n    threadId?: string;\n    title?: string;\n    metadata?: Record<string, unknown>;\n    memoryConfig?: MemoryConfig;\n  }): Promise<StorageThreadType> {\n    const thread: StorageThreadType = {\n      id: threadId || this.generateId(),\n      title: title || `New Thread ${new Date().toISOString()}`,\n      resourceId,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      metadata,\n    };\n\n    return this.saveThread({ thread, memoryConfig });\n  }\n\n  /**\n   * Helper method to delete a thread\n   * @param threadId - the id of the thread to delete\n   */\n  abstract deleteThread(threadId: string): Promise<void>;\n\n  /**\n   * Helper method to add a single message to a thread\n   * @param threadId - The thread to add the message to\n   * @param content - The message content\n   * @param role - The role of the message sender\n   * @param type - The type of the message\n   * @param toolNames - Optional array of tool names that were called\n   * @param toolCallArgs - Optional array of tool call arguments\n   * @param toolCallIds - Optional array of tool call ids\n   * @returns Promise resolving to the saved message\n   */\n  async addMessage({\n    threadId,\n    config,\n    content,\n    role,\n    type,\n    toolNames,\n    toolCallArgs,\n    toolCallIds,\n  }: {\n    threadId: string;\n    config?: MemoryConfig;\n    content: UserContent | AssistantContent;\n    role: 'user' | 'assistant';\n    type: 'text' | 'tool-call' | 'tool-result';\n    toolNames?: string[];\n    toolCallArgs?: Record<string, unknown>[];\n    toolCallIds?: string[];\n  }): Promise<MessageType> {\n    const message: MessageType = {\n      id: this.generateId(),\n      content,\n      role,\n      createdAt: new Date(),\n      threadId,\n      type,\n      toolNames,\n      toolCallArgs,\n      toolCallIds,\n    };\n\n    const savedMessages = await this.saveMessages({ messages: [message], memoryConfig: config });\n    return savedMessages[0]!;\n  }\n\n  /**\n   * Generates a unique identifier\n   * @returns A unique string ID\n   */\n  public generateId(): string {\n    return crypto.randomUUID();\n  }\n}\n"]}