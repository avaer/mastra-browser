{"version":3,"sources":["../../../src/vector/libsql/filter.ts","../../../src/vector/libsql/sql-builder.ts","../../../src/vector/libsql/index.ts"],"names":["BaseFilterTranslator","result","__name","traverse","conditions","operator","operatorValue","MastraVector","__publicField","isAbsolute","join","resolve"],"mappings":"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","file":"index.cjs","sourcesContent":["import { BaseFilterTranslator } from '../filter';\nimport type { FieldCondition, VectorFilter, OperatorSupport } from '../filter';\n\n/**\n * Translates MongoDB-style filters to LibSQL compatible filters.\n *\n * Key differences from MongoDB:\n *\n * Logical Operators ($and, $or, $nor):\n * - Can be used at the top level or nested within fields\n * - Can take either a single condition or an array of conditions\n *\n */\nexport class LibSQLFilterTranslator extends BaseFilterTranslator {\n  protected override getSupportedOperators(): OperatorSupport {\n    return {\n      ...BaseFilterTranslator.DEFAULT_OPERATORS,\n      regex: [],\n      custom: ['$contains', '$size'],\n    };\n  }\n\n  translate(filter?: VectorFilter): VectorFilter {\n    if (this.isEmpty(filter)) {\n      return filter;\n    }\n    this.validateFilter(filter);\n    return this.translateNode(filter);\n  }\n\n  private translateNode(node: VectorFilter | FieldCondition, currentPath: string = ''): any {\n    if (this.isRegex(node)) {\n      throw new Error('Direct regex pattern format is not supported in LibSQL');\n    }\n    // Helper to wrap result with path if needed\n    const withPath = (result: any) => (currentPath ? { [currentPath]: result } : result);\n\n    // Handle primitives\n    if (this.isPrimitive(node)) {\n      return withPath({ $eq: this.normalizeComparisonValue(node) });\n    }\n\n    // Handle arrays\n    if (Array.isArray(node)) {\n      return withPath({ $in: this.normalizeArrayValues(node) });\n    }\n\n    // Handle regex\n    // TODO: Look more into regex support for LibSQL\n    // if (node instanceof RegExp) {\n    //   return withPath(this.translateRegexPattern(node.source, node.flags));\n    // }\n\n    const entries = Object.entries(node as Record<string, any>);\n    const result: Record<string, any> = {};\n\n    // if ('$options' in node && !('$regex' in node)) {\n    //   throw new Error('$options is not valid without $regex');\n    // }\n\n    // TODO: Look more into regex support for LibSQL\n    // // Handle special regex object format\n    // if ('$regex' in node) {\n    //   const options = (node as any).$options || '';\n    //   return withPath(this.translateRegexPattern(node.$regex, options));\n    // }\n\n    // Process remaining entries\n    for (const [key, value] of entries) {\n      // // Skip options as they're handled with $regex\n      // if (key === '$options') continue;\n\n      const newPath = currentPath ? `${currentPath}.${key}` : key;\n\n      if (this.isLogicalOperator(key)) {\n        result[key] = Array.isArray(value)\n          ? value.map((filter: VectorFilter) => this.translateNode(filter))\n          : this.translateNode(value);\n      } else if (this.isOperator(key)) {\n        if (this.isArrayOperator(key) && !Array.isArray(value) && key !== '$elemMatch') {\n          result[key] = [value];\n        } else if (this.isBasicOperator(key) && Array.isArray(value)) {\n          result[key] = JSON.stringify(value);\n        } else {\n          result[key] = value;\n        }\n      } else if (typeof value === 'object' && value !== null) {\n        // Handle nested objects\n        const hasOperators = Object.keys(value).some(k => this.isOperator(k));\n        if (hasOperators) {\n          result[newPath] = this.translateNode(value);\n        } else {\n          Object.assign(result, this.translateNode(value, newPath));\n        }\n      } else {\n        result[newPath] = this.translateNode(value);\n      }\n    }\n\n    return result;\n  }\n\n  // TODO: Look more into regex support for LibSQL\n  // private translateRegexPattern(pattern: string, options: string = ''): any {\n  //   if (!options) return { $regex: pattern };\n\n  //   const flags = options\n  //     .split('')\n  //     .filter(f => 'imsux'.includes(f))\n  //     .join('');\n\n  //   return {\n  //     $regex: pattern,\n  //     $options: flags,\n  //   };\n  // }\n}\n","import type { InValue } from '@libsql/client';\n\nimport type {\n  BasicOperator,\n  NumericOperator,\n  ArrayOperator,\n  ElementOperator,\n  LogicalOperator,\n  RegexOperator,\n  VectorFilter,\n} from '../filter';\n\nexport type OperatorType =\n  | BasicOperator\n  | NumericOperator\n  | ArrayOperator\n  | ElementOperator\n  | LogicalOperator\n  | '$contains'\n  | Exclude<RegexOperator, '$options'>;\n\ntype FilterOperator = {\n  sql: string;\n  needsValue: boolean;\n  transformValue?: (value: any) => any;\n};\n\ntype OperatorFn = (key: string, value?: any) => FilterOperator;\n\n// Helper functions to create operators\nconst createBasicOperator = (symbol: string) => {\n  return (key: string): FilterOperator => ({\n    sql: `CASE \n      WHEN ? IS NULL THEN json_extract(metadata, '$.\"${handleKey(key)}\"') IS ${symbol === '=' ? '' : 'NOT'} NULL\n      ELSE json_extract(metadata, '$.\"${handleKey(key)}\"') ${symbol} ?\n    END`,\n    needsValue: true,\n    transformValue: (value: any) => {\n      // Return the values directly, not in an object\n      return [value, value];\n    },\n  });\n};\nconst createNumericOperator = (symbol: string) => {\n  return (key: string): FilterOperator => ({\n    sql: `CAST(json_extract(metadata, '$.\"${handleKey(key)}\"') AS NUMERIC) ${symbol} ?`,\n    needsValue: true,\n  });\n};\n\nconst validateJsonArray = (key: string) =>\n  `json_valid(json_extract(metadata, '$.\"${handleKey(key)}\"'))\n   AND json_type(json_extract(metadata, '$.\"${handleKey(key)}\"')) = 'array'`;\n\n// Define all filter operators\nexport const FILTER_OPERATORS: Record<string, OperatorFn> = {\n  $eq: createBasicOperator('='),\n  $ne: createBasicOperator('!='),\n  $gt: createNumericOperator('>'),\n  $gte: createNumericOperator('>='),\n  $lt: createNumericOperator('<'),\n  $lte: createNumericOperator('<='),\n\n  // Array Operators\n  $in: (key: string, value: any) => ({\n    sql: `json_extract(metadata, '$.\"${handleKey(key)}\"') IN (${value.map(() => '?').join(',')})`,\n    needsValue: true,\n  }),\n\n  $nin: (key: string, value: any) => ({\n    sql: `json_extract(metadata, '$.\"${handleKey(key)}\"') NOT IN (${value.map(() => '?').join(',')})`,\n    needsValue: true,\n  }),\n  $all: (key: string) => ({\n    sql: `json_extract(metadata, '$.\"${handleKey(key)}\"') = ?`,\n    needsValue: true,\n    transformValue: (value: any) => {\n      const arrayValue = Array.isArray(value) ? value : [value];\n      if (arrayValue.length === 0) {\n        return {\n          sql: '1 = 0',\n          values: [],\n        };\n      }\n\n      return {\n        sql: `(\n          CASE\n            WHEN ${validateJsonArray(key)} THEN\n                NOT EXISTS (\n                    SELECT value \n                    FROM json_each(?) \n                    WHERE value NOT IN (\n                    SELECT value \n                    FROM json_each(json_extract(metadata, '$.\"${handleKey(key)}\"'))\n                )\n            )\n            ELSE FALSE\n          END\n        )`,\n        values: [JSON.stringify(arrayValue)],\n      };\n    },\n  }),\n  $elemMatch: (key: string) => ({\n    sql: `json_extract(metadata, '$.\"${handleKey(key)}\"') = ?`,\n    needsValue: true,\n    transformValue: (value: any) => {\n      if (typeof value !== 'object' || Array.isArray(value)) {\n        throw new Error('$elemMatch requires an object with conditions');\n      }\n\n      // For nested object conditions\n      const conditions = Object.entries(value).map(([field, fieldValue]) => {\n        if (field.startsWith('$')) {\n          // Direct operators on array elements ($in, $gt, etc)\n          const { sql, values } = buildCondition('elem.value', { [field]: fieldValue }, '');\n          // Replace the metadata path with elem.value\n          const pattern = /json_extract\\(metadata, '\\$\\.\"[^\"]*\"(\\.\"[^\"]*\")*'\\)/g;\n          const elemSql = sql.replace(pattern, 'elem.value');\n          return { sql: elemSql, values };\n        } else if (typeof fieldValue === 'object' && !Array.isArray(fieldValue)) {\n          // Nested field with operators (count: { $gt: 20 })\n          const { sql, values } = buildCondition(field, fieldValue, '');\n          // Replace the field path with elem.value path\n          const pattern = /json_extract\\(metadata, '\\$\\.\"[^\"]*\"(\\.\"[^\"]*\")*'\\)/g;\n          const elemSql = sql.replace(pattern, `json_extract(elem.value, '$.\"${field}\"')`);\n          return { sql: elemSql, values };\n        } else {\n          // Simple field equality (warehouse: 'A')\n          return {\n            sql: `json_extract(elem.value, '$.\"${field}\"') = ?`,\n            values: [fieldValue],\n          };\n        }\n      });\n\n      return {\n        sql: `(\n          CASE\n            WHEN ${validateJsonArray(key)} THEN\n              EXISTS (\n                SELECT 1 \n                FROM json_each(json_extract(metadata, '$.\"${handleKey(key)}\"')) as elem\n                WHERE ${conditions.map(c => c.sql).join(' AND ')}\n              )\n            ELSE FALSE\n          END\n        )`,\n        values: conditions.flatMap(c => c.values),\n      };\n    },\n  }),\n\n  // Element Operators\n  $exists: (key: string) => ({\n    sql: `json_extract(metadata, '$.\"${handleKey(key)}\"') IS NOT NULL`,\n    needsValue: false,\n  }),\n\n  // Logical Operators\n  $and: (key: string) => ({\n    sql: `(${key})`,\n    needsValue: false,\n  }),\n  $or: (key: string) => ({\n    sql: `(${key})`,\n    needsValue: false,\n  }),\n  $not: key => ({ sql: `NOT (${key})`, needsValue: false }),\n  $nor: (key: string) => ({\n    sql: `NOT (${key})`,\n    needsValue: false,\n  }),\n  $size: (key: string, paramIndex: number) => ({\n    sql: `(\n    CASE\n      WHEN json_type(json_extract(metadata, '$.\"${handleKey(key)}\"')) = 'array' THEN \n        json_array_length(json_extract(metadata, '$.\"${handleKey(key)}\"')) = $${paramIndex}\n      ELSE FALSE\n    END\n  )`,\n    needsValue: true,\n  }),\n  //   /**\n  //    * Regex Operators\n  //    * Supports case insensitive and multiline\n  //    */\n  //   $regex: (key: string): FilterOperator => ({\n  //     sql: `json_extract(metadata, '$.\"${handleKey(key)}\"') = ?`,\n  //     needsValue: true,\n  //     transformValue: (value: any) => {\n  //       const pattern = typeof value === 'object' ? value.$regex : value;\n  //       const options = typeof value === 'object' ? value.$options || '' : '';\n  //       let sql = `json_extract(metadata, '$.\"${handleKey(key)}\"')`;\n\n  //       // Handle multiline\n  //       //   if (options.includes('m')) {\n  //       //     sql = `REPLACE(${sql}, CHAR(10), '\\n')`;\n  //       //   }\n\n  //       //       let finalPattern = pattern;\n  //       // if (options) {\n  //       //   finalPattern = `(\\\\?${options})${pattern}`;\n  //       // }\n\n  //       //   // Handle case insensitivity\n  //       //   if (options.includes('i')) {\n  //       //     sql = `LOWER(${sql}) REGEXP LOWER(?)`;\n  //       //   } else {\n  //       //     sql = `${sql} REGEXP ?`;\n  //       //   }\n\n  //       if (options.includes('m')) {\n  //         sql = `EXISTS (\n  //         SELECT 1\n  //         FROM json_each(\n  //           json_array(\n  //             ${sql},\n  //             REPLACE(${sql}, CHAR(10), CHAR(13))\n  //           )\n  //         ) as lines\n  //         WHERE lines.value REGEXP ?\n  //       )`;\n  //       } else {\n  //         sql = `${sql} REGEXP ?`;\n  //       }\n\n  //       // Handle case insensitivity\n  //       if (options.includes('i')) {\n  //         sql = sql.replace('REGEXP ?', 'REGEXP LOWER(?)');\n  //         sql = sql.replace('value REGEXP', 'LOWER(value) REGEXP');\n  //       }\n\n  //       // Handle extended - allows whitespace and comments in pattern\n  //       if (options.includes('x')) {\n  //         // Remove whitespace and comments from pattern\n  //         const cleanPattern = pattern.replace(/\\s+|#.*$/gm, '');\n  //         return {\n  //           sql,\n  //           values: [cleanPattern],\n  //         };\n  //       }\n\n  //       return {\n  //         sql,\n  //         values: [pattern],\n  //       };\n  //     },\n  //   }),\n  $contains: (key: string) => ({\n    sql: `json_extract(metadata, '$.\"${handleKey(key)}\"') = ?`,\n    needsValue: true,\n    transformValue: (value: any) => {\n      // Array containment\n      if (Array.isArray(value)) {\n        return {\n          sql: `(\n            SELECT ${validateJsonArray(key)}\n            AND EXISTS (\n              SELECT 1 \n              FROM json_each(json_extract(metadata, '$.\"${handleKey(key)}\"')) as m\n              WHERE m.value IN (SELECT value FROM json_each(?))\n            )\n          )`,\n          values: [JSON.stringify(value)],\n        };\n      }\n\n      // Nested object traversal\n      if (value && typeof value === 'object') {\n        const paths: string[] = [];\n        const values: any[] = [];\n\n        function traverse(obj: any, path: string[] = []) {\n          for (const [k, v] of Object.entries(obj)) {\n            const currentPath = [...path, k];\n            if (v && typeof v === 'object' && !Array.isArray(v)) {\n              traverse(v, currentPath);\n            } else {\n              paths.push(currentPath.join('.'));\n              values.push(v);\n            }\n          }\n        }\n\n        traverse(value);\n        return {\n          sql: `(${paths.map(path => `json_extract(metadata, '$.\"${handleKey(key)}\".\"${path}\"') = ?`).join(' AND ')})`,\n          values,\n        };\n      }\n\n      return value;\n    },\n  }),\n};\n\nexport interface FilterResult {\n  sql: string;\n  values: InValue[];\n}\n\nexport const handleKey = (key: string) => {\n  return key.replace(/\\./g, '\".\"');\n};\n\nexport function buildFilterQuery(filter: VectorFilter): FilterResult {\n  if (!filter) {\n    return { sql: '', values: [] };\n  }\n\n  const values: InValue[] = [];\n  const conditions = Object.entries(filter)\n    .map(([key, value]) => {\n      const condition = buildCondition(key, value, '');\n      values.push(...condition.values);\n      return condition.sql;\n    })\n    .join(' AND ');\n\n  return {\n    sql: conditions ? `WHERE ${conditions}` : '',\n    values,\n  };\n}\n\nfunction buildCondition(key: string, value: any, parentPath: string): FilterResult {\n  // Handle logical operators ($and/$or)\n  if (['$and', '$or', '$not', '$nor'].includes(key)) {\n    return handleLogicalOperator(key as '$and' | '$or' | '$not' | '$nor', value, parentPath);\n  }\n\n  // If condition is not a FilterCondition object, assume it's an equality check\n  if (!value || typeof value !== 'object') {\n    return {\n      sql: `json_extract(metadata, '$.\"${key.replace(/\\./g, '\".\"')}\"') = ?`,\n      values: [value],\n    };\n  }\n\n  //TODO: Add regex support\n  //   if ('$regex' in value) {\n  //     return handleRegexOperator(key, value);\n  //   }\n\n  // Handle operator conditions\n  return handleOperator(key, value);\n}\n\n// function handleRegexOperator(key: string, value: any): FilterResult {\n//   const operatorFn = FILTER_OPERATORS['$regex']!;\n//   const operatorResult = operatorFn(key, value);\n//   const transformed = operatorResult.transformValue ? operatorResult.transformValue(value) : value;\n\n//   return {\n//     sql: transformed.sql,\n//     values: transformed.values,\n//   };\n// }\n\nfunction handleLogicalOperator(\n  key: '$and' | '$or' | '$not' | '$nor',\n  value: VectorFilter[] | VectorFilter,\n  parentPath: string,\n): FilterResult {\n  // Handle empty conditions\n  if (!value || value.length === 0) {\n    switch (key) {\n      case '$and':\n      case '$nor':\n        return { sql: 'true', values: [] };\n      case '$or':\n        return { sql: 'false', values: [] };\n      case '$not':\n        throw new Error('$not operator cannot be empty');\n      default:\n        return { sql: 'true', values: [] };\n    }\n  }\n\n  if (key === '$not') {\n    // For top-level $not\n    const entries = Object.entries(value);\n    const conditions = entries.map(([fieldKey, fieldValue]) => buildCondition(fieldKey, fieldValue, key));\n    return {\n      sql: `NOT (${conditions.map(c => c.sql).join(' AND ')})`,\n      values: conditions.flatMap(c => c.values),\n    };\n  }\n\n  const values: InValue[] = [];\n  const joinOperator = key === '$or' || key === '$nor' ? 'OR' : 'AND';\n  const conditions = Array.isArray(value)\n    ? value.map(f => {\n        const entries = Object.entries(f);\n        return entries.map(([k, v]) => buildCondition(k, v, key));\n      })\n    : [buildCondition(key, value, parentPath)];\n\n  const joined = conditions\n    .flat()\n    .map(c => {\n      values.push(...c.values);\n      return c.sql;\n    })\n    .join(` ${joinOperator} `);\n\n  return {\n    sql: key === '$nor' ? `NOT (${joined})` : `(${joined})`,\n    values,\n  };\n}\n\nfunction handleOperator(key: string, value: any): FilterResult {\n  if (typeof value === 'object' && !Array.isArray(value)) {\n    const entries = Object.entries(value);\n    const results = entries.map(([operator, operatorValue]) =>\n      operator === '$not'\n        ? {\n            sql: `NOT (${Object.entries(operatorValue as Record<string, any>)\n              .map(([op, val]) => processOperator(key, op, val).sql)\n              .join(' AND ')})`,\n            values: Object.entries(operatorValue as Record<string, any>).flatMap(\n              ([op, val]) => processOperator(key, op, val).values,\n            ),\n          }\n        : processOperator(key, operator, operatorValue),\n    );\n\n    return {\n      sql: `(${results.map(r => r.sql).join(' AND ')})`,\n      values: results.flatMap(r => r.values),\n    };\n  }\n\n  // Handle single operator\n  const [[operator, operatorValue] = []] = Object.entries(value);\n  return processOperator(key, operator as string, operatorValue);\n}\n\nconst processOperator = (key: string, operator: string, operatorValue: any): FilterResult => {\n  if (!operator.startsWith('$') || !FILTER_OPERATORS[operator]) {\n    throw new Error(`Invalid operator: ${operator}`);\n  }\n  const operatorFn = FILTER_OPERATORS[operator]!;\n  const operatorResult = operatorFn(key, operatorValue);\n\n  if (!operatorResult.needsValue) {\n    return { sql: operatorResult.sql, values: [] };\n  }\n\n  const transformed = operatorResult.transformValue ? operatorResult.transformValue(operatorValue) : operatorValue;\n\n  if (transformed && typeof transformed === 'object' && 'sql' in transformed) {\n    return transformed;\n  }\n\n  return {\n    sql: operatorResult.sql,\n    values: Array.isArray(transformed) ? transformed : [transformed],\n  };\n};\n","import { join, resolve, isAbsolute } from 'path';\n// import { createClient } from '@libsql/client';\n// import type { Client as TursoClient, InValue } from '@libsql/client';\n\nimport type { VectorFilter } from '../filter';\nimport { MastraVector } from '../index';\nimport type {\n  CreateIndexParams,\n  IndexStats,\n  QueryVectorParams,\n  QueryResult,\n  UpsertVectorParams,\n  ParamsToArgs,\n  QueryVectorArgs,\n} from '../index';\n\nimport { LibSQLFilterTranslator } from './filter';\nimport { buildFilterQuery } from './sql-builder';\n\ninterface LibSQLQueryParams extends QueryVectorParams {\n  minScore?: number;\n}\n\ntype LibSQLQueryArgs = [...QueryVectorArgs, number?];\n\nexport class LibSQLVector extends MastraVector {\n  private turso: any;\n\n  constructor({\n    connectionUrl,\n    authToken,\n    syncUrl,\n    syncInterval,\n  }: {\n    connectionUrl: string;\n    authToken?: string;\n    syncUrl?: string;\n    syncInterval?: number;\n  }) {\n    super();\n\n    // this.turso = createClient({\n    //   url: this.rewriteDbUrl(connectionUrl),\n    //   syncUrl: syncUrl,\n    //   authToken,\n    //   syncInterval,\n    // });\n    this.turso = null;\n  }\n\n  // If we're in the .mastra/output directory, use the dir outside .mastra dir\n  // reason we need to do this is libsql relative file paths are based on cwd, not current file path\n  // since mastra dev sets cwd to .mastra/output this means running an agent directly vs running with mastra dev\n  // will put db files in different locations, leading to an inconsistent experience between the two.\n  // Ex: with `file:ex.db`\n  // 1. `mastra dev`: ${cwd}/.mastra/output/ex.db\n  // 2. `tsx src/index.ts`: ${cwd}/ex.db\n  // so if we're in .mastra/output we need to rewrite the file url to be relative to the project root dir\n  // or the experience will be inconsistent\n  // this means `file:` urls are always relative to project root\n  // TODO: can we make this easier via bundling? https://github.com/mastra-ai/mastra/pull/2783#pullrequestreview-2662444241\n  protected rewriteDbUrl(url: string): string {\n    if (url.startsWith('file:')) {\n      const pathPart = url.slice('file:'.length);\n\n      if (isAbsolute(pathPart)) {\n        return url;\n      }\n\n      const cwd = process.cwd();\n\n      if (cwd.includes('.mastra') && (cwd.endsWith(`output`) || cwd.endsWith(`output/`) || cwd.endsWith(`output\\\\`))) {\n        const baseDir = join(cwd, `..`, `..`); // <- .mastra/output/../../\n\n        const fullPath = resolve(baseDir, pathPart);\n\n        this.logger.debug(\n          `Initializing LibSQL db with url ${url} with relative file path from inside .mastra/output directory. Rewriting relative file url to \"file:${fullPath}\". This ensures it's outside the .mastra/output directory.`,\n        );\n\n        return `file:${fullPath}`;\n      }\n    }\n\n    return url;\n  }\n\n  transformFilter(filter?: VectorFilter) {\n    const translator = new LibSQLFilterTranslator();\n    return translator.translate(filter);\n  }\n\n  async query(...args: ParamsToArgs<LibSQLQueryParams> | LibSQLQueryArgs): Promise<QueryResult[]> {\n    const params = this.normalizeArgs<LibSQLQueryParams, LibSQLQueryArgs>('query', args, ['minScore']);\n\n    try {\n      const { indexName, queryVector, topK = 10, filter, includeVector = false, minScore = 0 } = params;\n\n      const vectorStr = `[${queryVector.join(',')}]`;\n\n      const translatedFilter = this.transformFilter(filter);\n      const { sql: filterQuery, values: filterValues } = buildFilterQuery(translatedFilter);\n      filterValues.push(minScore);\n\n      const query = `\n        WITH vector_scores AS (\n          SELECT\n            vector_id as id,\n            (1-vector_distance_cos(embedding, '${vectorStr}')) as score,\n            metadata\n            ${includeVector ? ', vector_extract(embedding) as embedding' : ''}\n          FROM ${indexName}\n          ${filterQuery}\n        )\n        SELECT *\n        FROM vector_scores\n        WHERE score > ?\n        ORDER BY score DESC\n        LIMIT ${topK}`;\n\n      const result = await this.turso.execute({\n        sql: query,\n        args: filterValues,\n      });\n\n      return result.rows.map(({ id, score, metadata, embedding }: {\n        id: any,\n        score: any,\n        metadata: any,\n        embedding: any,\n      }) => ({\n        id: id as string,\n        score: score as number,\n        metadata: JSON.parse((metadata as string) ?? '{}'),\n        ...(includeVector && embedding && { vector: JSON.parse(embedding as string) }),\n      }));\n    } finally {\n      // client.release()\n    }\n  }\n\n  async upsert(...args: ParamsToArgs<UpsertVectorParams>): Promise<string[]> {\n    const params = this.normalizeArgs<UpsertVectorParams>('upsert', args);\n\n    const { indexName, vectors, metadata, ids } = params;\n    const tx = await this.turso.transaction('write');\n\n    try {\n      const vectorIds = ids || vectors.map(() => crypto.randomUUID());\n\n      for (let i = 0; i < vectors.length; i++) {\n        const query = `\n          INSERT INTO ${indexName} (vector_id, embedding, metadata)\n          VALUES (?, vector32(?), ?)\n          ON CONFLICT(vector_id) DO UPDATE SET\n            embedding = vector32(?),\n            metadata = ?\n        `;\n\n        // console.log('INSERTQ', query, [\n        //   vectorIds[i] as InValue,\n        //   JSON.stringify(vectors[i]),\n        //   JSON.stringify(metadata?.[i] || {}),\n        //   JSON.stringify(vectors[i]),\n        //   JSON.stringify(metadata?.[i] || {}),\n        // ]);\n        await tx.execute({\n          sql: query,\n          // @ts-ignore\n          args: [\n            vectorIds[i] as any,\n            JSON.stringify(vectors[i]),\n            JSON.stringify(metadata?.[i] || {}),\n            JSON.stringify(vectors[i]),\n            JSON.stringify(metadata?.[i] || {}),\n          ],\n        });\n      }\n\n      await tx.commit();\n      return vectorIds;\n    } catch (error) {\n      await tx.rollback();\n      throw error;\n    }\n  }\n\n  async createIndex(...args: ParamsToArgs<CreateIndexParams>): Promise<void> {\n    const params = this.normalizeArgs<CreateIndexParams>('createIndex', args);\n\n    const { indexName, dimension } = params;\n    try {\n      // Validate inputs\n      if (!indexName.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/)) {\n        throw new Error('Invalid index name format');\n      }\n      if (!Number.isInteger(dimension) || dimension <= 0) {\n        throw new Error('Dimension must be a positive integer');\n      }\n\n      // Create the table with explicit schema\n      await this.turso.execute({\n        sql: `\n        CREATE TABLE IF NOT EXISTS ${indexName} (\n          id SERIAL PRIMARY KEY,\n          vector_id TEXT UNIQUE NOT NULL,\n          embedding F32_BLOB(${dimension}),\n          metadata TEXT DEFAULT '{}'\n        );\n      `,\n        args: [],\n      });\n\n      await this.turso.execute({\n        sql: `\n        CREATE INDEX IF NOT EXISTS ${indexName}_vector_idx\n        ON ${indexName} (libsql_vector_idx(embedding))\n      `,\n        args: [],\n      });\n    } catch (error: any) {\n      console.error('Failed to create vector table:', error);\n      throw error;\n    } finally {\n      // client.release()\n    }\n  }\n\n  async deleteIndex(indexName: string): Promise<void> {\n    try {\n      // Drop the table\n      await this.turso.execute({\n        sql: `DROP TABLE IF EXISTS ${indexName}`,\n        args: [],\n      });\n    } catch (error: any) {\n      console.error('Failed to delete vector table:', error);\n      throw new Error(`Failed to delete vector table: ${error.message}`);\n    } finally {\n      // client.release()\n    }\n  }\n\n  async listIndexes(): Promise<string[]> {\n    try {\n      const vectorTablesQuery = `\n        SELECT name FROM sqlite_master \n        WHERE type='table' \n        AND sql LIKE '%F32_BLOB%';\n      `;\n      const result = await this.turso.execute({\n        sql: vectorTablesQuery,\n        args: [],\n      });\n      return result.rows.map((row: any) => row.name as string);\n    } catch (error: any) {\n      throw new Error(`Failed to list vector tables: ${error.message}`);\n    }\n  }\n\n  async describeIndex(indexName: string): Promise<IndexStats> {\n    try {\n      // Get table info including column info\n      const tableInfoQuery = `\n        SELECT sql \n        FROM sqlite_master \n        WHERE type='table' \n        AND name = ?;\n      `;\n      const tableInfo = await this.turso.execute({\n        sql: tableInfoQuery,\n        args: [indexName],\n      });\n\n      if (!tableInfo.rows[0]?.sql) {\n        throw new Error(`Table ${indexName} not found`);\n      }\n\n      // Extract dimension from F32_BLOB definition\n      const dimension = parseInt((tableInfo.rows[0].sql as string).match(/F32_BLOB\\((\\d+)\\)/)?.[1] || '0');\n\n      // Get row count\n      const countQuery = `\n        SELECT COUNT(*) as count\n        FROM ${indexName};\n      `;\n      const countResult = await this.turso.execute({\n        sql: countQuery,\n        args: [],\n      });\n\n      // LibSQL only supports cosine similarity currently\n      const metric: 'cosine' | 'euclidean' | 'dotproduct' = 'cosine';\n\n      return {\n        dimension,\n        count: (countResult?.rows?.[0]?.count as number) ?? 0,\n        metric,\n      };\n    } catch (e: any) {\n      throw new Error(`Failed to describe vector table: ${e.message}`);\n    }\n  }\n\n  /**\n   * Updates an index entry by its ID with the provided vector and/or metadata.\n   *\n   * @param indexName - The name of the index to update.\n   * @param id - The ID of the index entry to update.\n   * @param update - An object containing the vector and/or metadata to update.\n   * @param update.vector - An optional array of numbers representing the new vector.\n   * @param update.metadata - An optional record containing the new metadata.\n   * @returns A promise that resolves when the update is complete.\n   * @throws Will throw an error if no updates are provided or if the update operation fails.\n   */\n  async updateIndexById(\n    indexName: string,\n    id: string,\n    update: { vector?: number[]; metadata?: Record<string, any> },\n  ): Promise<void> {\n    try {\n      const updates = [];\n      const args: any[] = [];\n\n      if (update.vector) {\n        updates.push('embedding = vector32(?)');\n        args.push(JSON.stringify(update.vector));\n      }\n\n      if (update.metadata) {\n        updates.push('metadata = ?');\n        args.push(JSON.stringify(update.metadata));\n      }\n\n      if (updates.length === 0) {\n        throw new Error('No updates provided');\n      }\n\n      args.push(id);\n\n      const query = `\n        UPDATE ${indexName}\n        SET ${updates.join(', ')}\n        WHERE vector_id = ?;\n      `;\n\n      await this.turso.execute({\n        sql: query,\n        args,\n      });\n    } catch (error: any) {\n      throw new Error(`Failed to update index by id: ${id} for index: ${indexName}: ${error.message}`);\n    }\n  }\n\n  async deleteIndexById(indexName: string, id: string): Promise<void> {\n    try {\n      await this.turso.execute({\n        sql: `DELETE FROM ${indexName} WHERE vector_id = ?`,\n        args: [id],\n      });\n    } catch (error: any) {\n      throw new Error(`Failed to delete index by id: ${id} for index: ${indexName}: ${error.message}`);\n    }\n  }\n\n  async truncateIndex(indexName: string) {\n    await this.turso.execute({\n      sql: `DELETE FROM ${indexName}`,\n      args: [],\n    });\n  }\n}\n\nexport { LibSQLVector as DefaultVectorDB };\n"]}